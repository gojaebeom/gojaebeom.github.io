<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jaebeom&#39;s Blog</title>
    <link>http://gojaebeom.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/98c3781dafc67dfe731441beeee5e4ec</url>
      <title>Jaebeom&#39;s Blog</title>
      <link>http://gojaebeom.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>재범의 기술 블로그 입니다.</description>
    <pubDate>Mon, 11 May 2020 03:53:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JAVA - 18. 다형성</title>
      <link>http://gojaebeom.github.io/2020/05/03/java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/</link>
      <guid>http://gojaebeom.github.io/2020/05/03/java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/</guid>
      <pubDate>Sun, 03 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;다형성-Polymorphism&quot;&gt;&lt;a href=&quot;#다형성-Polymorphism&quot; class=&quot;headerlink&quot; title=&quot;다형성(Polymorphism)&quot;&gt;&lt;/a&gt;다형성(Polymorphism)&lt;/h2&gt;&lt;p&gt;다형성은 상속과 깊은 관계가 있다. 객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함으로써 다형성을 프로그램적으로 구현하였다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="다형성-Polymorphism"><a href="#다형성-Polymorphism" class="headerlink" title="다형성(Polymorphism)"></a>다형성(Polymorphism)</h2><p>다형성은 상속과 깊은 관계가 있다. 객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함으로써 다형성을 프로그램적으로 구현하였다.<a id="more"></a></p><h2 id="다형성의-장점"><a href="#다형성의-장점" class="headerlink" title="다형성의 장점"></a>다형성의 장점</h2><p>다양한 여러 클래스를 하나의 자료형(상위 클래스)로 선언하거나 형변환 하여 각 클래스가 동일한 메서드를 오버라이딩 한 경우, 하나의 코드가 다양한 구현을 실행할 수 있다.</p><h2 id="다형성-예제"><a href="#다형성-예제" class="headerlink" title="다형성 예제"></a>다형성 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"동물이 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"사람이 두발로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"강아지가 네발로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"독수리가 날개로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 <code>Animal</code> 클래스를 각 사람 , 강아지, 독수리 클래스가 상속 받아 <code>move</code> 메소드를 제정의(Overriding)하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphismTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal human = <span class="keyword">new</span> Human();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal eagle = <span class="keyword">new</span> Eagle();<span class="comment">//업캐스팅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Human</code>, <code>Dog</code>, <code>Eagle</code> 클래스는 Animal 클래스를 상속받으므로 위와 같이 Animal 참조변수로 형변환하여 참조할 수 있다. 이를 업캐스팅(Up-casting)이라고 한다.</p><p>만약 위와 같은 상황에서 각 객체의 <code>move</code> 메소드를 한번식 호출하는 코드를 작성하라고 한다면 어떻게 할 수 있을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphismTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal human = <span class="keyword">new</span> Human();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal eagle = <span class="keyword">new</span> Eagle();<span class="comment">//업캐스팅</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(human);</span><br><span class="line">        animalList.add(dog);</span><br><span class="line">        animalList.add(eagle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Animal animal : animalList)&#123;</span><br><span class="line">            animal.move();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>human</code>, <code>dog</code>, <code>eagle</code> 은 서로 다른 클래스에서 생성된 객체이다. 하지만 같은 부모클래스형으로 참조되어, 세 객체 모두 <code>ArrayList</code>의 <code>Animal</code> 타입으로 추가될 수 있었다. 이 후 for each 문으로 <code>animal.move()</code> 메소드를 한번 호출한 것으로 세 객체의 move 메소드를 호출하는 것을 볼 수 있다. 이것이 다형성의 장점이다.</p><h2 id="다형성을-사용하지-않은-예제"><a href="#다형성을-사용하지-않은-예제" class="headerlink" title="다형성을 사용하지 않은 예제"></a>다형성을 사용하지 않은 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human human = <span class="keyword">new</span> Human();</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        Eagle eagle = <span class="keyword">new</span> Eagle();</span><br><span class="line"></span><br><span class="line">        human.move();</span><br><span class="line">        dog.move();</span><br><span class="line">        eagle.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 경우 코드의 양으로 보면 더 간단해 보일 수 있다. 하지만 Animal 클래스를 상속받는 다른 클래스가 더 많아진다고 가정해보자. 사람, 개, 독수리 뿐만아니라 동물의 범주에 모두 해당되는 10개체가 넘는 클래스만 정의하면 반복되는 코드량이 더 많아 질 것이다. 프로그램은 코드의 반복적인 작업을 줄이는것이 바람직하다. 이와 같은 관점에서 보면 다형성을 이용하여 작업하는 것이 이후의 코드 관리면에서도 큰 장점을 보인다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/03/java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 17. 메소드 오버라이딩</title>
      <link>http://gojaebeom.github.io/2020/05/02/java/JAVA-17.method%20overriding/</link>
      <guid>http://gojaebeom.github.io/2020/05/02/java/JAVA-17.method%20overriding/</guid>
      <pubDate>Sat, 02 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;메소드-오버라이딩-Method-Overriding-이란&quot;&gt;&lt;a href=&quot;#메소드-오버라이딩-Method-Overriding-이란&quot; class=&quot;headerlink&quot; title=&quot;메소드 오버라이딩(Method Overriding)이란?&quot;&gt;&lt;/a&gt;메소드 오버라이딩(Method Overriding)이란?&lt;/h2&gt;&lt;p&gt;상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="메소드-오버라이딩-Method-Overriding-이란"><a href="#메소드-오버라이딩-Method-Overriding-이란" class="headerlink" title="메소드 오버라이딩(Method Overriding)이란?"></a>메소드 오버라이딩(Method Overriding)이란?</h2><p>상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다. <a id="more"></a></p><p>다음 예제를 통해 메소드 오버라이딩의 결과를 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;<span class="comment">// Cake의 Yummy 메소드를 오버라이딩 함</span></span><br><span class="line">System.out.println(<span class="string">"Yummy Cheese Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeOverriding</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line"></span><br><span class="line">c1.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">c2.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  실행 결과 : Yummy Cheese Cake가 두번 출력 되는 것을 알 수 있다.</p><p>위의 CheeseCake 클래스는 Cake를 상속하면서, Cake에 정의된 yummy메소드와 다음 세 가지가 같은 메소드를 정의하였다.</p><ul><li>메소드의 이름</li><li>메소드의 반환형</li><li>메소드의 매개변수 선언</li></ul><p>위의 세가지가 같아야 메소드 오버라이딩이 성립한다.</p><p>즉 Cake의 yummy 메소드를 CheeseCake의 Yummy 메소드가 오버라이딩 하였다. 그리고 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 오버라이딩된 메소드를 대신하게 된다. </p><p>위의 예제의 main 메소드에서 다음과 같이 Cake 형 참조변수로 CheeseCake 인스턴스를 참조하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();<span class="comment">//업캐스팅</span></span><br></pre></td></tr></table></figure><p>그리고 다음과 같이 yummy 메소드를 호출하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy();</span><br></pre></td></tr></table></figure><p>앞서 설명한 바에 의하면 c1은 Cake형 참조변수이니, 위 문장의 경우 Cake의 yummy 메소드가 호출되어야 한다. CheeseCake 인스턴스를 참조하고 있는 상황이라도 말이다. 그러나 Cake의 yummy 메소드는 오버라이딩 되었다(무효화 되었다). 따라서 이 경우에는 CheeseCake의 yummy 메소드가 대신 호출이 된다.</p><h2 id="메소드-오버라이딩의-일반화"><a href="#메소드-오버라이딩의-일반화" class="headerlink" title="메소드 오버라이딩의 일반화"></a>메소드 오버라이딩의 일반화</h2><p>앞서 설명한 메소드 오버라이딩을 문법적으로 정리하기 위해서 클래스를 다음과 같이 정의하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 클래스를 정의한 경우 CheeseCake의 참조변수와 인스턴스의 생성문을 다음과 같이 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">StrawberryCheeseCake c3 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br></pre></td></tr></table></figure><p>그리고 다음 세 문장이 실행되었을 때 호출되는 메소드는 StrawberryCheeseCake의 yummy 메소드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c2.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c3.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br></pre></td></tr></table></figure><h2 id="오버라이딩된-메소드를-호출하는-방법"><a href="#오버라이딩된-메소드를-호출하는-방법" class="headerlink" title="오버라이딩된 메소드를 호출하는 방법"></a>오버라이딩된 메소드를 호출하는 방법</h2><p>위의 예제들에서도 알 수 있듯이 Cake, CheeseCake에 정의된 yummy 메소드들을 위의 방법처럼 호출하는 것은 불가능하다.</p><p>하지만 클래스 외부가 아닌 내부에서 Cake의 yummy 메소드를 호출하는 방법은 있다. 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch11_상속;</span><br><span class="line"><span class="comment">//오버라이딩 된 메소드를 호출하는 방법 예제</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.yummy();</span><br><span class="line">System.out.println(<span class="string">"Yummy CheeseCake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CheeseCake cake = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">cake.yummy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 상위 클래스의 생성자를 호출할 목적으로 키워드 super를 사용하였다. 그런데 위의 예제에서 보이듯이 상위 클래스에 정의된, 오버라이딩 된 메소드의 호출을 목적으로도 super가 사용될 수 있다.</p><h2 id="Object-클래스"><a href="#Object-클래스" class="headerlink" title="Object 클래스"></a>Object 클래스</h2><p>클래스를 정의할 때 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>두 클래스의 정의는 동일하다.</p><p>물론 위의 설명에도 언급했듯이 상속하는 클래스가 있는 경우에는 Object 클래스를 상속하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>그러나 이 경우에도 OtherClass 또는 OtherClass가 상속하는 클래스가 Object 클래스를 상속한다. 결국 자바의 모든 클래스는 Object 클래스를 직접 혹은 간접적으로 상속하게 되어있다. 그렇다면 자바의 모든 클래스는 Object 클래스를 상속하도록 한 이유는 무엇일까?</p><p>이는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다. 한 예로 자바의 모든 인스턴스는 다음 메소드의 인자로 전달될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> <span class="comment">// System.out.println 메소드</span></span></span><br></pre></td></tr></table></figure><p>위 메소드의 매개변수 형이 Object이다. 따라서 자바의 모든 인스턴스는 위 메소드의 인자가 될 수 있다. 그리고 위의 메소드는 인자로 전달된 인스턴스의 다음 메소드를 호출한다. 이 메소드는 Object 클래스에 정의되어 있는 메소드이므로 모든 인스턴스를 대상으로 호출이 가능하다.</p><p>이 블로그엔 포스팅하지 않았지만 글쓴이의 github 에 <a href="https://github.com/gojaebeom/java_tutorial" rel="external nofollow noopener noreferrer" target="_blank">String 클래스 예제</a>에 대해 다루었다.(목차에서 String 클래스 부분의 글들을 찾아보면 된다) </p><p>이 예제에서 클래스를 정의하면서 toString 메소드를 정의한 바 있다. 그런데 사실 이것은 Object 클래스의 toString 메소드를 오버라이딩 한 것 이다. 이와 관련해서 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//오브젝트 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">super</span>.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"My Bread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreamBread</span> <span class="keyword">extends</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bread 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"my CreamBread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridingToString</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bread b1 = <span class="keyword">new</span> Bread();</span><br><span class="line">Bread b2 = <span class="keyword">new</span> CreamBread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//b1이 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2가 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="클래스와-메소드의-final-선언"><a href="#클래스와-메소드의-final-선언" class="headerlink" title="클래스와 메소드의 final 선언"></a>클래스와 메소드의 final 선언</h2><p>클래스를 정의하는데 있어서 해당 클래스를 다른 클래스가 상속하는 것을 원치 않는다면, 다음과 같이 final 선언을 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;...&#125; <span class="comment">//MyClass 는 다른 클래스가 상속 할 수 없음</span></span><br></pre></td></tr></table></figure><p>대표적인 final 클래스로 String 클래스가 있다. 따라서 우리는 String 클래스를 상속할 수 없다. 또한 다음과 같이 메소드의 정의에 final 선언을 추가하여 해당 메소드의 오버라이딩을 허용하지 않을 수 도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>자바 5에서 ‘어노테이션(Annotations)’이라는 것이 소개되었다. 그리고 이와 관련하여 이후에 별도로 설명을 하겠다. 그러나 상속, 정확히는 메소드 오버라이딩과 관련 있는 내용이 있어 이에 대한 부분만 먼저 소개하고자 한다. 다음 예제를 보자. 이 예제는 컴파일도 되고 실행도 잘 된다. 그러나 프로그래머의 실수가 일부 포함되어 있다. 그 실수가 무엇인지찾아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideMistake</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ParentAdder adder = <span class="keyword">new</span> ChildAdder();</span><br><span class="line">System.out.println(adder.add(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 ChildAdder 는 ParentAdder를 상속한다. 그리고 ParentAdder의 add를 오버라이딩 할 의도였음을 주석을 통해 알 수 있다. 그러나 부모 메소드와 매개변수 타입과 반환형이 달랐기 때문이다. 이러한 유형의 실수는 매우 흔하다. 그럼에도 불구하고 발견이 쉽지 않기 때문에 치명적인 실수가 될 수 있다. 제일 좋은 것은 컴파일 과정에서 실수가 확인되는 것이다. 그러나 이 경우 문법적으로는 오류가 없기 때문에 컴파일도 되고 실행도 된다.</p><p>이러한 상황을 방지하기 위해서 ‘어노테이션’ 이라는 것을 사용할 수 있다. 어노테이션은 일종의 메모이다. 그것도 ‘자바 컴파일러에게 메시지를 전달하는 목적의 메모’이다. ChildAdder 클래스를 설계하는 과정에서 add 메소드가 ParentAdder의 add 메소드를 오버라이딩 할 의도였다면 다음과 같이 메모를 달아준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 어노테이션을 정의하면 컴파일러는 오버라이딩이 제대로 되었는지 확인을 하고, 프로그래머의 의도대로 오버라이딩이 되지 않았다면 컴파일 단계에서 에러를 전달해준다.</p><p>메소드를 오버라이딩 해야 한다면, 이렇듯 어노테이션을 사용하여 컴파일 과정에서 확인되지 않는 오류의 발생을 차단하는 것이 좋다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/02/java/JAVA-17.method%20overriding/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 16. 상속</title>
      <link>http://gojaebeom.github.io/2020/05/01/java/JAVA-16.%EC%83%81%EC%86%8D/</link>
      <guid>http://gojaebeom.github.io/2020/05/01/java/JAVA-16.%EC%83%81%EC%86%8D/</guid>
      <pubDate>Fri, 01 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;상속의-기본문법-이해&quot;&gt;&lt;a href=&quot;#상속의-기본문법-이해&quot; class=&quot;headerlink&quot; title=&quot;상속의 기본문법 이해&quot;&gt;&lt;/a&gt;상속의 기본문법 이해&lt;/h2&gt;&lt;p&gt;상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상속에 대한 문법적인 이해가 선행되어야 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="상속의-기본문법-이해"><a href="#상속의-기본문법-이해" class="headerlink" title="상속의 기본문법 이해"></a>상속의 기본문법 이해</h2><p>상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상속에 대한 문법적인 이해가 선행되어야 한다. <a id="more"></a></p><h2 id="상속이란"><a href="#상속이란" class="headerlink" title="상속이란?"></a>상속이란?</h2><p>상속의 이유와 목적을 물어보면 </p><ul><li>상속은 코드의 재활용를 위한 문법입니다.</li></ul><p>그러나 이는 정확한 표현은 아니다.</p><ul><li>연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다.</li></ul><p>위의 답변은 매우 모범적인 답변이다.</p><h3 id="상속의-가장-기본적인-특성"><a href="#상속의-가장-기본적인-특성" class="headerlink" title="상속의 가장 기본적인 특성"></a>상속의 가장 기본적인 특성</h3><p>상속을 단순하게 설명하면 , 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것이 상속이다. 예를 들어서 다음의 클래스가 정의되어 있다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">Animal(String name)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"이 동물의 이름은 "</span>+name+<span class="string">"입니다."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 위의 클래스를 상속하여 다음과 같이 새로운 클래스를 정의 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String cry;</span><br><span class="line"></span><br><span class="line">Cat(String name , String cry)&#123;</span><br><span class="line"><span class="keyword">super</span>(name);<span class="comment">//부모의 String타입의 매개변수를 받는 생성자 호출(super는 이후에 배우게 된다.)</span></span><br><span class="line"><span class="keyword">this</span>.cry = cry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name();<span class="comment">//Animal 클래스를 상속했기 때문에 호출 가능</span></span><br><span class="line">System.out.println(<span class="string">"울음소리는 "</span>+cry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제를 보면 새로운 super 키워드가 등장한 것을 알 수 있다. 이건 나중에 더 자세히 다루어보겠다.</p><h2 id="클래스-변수와-클래스-메소드의-상속이-가능한가"><a href="#클래스-변수와-클래스-메소드의-상속이-가능한가" class="headerlink" title="클래스 변수와 클래스 메소드의 상속이 가능한가?"></a>클래스 변수와 클래스 메소드의 상속이 가능한가?</h2><p>static 선언이 붙는 클래스 변수와 클래스 메소드도 상속의 대상에 포함이 되겠는가?</p><p>static 선언이 갖는 의미를 떠올리고 논리적으로 접근을 하면 이 질문에 스스로 답을 할 수 있다.</p><p>앞서 공부한 클래스 변수와 클래스 메소드의 특징을 정리하면 다음과 같다. </p><ul><li>인스턴스의 생성과 상관없이 접근이 가능하다.</li><li>클래스 내부와 외부에서 접근이 가능하다.</li><li>클래스 변수와 클래스 메소드가 위치한 클래스 내에서는 직접 접근이 가능하다.</li></ul><p>즉 클래스 변수와 클래스 메소드는 인스턴스에 속하지 않는, 딱 하나만 존재하는 변수와 메소드이다. <strong>따라서 상속의 대상이 아니다.</strong></p><p>그렇다면 다음 내용에 대해서는 생각을 해볼 필요가 있다. </p><ul><li>상위 클래스에 위치한 클래스 변수와 메소드에 하위 클래스에서 어떻게 접근하는가?</li></ul><p>결론을 말하자면 변수의 이름만으로 접근이 가능하다. 단 접근 수준 지시자가 접근을 허용해야 접근이 가능하다. 다음 예제를 통해 알아보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperClass sc1 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line">SuperClass sc2 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line"></span><br><span class="line">SubClass sub1 = <span class="keyword">new</span> SubClass();<span class="comment">//인스턴스 생성 과정에서 부모생성자가 호출 되므로 count 값 1 증가</span></span><br><span class="line">sub1.showCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//protected는 하위 클래스 접근을 허용</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서 변수 count의 접근 수준 지시자를 private으로 선언하면 이로 인해 컴파일 오류가 발생하는 것도 확인하기 바란다.</p><h2 id="IS-A"><a href="#IS-A" class="headerlink" title="IS - A"></a>IS - A</h2><p>두 클래스를 상속의 관계로 맺는 것이 도움이 되는 상황이 있고 도움이 되지 않는 상황이 있다. 그렇다면 언제 두 클래스를 상속의 관계로 맺어야 할까? </p><p>기본적으로 IS-A 관계라는 것이 성립해야 상속의 후보로 고려할 수 있다.</p><p>상속이 갖는 문법적 특성을 통해서 상위 클래스와 하위 클래스를 다음과 같이 이야기할 수 있다.</p><ul><li>하위 클래스는 상위 클래스의 모든 특성을 지닌다. </li><li>거기에 더하여 하위 클래스는 자신만의 추가적인 특성을 더하게 된다.</li></ul><p>이러한 상속의 특성을 현실 세계에서도 찾아볼 수 있다. 대표적인 예가 다음과 같다.</p><ul><li>모바일폰 vs 스마트폰</li></ul><p>모바일폰이 상위 클래스라면 스마트폰은 하위 클래스이다. 즉 이 둘을 객체지향의 관점에서 보면 다음과 같이 이야기할 수 있다. </p><ul><li>모바일폰을 스마트폰이 상속한다.</li></ul><p>스마트폰은 모바일폰이 갖는 특성을 모두 갖는다. 게다가 스마트폰은 앱의 설치 및 실행 등 컴퓨터의 특성을 추가적으로 갖고 있다. 따라서 클래스를 설계한다면 다음과 같은 설계가 논리적으로 타당하다.</p><ul><li>class 스마트폰 extends 모바일폰 {…}</li></ul><p>그런데 우리는 스마트폰도 모바일폰의 한 종류라 말한다. 즉 컴퓨터의 기능이 추가된 모바일폰이 스마트 폰인 것이다. 따라서 다음과 같이 이야기할 수 있다. </p><ul><li>스마트폰도 모바일폰이다.</li><li>스마트폰은 일종의 모바일폰이다.</li></ul><p>그리고 위의 문장들이 나타나는 관계를 가리켜 IS-A 관계라 하고, 이것이 상속의 관계를 맺기 위한 두 클래스의 기본 조건이 된다. 참고로 is a는 ~은 ~ 이다. 로해석 된다. 예를 들면 다음과 같다.</p><ul><li>Life is a journey - 인생은 여행이다. </li></ul><p>지금까지 설명한 내용을 정리하면 다음과 같다.</p><h3 id="IS-A-관계-총-정리"><a href="#IS-A-관계-총-정리" class="headerlink" title="IS-A 관계 총 정리"></a>IS-A 관계 총 정리</h3><ul><li>IS - A 관계는 ~은 ~이다. 로 표현되는 관계이다. </li><li>상속이 갖는 문법적 특성은 IS - A 관계의 표현에 적합하다.</li><li>따라서 상속 관계를 형성하기 위한 두 클래스는 IS -A 관계에 있어야 한다.</li></ul><h3 id="IS-A-관계-예제"><a href="#IS-A-관계-예제" class="headerlink" title="IS-A 관계 예제"></a>IS-A 관계 예제</h3><p>관련된 예제를 github에 올려두었다.</p><ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch11_%EC%83%81%EC%86%8D/IS_A_%EC%98%88%EC%A0%9C.java" rel="external nofollow noopener noreferrer" target="_blank">IS - A 예제</a></li></ul><h2 id="상위-클래스의-참조변수가-참조할-수-있는-대상의-범위"><a href="#상위-클래스의-참조변수가-참조할-수-있는-대상의-범위" class="headerlink" title="상위 클래스의 참조변수가 참조할 수 있는 대상의 범위"></a>상위 클래스의 참조변수가 참조할 수 있는 대상의 범위</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>따라서 다음과 같이 문장을 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그런데 다음과 같이 MobilePhone형 참조변수가 SmartPhone 인스턴스를 참조하게 할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>이렇듯 상위 클래스의 참조변수는 하위 클래스의 인스턴스를 참조할 수 있는데, 이 부분을 다음과 같이 이해하자.</p><ul><li>모바일폰을 상속하는 스마트폰도 일종의 모바일폰이다.<ul><li>Mobilephone을 상속하는 SmartPhone 인스턴스는 MobilePhone 인스턴스이기도 하다.</li></ul></li><li>따라서 MobilePhone형 참조변수는 SmartPhone 인스턴스를 참조할 수 있다.</li></ul><p>다음과 같이 상속 관계가 형성이 되면,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>다음 인스턴스는 Smartphone 인스턴스인 동시에 MobilePhone 인스턴스가 된다.<br><br>(이는 스마트폰을 가리키며 모바일폰이다. 라고 말할 수 있는 것과 이치가 같다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SmartPhone(<span class="string">"010-555-666"</span>,<span class="string">"Nougat"</span>);</span><br><span class="line"><span class="comment">//스마트폰 인스턴스이면서 동시에 모바일폰 인스턴스</span></span><br></pre></td></tr></table></figure><br><p>따라서 위에 말한것처럼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><p>SmartPhone 인스턴스를 참조하는 변수를 선언하는 두 가지 방법이 가능하다.</p><h3 id="지금까지-설명한-것을-예제를-통해-알아보자"><a href="#지금까지-설명한-것을-예제를-통해-알아보자" class="headerlink" title="지금까지 설명한 것을 예제를 통해 알아보자"></a><em>지금까지 설명한 것을 예제를 통해 알아보자</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Overriding_Exam01.class </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String number;<span class="comment">// 전화번호</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MobilePhone</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number  = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hi ~ from "</span> + number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//모바일폰을 상속받는 하위클래스 스마트폰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String androidVer;<span class="comment">// 안드로이드 운영체제 네임(버전)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmartPhone</span><span class="params">(String number, String ver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(number);</span><br><span class="line"><span class="keyword">this</span>.androidVer = ver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"App is running in "</span> + androidVer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SmartPhone ph1 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-111-222"</span>, <span class="string">"Andro01"</span>);</span><br><span class="line">MobilePhone ph2 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-444-333"</span>, <span class="string">"Andro02"</span>);</span><br><span class="line"></span><br><span class="line">ph1.answers();</span><br><span class="line">ph1.playApp();</span><br><span class="line"></span><br><span class="line">ph2.answers();</span><br><span class="line"><span class="comment">//ph2.playApp();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서는 다음과 같이 인스턴스를 생성하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그리고 다음과 같이 mobilePhone 클래스에 정의된 메소드를 호출하는데 이는 당연히 가능한 일이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br></pre></td></tr></table></figure><br><p>그러나 다음과 같이 SmartPhone 클래스에 정의된 메소드의 호출은 불가능하다. 참조변수 ph2가 실제 참조 하는 인스턴스가 SmartPhone 인스턴스이지만 불가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.playApp(); <span class="comment">// 스마트폰 클래스에서 정의한 메소드</span></span><br></pre></td></tr></table></figure><br><p>참조변수 ph2는 MobilePhone형 참조변수이다. 이러한 경우 ph2를 통해서 접근이 가능한 멤버는 MobilePhone 클래스에 정의되었거나 이 클래스가 상속하는 클래스의 멤버로 제한된다.(ph2가 참조하는 인스턴스가 무엇인지는 상관이 없다)</p><p>지금 설명한 이 내용이 비합리적이라고 생각할 수 있다. 참조변수의 형에 상관없이, 참조하는 인스턴스에 따라서 접근가능한 멤버가 결정되어야 한다고 생각할 수 있다. 그러나 그렇게 설계하지 않은 이유가 두 가지 있는데 그중 하나는 다음과 같다.</p><ul><li><em>실행 시간을 늦추는 결과로 이어질 수 있습니다</em></li></ul><p>자바는 메소드 호출 시 참조변수의 형을 참조 하여 그 메소드 호출이 옳은 것인지 판단한다.예를 들면 다음과 같다.(다음과 같이 컴파일러가 판단하고 컴파일을 한다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br><span class="line"><span class="comment">//ph2가 MobilePhone형이므로 MobilePhone 클래스의 메소드 answer은 호출가능하다.</span></span><br></pre></td></tr></table></figure><br><p>이러한 형태의 판단은 그 속도가 빠르다.(컴파일 단계에서 쉽게 판단 가능하다) 그러나 실제 참조하는 인스턴스를 대상으로 메소드의 호출 가능성을 판단하는 일은 간단하지 않다. 참조하는 인스턴스의 종류는 코드의 흐름에 따라 얼마든지 달라질 수 있기 때문이다.</p><p>그런데 이러한 단점도 감수할 만한 가치가 있다면 감수했을 것이다. 그러나 이어서 언급하는 두 번째 이유는 이러한 단점을 감수할 필요가 없다는 결론을 내리게 한다. </p><ul><li><em>참조변수의 타입을 기준으로 접근 가능한 멤버를 제한하는 것은 코드를 단순하게 한다.</em></li></ul><p>단점이 많은 일부 기능을 제한함으로써 단순하고 명료한 코드의 작성을 유도하는 언어가 좋은 언어이다. 그런 측면에서 참조변수의 타입을 기준으로 접근 가능한 멤버를 제한한 것은 의미가 있는 일이다.<br><br></p><h2 id="업캐스팅-Up-Casting"><a href="#업캐스팅-Up-Casting" class="headerlink" title="업캐스팅(Up Casting)"></a>업캐스팅(Up Casting)</h2><p>업캐스팅이란 서브 클래스의 객체가 수퍼 클래스 타입으로 형변환되는 것을 말한다.</p><p>다음과 같이 상속 관계를 맺은 세 클래스가 존재한다고 가정하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sweet</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">milky</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sour</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이때 StrawberryCheeseCake 인스턴스는 다음과 같이 말할 수 있다.- _StrawberryCheeseCake 인스턴스는 CheeseCake 인스턴스이면서 Cake 인스턴스 이다._<p>따라서 다음과 같이 인스턴스를 참조할 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cake cake1 = <span class="keyword">new</span> StrawberryCheeseCake();<span class="comment">//업캐스팅</span></span><br><span class="line">CheeseCake cake2 = <span class="keyword">new</span> StrawberryCheeseCake();<span class="comment">//업캐스팅</span></span><br></pre></td></tr></table></figure><br>그러나 Cake형 참조변수 cake1을 통해서 호출할 수 있는 메소드는 다음 한 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cake1.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>그리고 CheeseCake형 참조변수 cake2를 통해서 호출할 수 있는 메소드는 다음 두 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cake2.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br><span class="line">cake2.milky();</span><br><span class="line"><span class="comment">//CheeseCake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>이렇듯 참조변수가 참조하는 인스턴스의 종류에 상관없이, 참조변수의 타입에 해당하는 클래스와 그 클래스가 상속하는 상위 클래스에 정의된 메소드들만 호출이 가능하다.]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/01/java/JAVA-16.%EC%83%81%EC%86%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 15. ArrayList</title>
      <link>http://gojaebeom.github.io/2020/04/30/java/JAVA-15-AarrayList/</link>
      <guid>http://gojaebeom.github.io/2020/04/30/java/JAVA-15-AarrayList/</guid>
      <pubDate>Thu, 30 Apr 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;p&gt;ArrayList는 순차적인 여러 값들을 저장하기 위해 자바에서 기본적으로 제공하는 자료구조중 하나이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList는 순차적인 여러 값들을 저장하기 위해 자바에서 기본적으로 제공하는 자료구조중 하나이다. <a id="more"></a></p><p>이전에 배웠던 배열의 특징과 비교하자면, 배열은 ArrayList에 비해 속도는 빠르지만 선언시에 크기를 정하고 한번 정한 값을 바꿀 수 없다. 즉 할당한 크기보다 값이 적게 들어가면 그만큼 공간을 낭비하는 것이고, 할당한 크기 이상의 값을 저장할 수 없기때문에 이러한 부분도 불편한점이 아닐 수 없다. </p><p>반면 ArrayList는 속도는 배열에 비해 느리지만 값을 추가하거나 삭제함에 따라 그 크기를 유동적으로 변화시키는 장점이 있다. 이제 ArrayList를 사용하는 방법에 대하여 알아보자.</p><h2 id="ArrayList-사용법"><a href="#ArrayList-사용법" class="headerlink" title="ArrayList 사용법"></a>ArrayList 사용법</h2><h3 id="선언-방법"><a href="#선언-방법" class="headerlink" title="선언 방법"></a>선언 방법</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>기본적인 선언 방법은 위와 같다.(ArrayList는 java.util.ArrayList에 포함되어 있으므로 사용시 import 가 필요하다)</p><p>만약 VScode나 이클립스와 같은 코드 에디터를 사용하고 있다면 ArrayList에 경고줄이 떠있는 것을 볼 수 있다. ArrayList는 사용시 어떠한 데이터 타입을 넣을 것 인가 선언 시에 지정할 수 있는데, 이것은 이후에 배울 제네릭때 더 자세히 알아보자. 지금은 그냥 아래 예제와 같이 선언 한다는 것만 알아두자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;(); <span class="comment">//&lt;&gt; 사이에 사용할 유형의 타입을 적는다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ex </span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 문자열 타입만 넣을 경우</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 정수형 타입만 넣을 경우</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Subject&gt; list = <span class="keyword">new</span> ArrayList&lt;Subject&gt;(); <span class="comment">// 특정 클래스형으로 사용할 경우</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 데이터 추가</span><br><span class="line">```java</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">list.add(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><h3 id="추가한-데이터-조회"><a href="#추가한-데이터-조회" class="headerlink" title="추가한 데이터 조회"></a>추가한 데이터 조회</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">  System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-사용-예제"><a href="#ArrayList-사용-예제" class="headerlink" title="ArrayList 사용 예제"></a>ArrayList 사용 예제</h2><p>이전의 학생과 과목 클래스를 정의를 하고 학생클래스에서 과목클래스를 사용한 적이 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Subject형 참조변수</span></span><br><span class="line">    Subject eng;</span><br><span class="line">    Subject math;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> id, String name)&#123;</span><br><span class="line">        studentId = id;</span><br><span class="line">        studentName = name;</span><br><span class="line">        Subject eng = <span class="keyword">new</span> Subject();</span><br><span class="line">        Subject math = <span class="keyword">new</span> Subject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        eng.subjectId = id;</span><br><span class="line">        eng.subjectName = name;</span><br><span class="line">        eng.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMathSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        math.subjectId = id;</span><br><span class="line">        math.subjectName = name;</span><br><span class="line">        math.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>과목을 별도의 클래스로 나눈것 까지는 좋았지만 과목명을 직접 정의하여 나열하고있는 것은 좋은 코드가 아닐 것 이다. 과목 수가 많아짐에 따라 서로 중복되는 코드를 가지는 메소드들을 계속 생성해야 할 것 이다.</p><p>위와 같은 단점을 ArrayList를 사용하는 것으로 리팩토링해보자.</p><p><strong>Subject 클래스의 정의</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">//과목 이름</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> score;<span class="comment">//과목 점수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Student 클래스의 정의</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> serialNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//학생 번호</span></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//학생 이름</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Subject&gt; subjectList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.id = ++serialNum;</span><br><span class="line">subjectList = <span class="keyword">new</span> ArrayList&lt;Subject&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubject</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">subject.setName(name);</span><br><span class="line">subject.setScore(score);</span><br><span class="line">subjectList.add(subject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"학생 번호: "</span>+ id);</span><br><span class="line">System.out.println(<span class="string">"학생 이름: "</span>+ name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(subjectList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"수강중인 과목이 없습니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Subject subject : subjectList) &#123;</span><br><span class="line">total += subject.getScore();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"수강 과목 "</span>+subject.getName() + <span class="string">": "</span>+ subject.getScore());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"과목 총합점수는 "</span> + total +<span class="string">" 이고 평균은 "</span> + total/subjectList.size() + <span class="string">" 입니다."</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스의 맴버변수 <code>private ArrayList&lt;Subject&gt; subjectList;</code> 를 선언, 그리고 생성자에서 초기화 시킨다. 예제와 같이 ArrayList는 Subject 클래스를 타입으로 받고 있다. </p><p>그리고 <code>addSubject</code> 메소드가 호출될때마다 subject 객체를 새로 생성해 매개변수로 받은  과목이름과 과목점수를 저장시킨다. 이후에 subject 타입의 subjectList에 추가시킨다.</p><p><code>showStudentInfo</code> 메소드는 기본적인 학생정보를 출력하고, subjectList에 값이 저장되지 않았다면 안내 문구를 출력하고 subjectList에 값이 존재하면 출력해주는 기능을 담당한다.</p><p><strong>StudentTest 클래스에서 테스트해보기</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student studentLee = <span class="keyword">new</span> Student(<span class="string">"Lee"</span>);</span><br><span class="line">studentLee.addSubject(<span class="string">"수학"</span>, <span class="number">80</span>);</span><br><span class="line">studentLee.addSubject(<span class="string">"영어"</span>, <span class="number">70</span>);</span><br><span class="line">studentLee.showStudentInfo();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">Student studentGo = <span class="keyword">new</span> Student(<span class="string">"Go"</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"수학"</span>, <span class="number">50</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"영어"</span>, <span class="number">90</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"과학"</span>, <span class="number">90</span>);</span><br><span class="line">studentGo.showStudentInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전의 ArrayList를 사용하지 않을때와의 차이점은 addSubject라는 메소드를 사용하여 과목을 필요한만큼 정의하여 추가하고 있다는 점이다. 이전의 코드에서 수학, 영어등의 과목명을 직접 정의하여 중복되는 코드를 계속사용하는 것을 수정하여 좀더 프로그램다운 코드가 되었다.</p><p>ArrayList는 이후의 컬랙션에서 한번더 다룰 예정이다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/30/java/JAVA-15-AarrayList/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 14. 배열</title>
      <link>http://gojaebeom.github.io/2020/04/30/java/JAVA-14-%EB%B0%B0%EC%97%B4/</link>
      <guid>http://gojaebeom.github.io/2020/04/30/java/JAVA-14-%EB%B0%B0%EC%97%B4/</guid>
      <pubDate>Thu, 30 Apr 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배열이란&quot;&gt;&lt;a href=&quot;#배열이란&quot; class=&quot;headerlink&quot; title=&quot;배열이란?&quot;&gt;&lt;/a&gt;배열이란?&lt;/h2&gt;&lt;p&gt;배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란?"></a>배열이란?</h2><p>배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다. <a id="more"></a></p><h3 id="1차원-배열"><a href="#1차원-배열" class="headerlink" title="1차원 배열"></a>1차원 배열</h3><p>1차원 배열은 다음과 같이 정의할 수 있다.</p><ul><li>타입이 같은 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간</li></ul><p>그런데 자바는 배열도 인스턴스로 처리한다. 즉 자바에서는 배열도 인스턴스 이다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//길이가 5인 int형 1차원 배열의 생성문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위 문장에서 등호를 기준으로 왼편, 오른편에 위치한 것은 각각 참조변수의 선언과 배열의 생성이다. </p><p>물론 다음과 같이 참조변수의 선언과 배열 인스턴스의 생성을 구분할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ref;</span><br><span class="line">    ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//물론 int형 말고도 다양한 자료형으로 배열을 생성할 수 있다.</span></span><br><span class="line">    <span class="keyword">double</span>[] db = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>];</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//각 배열에 대한 길이 </span></span><br><span class="line">    System.out.println(db.length);</span><br><span class="line">    System.out.println(f.length);</span><br><span class="line">    System.out.println(str.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 보면 각 배열의 인스턴스 변수 length에 접근하여 배열의 길이 정보를 출력하였다. 이렇듯 인스턴스 변수에 접근이 가능하다는 것은 배열이 인스턴스임을 보인는 결과이기도 하다.</p><h2 id="배열-저장과-참조"><a href="#배열-저장과-참조" class="headerlink" title="배열 저장과 참조"></a>배열 저장과 참조</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>위 선언된 배열 arr에 첫 번째 공간에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><br><p>이렇듯 배열 요소의 위치를 지정하는 인덱스 값은 0에서부터 시작한다. 따라서 배열 arr의 두번째 , 새 번째 요소에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">//2번째</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">//3번째</span></span><br></pre></td></tr></table></figure><br><p>배열에 저장된 값을 참조하는 방법도 이와 유사하다. 다음은 배열 arr의 모든 요소에 저장된 값을 더하는 방법을 보여준다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = arr[<span class="number">0</span>] + arr[<span class="number">1</span>] + arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><br><h2 id="배열의-생성과-초기화"><a href="#배열의-생성과-초기화" class="headerlink" title="배열의 생성과 초기화"></a>배열의 생성과 초기화</h2><p>배열도 변수와 마찬가지로 생성과 동시에 초기화가 가능하다. 기본적인 배열의 생성 방식은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>이 배열을 생성과 동시에 초기화하려면 초기화할 값들을 다음과 같이 중괄호를 이용해서 나열하면 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int[] arr2 = new int[3] &#123;1, 2, 3&#125;; //컴파일 오류 발생</span></span><br></pre></td></tr></table></figure><br><p>그런데 위의 문장에서는 초기화할 값들의 수를 통해 배열의 길이 정보를 계산할 수 있으므로, 이경우 배열의 길이 정보를 생략하도록 약속하였다. 즉 위의 문장은 다음과 같이 수정해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 통해 생성되는 배열의 길이는 3이다. 그리고 위의 문장은 다음과 같이 줄여서 표현할 수 도있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><h3 id="배열의-선언-두가지-방법"><a href="#배열의-선언-두가지-방법" class="headerlink" title="배열의 선언 두가지 방법"></a>배열의 선언 두가지 방법</h3><p>다음과 같이 배열을 생성하는 문장에서도 이 둘은 동일한 의미로 사용이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ar1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//조금 더 선호하는 방법</span></span><br><span class="line"><span class="keyword">int</span> ar2[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><h3 id="배열의-참조-값과-메소드"><a href="#배열의-참조-값과-메소드" class="headerlink" title="배열의 참조 값과 메소드"></a>배열의 참조 값과 메소드</h3><p>배열도 인스턴스이므로 메소드 호출 시 참조 값의 전달이 가능하다. 예를 들어 다음과 같이 배열의 참조 값을 인자로 전달할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(sumOfAry(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//물론 아래 메소드처럼 메소드 생성시 배열의 참조변수를 매개변수로 선언해야 한다.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfAry</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>이 과정에서 배열이 새로 생성되는 것은 아니다. 그저 배열 인스턴스를 참조할 수 있는 참조 값만 인자로 전달이 되고, 이 값을 매개변수로 받을 뿐이다. 그리고 다음과 같이 배열의 참조 값을 반환하는 메소드를 정의하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] reIntArr(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line">    <span class="keyword">return</span> arr;<span class="comment">//배열의 참조값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-메서드의-매개변수"><a href="#main-메서드의-매개변수" class="headerlink" title="main 메서드의 매개변수"></a>main 메서드의 매개변수</h2><p>지금까지 배열에 대해서 알아보았다. 그렇다면 main메소드의 매개변수 선언이 무엇을 의미하는지 알 수 있을 것이다.</p><p>매개변수로 String 배열의 참조변수가 선언되었다. 따라서 다음과 같이 main 메소드를 호출해야 한다. (main 메서드를 직접 호출한다는 가정하에 작성된 코드이다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String []&#123;<span class="string">"Coffee"</span>, <span class="string">"Milk"</span>, <span class="string">"Orange"</span>&#125;;</span><br><span class="line">main(arr);</span><br></pre></td></tr></table></figure><br><p>물론 코드상에서 main메소드를 위와 같이 직접 호출하지는 않는다. 게다가 우리가 main 메소드에 전달할 String 배열을 만들지도 않는다. </p><p>그렇다면 어떻게 String 배열이 만들어지고 또 main 메소드의 인자로 전달되는 것일까?</p><p>String 배열을 구성하는 것도 main 메소드를 호출하는 것도 가상머신에 의해 이뤄지는 일이다. 다만 String 배열을 구성할 문자열은 프로그램 사용자가 전달해야 한다. </p><p>예를 들어서 Simple.class 에 위치한 main 메소드를 다음과 같이 호출한다고 가정해보자. </p><ul><li>C:\JavaStudy&gt; java Simple</li></ul><p>그러면 String 배열이 다음과 같이 구성이 되어 main 메소드에 전달이 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;&#125;;</span><br></pre></td></tr></table></figure><br><p>즉 빈 String 배열이 생성되어 main 메소드의 호출이 이뤄진다. 반면 다음과 같이 실행을 하면, </p><ul><li>C:/JavaStudy&gt; java Simple Coffee Mile Orange</li></ul><p>즉 실행 명령문에 이어서 공백을 구분 기준으로 문자열을 입력하면, 이 내용을 대상으로 String 배열이 구성되고, 이 배열의 참조 값이 전달되면서 main 메소드가 호출이 된다. 그럼 이러한 내용의 확인을 위해 다음 예제를 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">        System.out.println(args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>Coffee, Mile, Orange가 뜨는 것을 볼 수 있을 것이다.(참고로 이클립스에선 javac , java 명령어를 알아서 처리해주기때문에 cmd를 활용하여 명령어를 직접 입력해보는 것이 좋다)</p><p>이 밖에 다차원 배열등이 있지만 설명하는 것보단 직접 해보는 것이 더 효율적인 것 같다.</p><ul><li>배열 관련 예제코드<ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C01.java" rel="external nofollow noopener noreferrer" target="_blank">예제 01</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C02.java" rel="external nofollow noopener noreferrer" target="_blank">예제 02</a></li></ul></li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/30/java/JAVA-14-%EB%B0%B0%EC%97%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 13. static 응용 - Singleton</title>
      <link>http://gojaebeom.github.io/2020/04/29/java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/</link>
      <guid>http://gojaebeom.github.io/2020/04/29/java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/</guid>
      <pubDate>Wed, 29 Apr 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;싱글톤-패턴-Singleton-Pattern-이란&quot;&gt;&lt;a href=&quot;#싱글톤-패턴-Singleton-Pattern-이란&quot; class=&quot;headerlink&quot; title=&quot;싱글톤 패턴(Singleton Pattern)이란?&quot;&gt;&lt;/a&gt;싱글톤 패턴(Singleton Pattern)이란?&lt;/h2&gt;&lt;p&gt;싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="싱글톤-패턴-Singleton-Pattern-이란"><a href="#싱글톤-패턴-Singleton-Pattern-이란" class="headerlink" title="싱글톤 패턴(Singleton Pattern)이란?"></a>싱글톤 패턴(Singleton Pattern)이란?</h2><p>싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다.<a id="more"></a></p><h2 id="싱글톤이-사용되는-이유"><a href="#싱글톤이-사용되는-이유" class="headerlink" title="싱글톤이 사용되는 이유"></a>싱글톤이 사용되는 이유</h2><p>한번의 객체 생성으로 재 사용이 가능하기 때문에 메모리 낭비를 방지할 수 있다. 또한 싱글톤으로 생성된 객체는 무조건 한번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이하다.</p><h2 id="싱글톤-예제"><a href="#싱글톤-예제" class="headerlink" title="싱글톤 예제"></a>싱글톤 예제</h2><p>우리가 프로그램을 만들다보면 단 하나만 존재해야 하는 인스턴스들이 존재할 수 있다. 예를 들어 특정 학교와 학생이라는 객체를 만든다고 할 때 학생은 다수 존재하기 때문에 생성자를 계속 만들어 사용해왔다. 하지만 학생들을 대상으로 학교는 1이상 생성하는 것은 비효율적 이므로 한번만 생성할 수 있게 만들어야 한다. 그렇다면 우리는 기술적으로 어떻게 객체를 최초 한번만 생성하게 할 수 있을까?</p><p>객체를 새로 생성할 때 우리는 생성자를 호출하여 만들 수 있다. 그렇다면 생성자를 외부에서 호출하지 못하게 막는다면 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">School</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 생성자를 private로 정의하면 직접 생성자를 정의하였기 때문에 자바가상머신이 디폴트 생성자를 만들어주지도 않는다. 즉 외부에서 생성자를 호출 할 수 없게 되는 것 이다. 하지만 위와 같은 상황에선 School 의 객체를 아예 생성할 수 없기 때문에 몇가지 코드를 더 추가해 주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> School instance = <span class="keyword">new</span> School();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">School</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> School <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private 는 클래스 내부에선 접근할 수 있기 때문에 내부에서 생성자를 호출하여 새로운 객체를 만들고 <code>School타입</code>의 참조변수에 할당된 것을 볼 수 있다. 그리고 <code>getInstance</code> 메소드를 통해 참조변수(생성된 객체의 주솟값을 참조) <code>instance</code>를 반환함으로써 외부에서 이 값을 통해 <code>School 객체</code>를 사용할 수 있을 것 이다.</p><p>여기서 중요한 것은 참조변수 instance가 static 변수라는 점 인데, 만약 instance가 non-static한 변수였다면 생성자를 통해 객체가 생성될 때 존재하게 될 것이다. 하지만 static 변수는 자바가상머신이 클래스를 읽어올때 생성되는 변수이다. 그렇기때문에 생성자를 호출하지 않아도 외부에서 클래스를 통해 사용되어질 수 있는 것 이다. 물론 정보은닉적인 관점에서 instance 변수 자체는 private 키워드를 통해 외부에서 조작하지 못하게 하고 getInstance 메소드를 통해서만 사용될 수 있게 하였다.</p><p>그렇다면 자연스럽게 getInstance 메소드가 static 메소드인 이유도 알 수 있다. 일반 인스턴스 메소드 역시 객체가 생성될때 사용할 수 있다. 때문에 static 메소드로 정의 함으로써 외부에서 클래스를 통해 바로 호출이 가능하게 해야하는 것 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        School s1 = School.getInstance();</span><br><span class="line">        School s2 = School.getInstance();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SchoolTest 클래스를 테스트한 결과 School 클래스를 객체 생성없이 바로 <code>getInstance()</code> 를 호출하고 있다. <code>getInstance</code>가 반환하는 <code>참조변수 instance</code>는 클래스를 로딩하는 시점에서 객체가 생성되어 주솟값을 담고 있기때문에 참조변수의 값으로써 사용되어질 수 있다. 위의 참조변수 s1와 s2의 값을 출력해보면</p><p>test.School@79698539<br>test.School@79698539</p><p>위와 같이 같은 인스턴스를 참조하고 있는 것을 알 수 있다.</p><h2 id="싱글톤의-문제점"><a href="#싱글톤의-문제점" class="headerlink" title="싱글톤의 문제점"></a>싱글톤의 문제점</h2><p>전역성을 띄면서 다른 객체와 공통으로 사용하는 경우와 같은 몇 가지 케이스에서만 사용할 때 효율적이며 그 외에는 문제점이 생길 수 있다.<br>일단 싱글톤으로 만든 객체의 역할이 간단한 것이 아닌 역할이 복잡한 경우라면 해당 싱글톤 객체를 사용하는 다른 객체간의 결함도가 높아져서 객체 지향 설계 원칙에 어긋나게 된다. (개방-폐쇄)</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/29/java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 12. static 변수와 메소드</title>
      <link>http://gojaebeom.github.io/2020/04/29/java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/29/java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/</guid>
      <pubDate>Wed, 29 Apr 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;static-변수&quot;&gt;&lt;a href=&quot;#static-변수&quot; class=&quot;headerlink&quot; title=&quot;static 변수&quot;&gt;&lt;/a&gt;static 변수&lt;/h2&gt;&lt;p&gt;static 변수는 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="static-변수"><a href="#static-변수" class="headerlink" title="static 변수"></a>static 변수</h2><p>static 변수는 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.<a id="more"></a> 인스턴스를 생성하면, 각 인스턴스들은 서로 독립적기 때문에 서로 다른 값을 유지하게된다. 경우에 따라서는 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우가 있는데 이때 static 변수를 사용하면 된다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> studentId;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> studentId, String studentName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">        <span class="keyword">this</span>.studentName = studentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"jaebeom"</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"jongwon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전에 다루었던 학생 클래스이다. 위와 같이 학생을 식별하기위한 학생번호라는 속성을 주고 사용자가 직접 학생번호를 입력하고있다. 위와 같은 상황에 일어날 수 있는 일이 무엇이 있을까?</p><p>먼저 값을 하나하나 입력하기때문에 학생이 1000명일 경우 1부터 1000까지 직접 입력해야한다. 그리고 사용자가 직접 번호를 적다보면 잘못 입력하여 중복되는 값들이 생길 수 있다. 이것은 치명적인 문제가 될 것 이다. 이것을 개선한 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> serialNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> studentId;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String studentName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentName = studentName;</span><br><span class="line">        serialNum++;</span><br><span class="line">        studentId = serialNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"jaebeom"</span>);</span><br><span class="line">        student1.showStudentInfo();</span><br><span class="line"></span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"jongwon"</span>);</span><br><span class="line">        student2.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스의 속성으로 <code>serialNum</code> 이라는 static 변수(클래스 변수)가 추가되었다. 그리고 생성자가 호출될때마다 <code>serialNum</code>의 값을 1씩 증가시키고 <code>studentId</code>에 그 값을 할당하고있다. 위의 코드를 메모리 상태와 연관 지어보면 다음과 같이 될 것 이다.</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/static.png?raw=true" alt="이미지"></p><p>위의 두 <code>student1</code>, <code>student2</code> 참조변수는 서로 다른 인스턴트를 참조하고 있기 때문에 맴버변수 또한 서로 다른 메모리를 사용한다. 하지만 static 변수는 선언 시 메모리 영역에 따로 할당이 되기때문에 Student 클래스를 통해 생성된 모든 인스턴트들은 이 값을 모두 공유하게 되는 것이다.</p><p>결론적으로 static 변수가 모든 인스턴스에 공유되는 특징을 이용하여 사용자가 직접 학생번호를 입력하지 않고도 생성자가 호출될 때 마다 알아서 학생의 번호가 증가되게 만들었다. 이렇듯 static 변수는 객체가 공유해야하는 값을 필요로 할 때 사용할 수 있다.</p><h2 id="static-변수-접근-방법"><a href="#static-변수-접근-방법" class="headerlink" title="static 변수 접근 방법"></a>static 변수 접근 방법</h2><p>static 변수도 ‘접근 수준 지시자’ 의 규칙을 그대로 적용받기 때문에 public으로 선언되면 어디서든 접근이 가능하다. 물론 접근 방법에 있어서는 차이를 보이는데 이와 관련된 내용은 이어서 설명하겠다.</p><p>static 변수에 접근하는 방법은 접근 영역을 기준으로 다음과 같이 크게 두 가지로 나뉜다.</p><ul><li>클래스 내부 접근 : 변수의 이름을 통해 직접 접근</li><li>클래스 외부 접근 : 클래스 또는 인스턴스의 이름을 통해 접근</li></ul><p>다음예제를 보면서 static 변수의 접근 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessWay</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AccessWay()&#123;</span><br><span class="line">incrCnt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++; <span class="comment">//클래스 내부에서 이름을 통한 접근</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWayTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AccessWay way = <span class="keyword">new</span> AccessWay();</span><br><span class="line">way.num++; <span class="comment">//외부에서 인스턴스의 이름을 통한 접근</span></span><br><span class="line">AccessWay.num++; <span class="comment">//외부에서 클래스의 이름을 통한 접근</span></span><br><span class="line">System.out.println(<span class="string">"num = "</span> + AccessWay.num);<span class="comment">// 총 3이 찍힌다.</span></span><br><span class="line"></span><br><span class="line">AccessWay way2 = <span class="keyword">new</span> AccessWay();<span class="comment">//way2라는 새로운 AccessWay의 인스턴스를 생성하였다.</span></span><br><span class="line">System.out.println(way2.num);<span class="comment">//그리고 way2의 클래스변수 num을 조회 하였는데 값은 4가 찍힌다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인스턴스의 이름을 통한 접근 방법을 보면서, static 변수를 인스턴스 내부에 위치한 것으로 오해하면 안된다. 그리고 static 변수 num은 default로 선언되었다. 따라서 클래스 내부는 물론 클래스 외부이더라도 동일 패키지로 묶여 있으면 접근이 가능하다.</p><h2 id="인스턴트-변수-맴버-변수-와-static-변수-클래스-변수-의-차이"><a href="#인스턴트-변수-맴버-변수-와-static-변수-클래스-변수-의-차이" class="headerlink" title="인스턴트 변수(맴버 변수)와 static 변수(클래스 변수)의 차이"></a>인스턴트 변수(맴버 변수)와 static 변수(클래스 변수)의 차이</h2><h3 id="맴버-변수"><a href="#맴버-변수" class="headerlink" title="맴버 변수"></a>맴버 변수</h3><ul><li>공간적 특성: 인스턴트 변수는 객체마다 별도로 존재한다.<br>인스턴스 멤버 라고 부른다.</li><li>시간적 특성: 객체 생성 시에 인스턴트 변수가 생성된다.<ul><li>객체가 생길 때 인스턴트 변수도 생성된다.</li><li>객체 생성 후 인스턴트 변수 사용이 가능하다.</li><li>객체가 사라지면 인스턴트 변수도 사라진다.</li></ul></li><li>공유의 특성: 공유되지 않는다.<ul><li>인스턴트 변수는 객체 내에 각각의 공간을 유지한다.</li></ul></li></ul><h3 id="static-변수-1"><a href="#static-변수-1" class="headerlink" title="static 변수"></a>static 변수</h3><ul><li>공간적 특성: static 변수는 클래스당 하나가 생성된다.<ul><li>static 변수는 객체 내부가 아닌 별도의 공간에 생성된다.</li></ul></li><li>시간적 특성: 클래스 로딩 시에 static 변수가 생성된다.<ul><li>객체가 생기기 전에 이미 생성된다.</li><li>객체가 생기기 전에도 사용이 가능하다. (객체를 생성하지 않고도 사용할 수 있다)</li><li>객체가 사라져도 static 변수는 사라지지 않는다.</li><li>static 변수는 프로그램이 종료될 때 사라진다.</li></ul></li><li>공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유된다.</li></ul><h3 id="클래스로딩"><a href="#클래스로딩" class="headerlink" title="클래스로딩"></a>클래스로딩</h3><p>앞서 설명에서 static 변수는 클래스 로딩시 생성된다고 하였는데, 이렇듯 가상머신이 특정 클래스 정보를 읽는 행위를 가리켜 클래스 로딩 이라 한다. 그리고 특정 클래스의 인스턴스 생성을 위해서는 해당 클래스가 반드시 가상머신에 의해 로딩되어야 한다. 즉 인스턴스 생성보다 클래스 로딩이 먼저이다.</p><h2 id="static-메소드"><a href="#static-메소드" class="headerlink" title="static 메소드"></a>static 메소드</h2><p>클래스 내에 정의된 메소드에 static 선언을 하면 static 메소드(클래스 메소드)가 된다. 그리고 static 메소드는 그 성격이 static 변수와 유사하다. 접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 static 변수와 동일하다.</p><h3 id="static-메소드의-정의와-호출"><a href="#static-메소드의-정의와-호출" class="headerlink" title="static 메소드의 정의와 호출"></a>static 메소드의 정의와 호출</h3><p>static 변수의 특성 두 가지는 다음과 같다.</p><ul><li>인스턴스 생성 이전부터 접근이 가능하다.</li><li>어느 인스턴스에도 속하지 않는다.</li></ul><p>이 두 가지는 static 메소드도 동일하게 갖는 특성이다. 따라서 이 사실을 다음 예제를 통해서 확인해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> myNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//static 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDouble</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;<span class="comment">//static 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">myNum = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyNumber</span><span class="params">()</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">showInt(myNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinterTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NumberPrinter.showInt(<span class="number">50</span>);<span class="comment">// 클래스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 사실 위의 문장만 보더라도 static 메소드가 어느 인스턴스에도 속하지 않는다는 사실을 알 수 있다.</span></span><br><span class="line"><span class="comment"> * 인스턴스 생성 이전에 호출이 되었기 때문이다. </span></span><br><span class="line"><span class="comment"> * 그리고 예제의 주석에서 설명하고 있듯이 클래스의 내부와 외부에서 static 메소드를 호출하는 방법은</span></span><br><span class="line"><span class="comment"> * static 변수에 접근하는 방법과 차이가 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">NumberPrinter np = <span class="keyword">new</span> NumberPrinter();</span><br><span class="line">np.showDouble(<span class="number">3.15</span>); <span class="comment">// 인스턴스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line">np.setMyNumber(<span class="number">30</span>);</span><br><span class="line">np.showMyNumber();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 질문에 답해보자. </p><ul><li>static 메소드에서 같은 클래스에 선언된 인스턴스 변수에 접근이 가능한가?</li></ul><p>이는 다음과 같은 코드의 작성이 가능한지를 묻는 질문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">num = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 에러가 난다. 논리적으로 생각을 하면 위와 같은 문장 구성이 불가능하다는 것을 알 수 있다.</p><p>인스턴스 변수는 인스턴스에 속한다. 더불어 인스턴스가 생성이 되어야 메모리 공간에 존재하게 된다. 반면 static 메소드는 인스턴스 생성 이전부터 호출이 가능하다. 따라서 위 질문에 대해서 다음과 같이 대답할 수 있다.</p><ul><li>static 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수에 접근이 불가능하다.</li><li>같은 이유로 static 메소드는 인스턴스 메소드의 호출도 불가능하다.</li></ul><p>그러나 static 메소드 같은 클래스에 정의되어 있는 다른 static 메소드나 성격이 동일한 static 변수에는 접근이 가능하다.(당연한 얘기지만)</p><h2 id="System-out-println-그리고-main-메소드"><a href="#System-out-println-그리고-main-메소드" class="headerlink" title="System.out.println 그리고 main 메소드"></a>System.out.println 그리고 main 메소드</h2><p>지금까지 main 메소드를 정의할 때 그 앞에 static 선언을 붙여왔다. 그리고 인스턴스의 생성 없이 println 메소드를 호출해 왔다.</p><h3 id="System-out-println-에서-out과-println의-정체는"><a href="#System-out-println-에서-out과-println의-정체는" class="headerlink" title="System.out.println()에서 out과 println의 정체는?"></a>System.out.println()에서 out과 println의 정체는?</h3><p>static 선언의 의미를 알았으니 System.out.println()의 구성을 이해할 수 있다. 일단 System은 자바에서 제공하는 클래스로 java.lang 패키지에 묶여있다. 따라서 원칙적으로는 다음과 같이 호출해야 한다.</p><ul><li>java.lang.System.out.println(…);</li></ul><p>그러나 컴파일러가 다음 문장은 삽입 해주기때문에 패키지의 이름부분은 생략할 수 있다. </p><ul><li>import java.lang.*;</li></ul><p>그리고 out은 System.out으로 접근을 하니, 이는 분명 static으로 선언된 static 변수가 분명하다. 클래스의 이름을 통해 접근하니 말이다.   실제로 out은 System 클래스 내에 다음과 같이 선언된 static 변수이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out; <span class="comment">//참조변수</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 println은 PrintStream 클래스의 인스턴스 메소드이다. 따라서 다음 문장을 보면서,</p><ul><li>System.out.println(…);</li></ul><p>다음과 같이 이해 할 수 있어야 한다.</p><ul><li>System에 위치한 클래스 변수 out이 참조하는 인스턴스의 println 메소드를 호출하는 문장</li></ul><h3 id="main-메소드가-public-이고-static인-이유에-대해서-알아보자"><a href="#main-메소드가-public-이고-static인-이유에-대해서-알아보자" class="headerlink" title="main 메소드가 public 이고 static인 이유에 대해서 알아보자."></a>main 메소드가 public 이고 static인 이유에 대해서 알아보자.</h3><p>main 메소드는 반드시 다음의 모양새를 갖춰야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 main 메소드는 public 으로 그리고 static으로 선언해야 한다. 이는 일종의 약속이다. </p><p>main메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당함을 알 수 있다. 그리고 main메소드는 인스턴스가 생성되기 이전에 호출된다. 따라서 static 선언하는 것이 옳음을 알 수 있다.</p><p>다음의 예제를 보자. Car클래스와 Boat 클래스를 정의 하였다. 다음의 main 메소드가 호출이 되어 실제 실행이 되게 하려고 한다면 어떤 클래스에 두어야 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"밴츠"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBoat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보트"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 메소드는 static 메소드이기 때문에, 즉 특정 인스턴스의 맴버로 존재하는 메소드가 아니기 때문에 정답은 어디든 상관은 없다. (물론 실행방식에선 차이가 발생한다. Car클래스에 두었으면 java Car 를 호출, Boat면 java Boat 호출)</p><p>그렇다면 Car클래스에 두었다고 가정해보자. main 메소드를 Car 클래스 내에 위치시켰는데 그 안에서 Car 인스턴스를 생성하고 있다. 혹시 이부분이 조금 난해하게 느껴지는가? 그렇다면 다음과 같이 생각하자.</p><ul><li>Car클래스와 static으로 선언된 main메소드는 사실상 별개다.</li><li>다만 Car 클래스가 main 메소드에게 공간을 제공했을 뿐이다. </li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/29/java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 11. this 키워드</title>
      <link>http://gojaebeom.github.io/2020/04/28/java/JAVA-11-this/</link>
      <guid>http://gojaebeom.github.io/2020/04/28/java/JAVA-11-this/</guid>
      <pubDate>Tue, 28 Apr 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;this의-의미&quot;&gt;&lt;a href=&quot;#this의-의미&quot; class=&quot;headerlink&quot; title=&quot;this의 의미&quot;&gt;&lt;/a&gt;this의 의미&lt;/h2&gt;&lt;p&gt;자바에서 제공하는 this 키워드는 인스턴스 자기 자신를 가리키는 키워드이다. 이 this 키워드를 통해 클래스 메서드 및 생성자에서 자기 자신의 데이터를 업데이트하거나 조작할 수 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="this의-의미"><a href="#this의-의미" class="headerlink" title="this의 의미"></a>this의 의미</h2><p>자바에서 제공하는 this 키워드는 인스턴스 자기 자신를 가리키는 키워드이다. 이 this 키워드를 통해 클래스 메서드 및 생성자에서 자기 자신의 데이터를 업데이트하거나 조작할 수 있다.<a id="more"></a></p><h2 id="this의-사용-예제"><a href="#this의-사용-예제" class="headerlink" title="this의 사용 예제"></a>this의 사용 예제</h2><h3 id="this를-이용한-생성자-호출"><a href="#this를-이용한-생성자-호출" class="headerlink" title="this를 이용한 생성자 호출"></a>this를 이용한 생성자 호출</h3><p>this를 이용하여 생성자를 호출하는 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">Example()&#123;</span><br><span class="line">System.out.println(<span class="string">"생성자 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Example(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)&#123;</span><br><span class="line">System.out.println(<span class="string">"생성자 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Example(<span class="keyword">int</span> num)&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"생성자 3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제를 보면 this 키워드를 이용하여 다른 생성자를 호출하고있다. 정수를 하나 받는 인스턴트를 새로 호출하자, 생성자2, 생성자3 이 콘솔에 출력된다. </p><p>생성자 3이 사용이 되었는데 생성자 3에서는 this(3, 4) 라는 키워드가 먼저 작성되어있다.<br>여기서 this는 오버로딩된 다른 생성자를 의미한다. 거기에 정수를 두개 받는 생성자를 찾기때문에 생성자 2가 먼저 호출이 되고 그다음 출력문을 만나 생성자 3이 콘솔에 찍히게 된다.</p><h3 id="this-인스턴수-변수-접근"><a href="#this-인스턴수-변수-접근" class="headerlink" title="this - 인스턴수 변수 접근"></a>this - 인스턴수 변수 접근</h3><p>앞서 키워드 this를 이용한 생성자의 호출에 대해 설명했는데, this는 다른 의미로도 사용이 된다. 이와 관련하여 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 매개변수의 이름이 인스턴스 변수의 이름과 동일하게 선언된 경우, 선언된 지역 내에서의 해당 이름은 매개변수를 의미하게 된다.<br>하지만 키워드 this를 이용하면 이 영역 안에서도 인스턴스 변수에 접근할 수 있다. </p><p>즉 this.name에서 this가 의미하는 것은 ‘이 문장이 속한 인스턴스’ 이다. 따라서 this.name은 인스턴스 변수 name을 의미하는 것이 된다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/28/java/JAVA-11-this/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 10. 정보 은닉</title>
      <link>http://gojaebeom.github.io/2020/04/28/java/JAVA-10-%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/</link>
      <guid>http://gojaebeom.github.io/2020/04/28/java/JAVA-10-%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/</guid>
      <pubDate>Tue, 28 Apr 2020 10:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;정보-은닉&quot;&gt;&lt;a href=&quot;#정보-은닉&quot; class=&quot;headerlink&quot; title=&quot;정보 은닉&quot;&gt;&lt;/a&gt;정보 은닉&lt;/h2&gt;&lt;p&gt;자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 자바에서는 ‘접근 제어자’(접근 제한자, 접근 제어 지시자 등 다양하게 불린다)를 통해  접근의 허용 수준을 결정할 때 선언하는 키워드를 제공한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="정보-은닉"><a href="#정보-은닉" class="headerlink" title="정보 은닉"></a>정보 은닉</h2><p>자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 자바에서는 ‘접근 제어자’(접근 제한자, 접근 제어 지시자 등 다양하게 불린다)를 통해  접근의 허용 수준을 결정할 때 선언하는 키워드를 제공한다.<a id="more"></a></p><h2 id="접근-제어자"><a href="#접근-제어자" class="headerlink" title="접근 제어자"></a>접근 제어자</h2><p>접근 제어자의 종류는 다음과 같이 4가지 이다.</p><ul><li>public, protected, private, default</li></ul><p>이중에서 default는 키워드가 아닌, 아무런 선언도 하지 않은 상황을 의미한다. 비록 이는 키워드가 아닌 일종의 상황이지만 이 역시 접근 제한자의 한 종류로 구분을 한다. </p><p>그리고 이러한 선언을 할 수 있는 대상은 다음 두 가지이다.</p><ul><li>클래스의 정의</li><li>클래스의 맴버 변수와 메소드</li></ul><p>클래스의 정의를 대상으로는 다음 두 가지 선언이 가능하다.</p><ul><li>클래스 정의대상 : public ,default</li></ul><p>그리고 맴버 변수와 메소드를 대상으로는 다음 네 가지 선언이 모두 가능하다.</p><ul><li>public, protected, private, default</li></ul><p>그럼 이제 각각의 기능을 알아보자. </p><h3 id="클래스-정의-대상의-public-과-default-선언이-갖는-의미"><a href="#클래스-정의-대상의-public-과-default-선언이-갖는-의미" class="headerlink" title="클래스 정의 대상의 public 과 default 선언이 갖는 의미"></a>클래스 정의 대상의 public 과 default 선언이 갖는 의미</h3><ul><li>public : 어디서든 객체(인스턴스) 생성이 가능하다. </li><li>default : 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용한다.</li></ul><h3 id="인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미"><a href="#인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미" class="headerlink" title="인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미"></a>인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미</h3><table><thead><tr><th>접근제한자</th><th>클래스 내부</th><th align="right">동일 패키지</th><th align="center">상속 받은 클래스</th><th align="right">이외의 영역</th></tr></thead><tbody><tr><td>private</td><td>o</td><td align="right">x</td><td align="center">x</td><td align="right">x</td></tr><tr><td>default</td><td>o</td><td align="right">o</td><td align="center">x</td><td align="right">x</td></tr><tr><td>protected</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">x</td></tr><tr><td>public</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">o</td></tr></tbody></table><p>위의 표에서 말하는 이외의 영역은 다른 패키지에 속한 클래스를 뜻한다. 즉 서로 다른 패키지에 속한 두 클래스 사이의 접근을 의미한다. 그리고 위 표의 내용을 기준으로 접근 허용 범위에 대하여 다음과 같이 이해하고 있는 것도 도움이 된다. </p><ul><li>public &gt;  protected &gt; default &gt; private</li></ul><h2 id="정보-은닉이-필요한-이유"><a href="#정보-은닉이-필요한-이유" class="headerlink" title="정보 은닉이 필요한 이유"></a>정보 은닉이 필요한 이유</h2><p>우리가 어떠한 클래스를 정의한다고 생각해보자. 만약 사용자 입장에서 잘못된 조작을 할 수 있는 예외상황으로 인해 우리가만든 프로그램이 잘못사용될 경우 그 프로그램은 잘 짜여진 프로그램이 아닐 것 이다.</p><p>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println( year + <span class="string">"년"</span> + month + <span class="string">"월 "</span> + day + <span class="string">"일."</span>  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyDate date = <span class="keyword">new</span> MyDate();</span><br><span class="line">date.day = <span class="number">100</span>;</span><br><span class="line">date.month = <span class="number">100</span>;</span><br><span class="line">date.year = <span class="number">2019</span>;</span><br><span class="line">date.showDate(); <span class="comment">//2019년 100월 100일. 출력</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 날짜값을 받아서 날짜를 출력하는 프로그램이다. 사용자가 맴버변수에 바로 접근하여 값을 할당하고, 그에 맞는 값이 출력되는 것을 볼 수 있다. 여기서 문제는 <code>2019년 100월 100일</code> 과 같은 날짜가 출력되는것이 정상인가? 존재하지 않는 날짜가 출력되기때문에 이는 잘못된 프로그램이라고 할 수 있다.</p><p>이와같이 사용자가 직접 값을 조작하면 예외 상황이 일어날 수 있는 코드들은 외부에서 접근하지 못하게 막아놓고 메소드를 통해 값을 받아 잘못된 값이 들어오면 조취를 취할 수 있게 하는 것이 정보은닉의 대표적인 예 이다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//조건이 유효한지 체크하는 변수</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isValid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(day &lt; <span class="number">1</span> || day &gt; <span class="number">31</span>)</span><br><span class="line">            isValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.day = day; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> month)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( month &lt; <span class="number">1</span> || month &gt; <span class="number">12</span>) </span><br><span class="line">            isValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">this</span>.month = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(year &lt; <span class="number">1900</span> || year &gt; <span class="number">2020</span>)</span><br><span class="line">            isValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid) </span><br><span class="line">            System.out.println( year + <span class="string">"년"</span> + month + <span class="string">"월 "</span> + day + <span class="string">"일."</span>  );</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            System.out.println(<span class="string">"정상적인 값이 아닙니다."</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맴버변수에 <code>isValid</code> 라는 변수를 <code>true</code>로 선언과 동시에 초기화 하였다. 유효성 검사를 하기위한 변수이다. 그리고 모든 맴버변수들을 private로 외부로부터 숨기고 각 변수들에게 값을 담을 수 있는 public 메소드들을 정의하였다. 그리고 이 메소드는 내부적으로 잘못된 값이 들어오면 <code>isValid</code>의 값을 <code>false</code>로 바꾼다. 이후에 날짜를 출력하는 <code>showDate</code> 메소드는 <code>isValid</code>의 값이 참일때 시간을 보여주고 거짓이면 실패 문구를 출력한다. 결과적으로 값이 하나라도 잘못 입력되면 날짜를 띄울 수 없게 만든 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate date = <span class="keyword">new</span> MyDate();</span><br><span class="line">    date.setDay(<span class="number">0</span>);</span><br><span class="line">    date.setMonth(<span class="number">5</span>);</span><br><span class="line">    date.setYear(<span class="number">2020</span>);</span><br><span class="line">    date.showDate();<span class="comment">//정상적인 값이 아닙니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스를 <code>MyDateTest</code> 클래스에서 테스트해보면 잘못된 값이 하나라도 존재하면 ‘정상적인 값이 아닙니다.’(살짝 불친절한..) 문구가 나오는 것을 알 수 있다. 물론 값이 제대로 입력되면 정상적으로 날짜를 출력한다. </p><p>이와 같이 프로그램을 만들다보면 외부로부터의 접근을 숨겨야하는 정보들이 있다. 그러한 정보들은 외부로부터의 접근을 막고 만든이가 의도하는대로 사용자가 프로그램을 다루게 하는것이 정보 은닉이 필요한 이유라 생각한다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/28/java/JAVA-10-%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 09. 참조 자료형</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/JAVA-09-%EC%B0%B8%EC%A1%B0%20%EC%9E%90%EB%A3%8C%ED%98%95/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/JAVA-09-%EC%B0%B8%EC%A1%B0%20%EC%9E%90%EB%A3%8C%ED%98%95/</guid>
      <pubDate>Mon, 27 Apr 2020 10:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;참조-자료형-Reference-Data-Type&quot;&gt;&lt;a href=&quot;#참조-자료형-Reference-Data-Type&quot; class=&quot;headerlink&quot; title=&quot;참조 자료형(Reference Data Type)&quot;&gt;&lt;/a&gt;참조 자료형(Reference Data Type)&lt;/h2&gt;&lt;p&gt;처음 자바에 대한 글을 작성할때 변수와 자료형에 대해 알아보았다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="참조-자료형-Reference-Data-Type"><a href="#참조-자료형-Reference-Data-Type" class="headerlink" title="참조 자료형(Reference Data Type)"></a>참조 자료형(Reference Data Type)</h2><p>처음 자바에 대한 글을 작성할때 변수와 자료형에 대해 알아보았다.<a id="more"></a> 그리고 자료형에는 기본 자료형과 참조 자료형이 있다고 하였다. 참조형에 대해선 그 당시에 다루지 않았는데, 참조 자료형은 클래스에 대한 기본적인 지식을 가지고 있어야 이해하기 편하다고 생각하였다. </p><p>참조 자료형은 자료형이 클래스이다. 우리가 자주 사용하는 String, 그리고 우리가 직접 정의한 Student 클래스도 참조 자료형이 될 수 있다. 기본 자료형은 int, char, double, boolean 과 같이 그 크기가 이미 정해져 있지만, 참조자료형은 참조하는 클래스에 따라 그 크기가 다르다. </p><h2 id="참조-자료형-사용-예제"><a href="#참조-자료형-사용-예제" class="headerlink" title="참조 자료형 사용 예제"></a>참조 자료형 사용 예제</h2><p>이전에 학생 클래스를 만들어 학생의 고유번호와 이름을 받아 학생의 정보를 보여주는 일을 하는 클래스를 정의하였다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student studentGo = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 만든 학생 클래스를 객체로 생성하여 위와 같이 참조변수에 할당하였다. 이렇듯 참조변수를 main 메소드 안에서만 정의 하였는데, 참조변수는 클래스의 내부에 맴버변수로써도 사용할 수 있다. </p><p>학생 클래스를 만들었으니 학생마다 수강하는 과목을 만들고 싶다. 그리고 그 과목에 대한 점수도 받고싶다. 그렇다면 다음과 같이 작성하면 될까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    String subjectEng;<span class="comment">//영어</span></span><br><span class="line">    <span class="keyword">int</span> subjectEngScore;<span class="comment">//영어점수</span></span><br><span class="line">    String subjectMath;<span class="comment">//수학</span></span><br><span class="line">    <span class="keyword">int</span> subjeectMathScore;<span class="comment">//수학점수</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 과목을 하나하나 적는 것은 비효율 적일 것 같다. 게다가 과목이 갖는 점수 역시 따로 명시해주어야 한다. 우리는 위의 클래스를 Student 라 정의 하였다. 여기서 알 수 있는 것은 학생에 관련된 클래스라는 것 이다. 그렇다면 과목에 관련된 클래스 역시 따로 정의 할 수 있지 않을까? 한번 과목 클래스를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subjectId;<span class="comment">//과목 번호</span></span><br><span class="line">    String sbujectName;<span class="comment">//과목 이름</span></span><br><span class="line">    <span class="keyword">int</span> subjectScore;<span class="comment">//과목 점수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 따로 과목에 대한 클래스를 정의할 수 있다. 그렇다면 학생 클래스에서 이 과목 클래스를 가져와 사용하는 예를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Subject형 참조변수</span></span><br><span class="line">    Subject eng;</span><br><span class="line">    Subject math;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> id, String name)&#123;</span><br><span class="line">        studentId = id;</span><br><span class="line">        studentName = name;</span><br><span class="line">        Subject eng = <span class="keyword">new</span> Subject();</span><br><span class="line">        Subject math = <span class="keyword">new</span> Subject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subject 타입의 참조변수 eng와 math를 맴버변수로 선언한 뒤, 학생 객체의 생성자가 호출될때 동시에 Subject 객체가 생성되고 참조값을 참조하게 된다. 이로써 Student 객체가 생성이 되면 Subject 객체도 같이 생성되는것을 알 수 있다. (사실 위의 Subject를 통해 과목을 직접 나누는 것도 좋은 예는 아니지만 우리는 아직 배열과 리스트를 배우지 않았기 때문에 일단은 위와 같이 작성하자) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        eng.subjectId = id;</span><br><span class="line">        eng.subjectName = name;</span><br><span class="line">        eng.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMathSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        math.subjectId = id;</span><br><span class="line">        math.subjectName = name;</span><br><span class="line">        math.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showStudentScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"학생번호:"</span>+studentId);</span><br><span class="line">        System.out.println(<span class="string">"학생이름:"</span>+studentName);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"과목1:"</span>+eng.subjectName);</span><br><span class="line">        System.out.println(<span class="string">"점수:"</span>+eng.subjectScore);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"과목2:"</span>+math.subjectName);</span><br><span class="line">        System.out.println(<span class="string">"점수:"</span>+math.subjectScore);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"총 점수"</span>+(eng.subjectScore + math.subjectScore));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 Subject를 참조하긴 했지만, 과목번호와 , 과목이름, 과목점수등을 설정하지 않았기때문에 과목의 정보를 입력할 수 있는 메소드와, 학생정보 그리고 수강과목점수등을 보여주는 메소드를 만들었다. 이제 StudentTest에서 Student 객체를 생성하여 사용해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Student sJaebeom = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"재범"</span>);</span><br><span class="line">        sJaebeom.setEngSubject(<span class="number">1</span>, <span class="string">"영어"</span>, <span class="number">50</span>);</span><br><span class="line">        sJaebeom.setMathSubject(<span class="number">2</span>, <span class="string">"수학"</span>, <span class="number">30</span>);</span><br><span class="line">        sJaebeom.showStudentScore();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Student sJongwon = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"종원"</span>);</span><br><span class="line">        sJongwon.setEngSubject(<span class="number">1</span>, <span class="string">"영어"</span>, <span class="number">40</span>);</span><br><span class="line">        sJongwon.setMathSubject(<span class="number">2</span>, <span class="string">"수학"</span>, <span class="number">70</span>);</span><br><span class="line">        sJongwon.showStudentScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentTest 클래스에서 테스트해보면 위와 같이 작성할 수 있다. 이번 글의 주제는 참조변수이지만, 참조변수를 다른 클래스에서 사용하여 객체끼리 상호작용을 하는 예제를 살짝 다루었다. 객체지향적인 프로그래밍은 이와 같이 서로 다른 객체가 맞물려서 작동하는 프로그램을 나타낸다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/JAVA-09-%EC%B0%B8%EC%A1%B0%20%EC%9E%90%EB%A3%8C%ED%98%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 08. 생성자</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/JAVA-08-%EC%83%9D%EC%84%B1%EC%9E%90/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/JAVA-08-%EC%83%9D%EC%84%B1%EC%9E%90/</guid>
      <pubDate>Mon, 27 Apr 2020 10:15:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;생성자-Constructor-란-무엇인가&quot;&gt;&lt;a href=&quot;#생성자-Constructor-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;생성자(Constructor)란 무엇인가?&quot;&gt;&lt;/a&gt;생성자(Constructor)란 무엇인가?&lt;/h2&gt;&lt;p&gt;우리는 이미 생성자를 한번 사용한 적이 있다. 객체를 생성할 때 &lt;code&gt;new&lt;/code&gt; 키워드 다음에 선언한 &lt;code&gt;클래스명()&lt;/code&gt; 이 생성자 이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="생성자-Constructor-란-무엇인가"><a href="#생성자-Constructor-란-무엇인가" class="headerlink" title="생성자(Constructor)란 무엇인가?"></a>생성자(Constructor)란 무엇인가?</h2><p>우리는 이미 생성자를 한번 사용한 적이 있다. 객체를 생성할 때 <code>new</code> 키워드 다음에 선언한 <code>클래스명()</code> 이 생성자 이다. <a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Example();</span><br></pre></td></tr></table></figure><h3 id="생성자-만들기"><a href="#생성자-만들기" class="headerlink" title="생성자 만들기"></a>생성자 만들기</h3><p>생성자는 클래스명과 동일해야한다. 그리고 반환형도 없고 (이후에 배울)상속되지도 않는다. 생성자는 다음과 같이 선언할 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="comment">//생성자</span></span><br><span class="line">    Example()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바에서 클래스를 만들때 내부적으로 반드시 하나 이상의 생성자를 만들어야 하는 규칙이있다. 그런데 우리는 위와같이 생성자를 구현한 적이 없다. 그렇다면 지금까지 만든 클래스는 생성자가 없었는데 규칙을 어겼던 것일까?</p><p>자바는 컴파일을 할때 class에 생성자가 정의되어 있지않으면 디폴트 생성자(Default Constructor)라는 것을 만들어준다. 위와 같이 내용이 비어있는 빈껍대기인 생성자이다. 내부적으로 구현된 코드는 없지만 이로써 생성자를 하나 이상 만들어야 하는 규칙은 지켜지는 것 이다.</p><h2 id="생성자의-사용"><a href="#생성자의-사용" class="headerlink" title="생성자의 사용"></a>생성자의 사용</h2><p>생성자는 메소드와 같이 필요할 때 바로바로 호출하여 사용할 수 있는 것은 아니다. 생성자는 객체를 생성할때에만 호출이되며, 주로 맴버변수의 값을 초기와하는 역할을 한다. 다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"학생번호:"</span>+studentId);</span><br><span class="line">        System.out.println(<span class="string">"학생이름:"</span>+studentName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.studentId = <span class="number">1</span>;</span><br><span class="line">        student.studentName = <span class="string">"jaebeom"</span>;</span><br><span class="line"></span><br><span class="line">        student.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에선 Student 객체를 생성한 이후 맴버변수에 접근하여 값을 넣고 학생정보를 보이고 있다. 하지만 생성이후 저렇게 정보를 보이기 위해 변수에 하나하나 값을 넣는 것은 비효율적으로 보인다. 그리고 이후에 나오는 ‘정보은닉’관점에서도 저 방법은 좋은 예제는 아니다. 이제 다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> id, String name)&#123;</span><br><span class="line">        studentId = id;</span><br><span class="line">        studentName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"학생번호:"</span>+studentId);</span><br><span class="line">        System.out.println(<span class="string">"학생이름:"</span>+studentName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"jaebeom"</span>);</span><br><span class="line">        student.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 생성자를 직접 정의하여 객체 생성 당시에 학생번호와 학생이름을 매개변수로 받아 맴버변수들을 초기화하는 예제이다. 불필요하게 맴버변수들을 불러와 값을 할당할 필요가 없어진 것 이다. </p><p>여기서 한가지 궁금한 적이 있다. 우리가 생성자를 직접 정의하였는데, 그렇다면 아무런 매개변수를 받지 않는 디폴트 생성자는 그대로 존재하는가? 결론은 ‘존재하지 않는다’ 이다. 우리가 직접 생성자를 정의하게되면 디폴트 생성자는 생성되지 않는다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"jaebeom"</span>); </span><br><span class="line">        <span class="keyword">new</span> Student();<span class="comment">//에러</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전의 Student 클래스의 생성자를 정의했다고 가정하고 위와 같이 작성해보면, 매개변수를 받지 않는 생성자가 호출될 때 에러가 나는 것을 알 수 있다. 우리가 매개변수를 받지 않는 생성자를 정의하지 않았기 때문이다.</p><h2 id="생성자-오버로딩-Overloading"><a href="#생성자-오버로딩-Overloading" class="headerlink" title="생성자 오버로딩(Overloading)"></a>생성자 오버로딩(Overloading)</h2><p>생성자 오버로딩은 생성자의 이름을 같게 하고 매개변수의 수, 그리고 타입에 따라 여러개의 생성자를 만들어 내는 것을 말한다. (오버로딩은 이후의 메소드 오버로딩때 자세히 다루도록 한다)</p><p>예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    Student()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    Student(String name, <span class="keyword">int</span> id)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 똑같은 이름인 생성자들이 매개변수의 수, 그리고 타입에 따라 여러개를 정의하게 가능한 것을 알 수 있다. 즉 이전 예제인 Student 객체의 생성자 호출 문제는 다음과 같이 해결할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> id, String name)&#123;</span><br><span class="line">        studentId = id;</span><br><span class="line">        studentName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"학생번호:"</span>+studentId);</span><br><span class="line">        System.out.println(<span class="string">"학생이름:"</span>+studentName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"jaebeom"</span>);</span><br><span class="line">        student.showStudentInfo();</span><br><span class="line"></span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아무런 매개변수를 받지 않는 생성자도 따로 정의하여 문제없이 호출하는 것을 알 수 있다. 이것이 생성자 오버로딩이 필요한 이유이다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/JAVA-08-%EC%83%9D%EC%84%B1%EC%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 07. 함수와 메소드</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/JAVA-07-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/JAVA-07-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/</guid>
      <pubDate>Mon, 27 Apr 2020 10:10:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;함수-Function-란&quot;&gt;&lt;a href=&quot;#함수-Function-란&quot; class=&quot;headerlink&quot; title=&quot;함수(Function)란?&quot;&gt;&lt;/a&gt;함수(Function)란?&lt;/h2&gt;&lt;p&gt;프로그래밍에서 함수는 하나의 기능을 수행하는 코드의 단위이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="함수-Function-란"><a href="#함수-Function-란" class="headerlink" title="함수(Function)란?"></a>함수(Function)란?</h2><p>프로그래밍에서 함수는 하나의 기능을 수행하는 코드의 단위이다.</p><a id="more"></a><p>이전의 객체지향 프로그래밍이 무엇인가 다루었을 때 객체의 속성은 변수, 기능은 메소드라고 하였다. 메소드와 함수는 무슨 차이일까? </p><h2 id="메소드-Method-란"><a href="#메소드-Method-란" class="headerlink" title="메소드(Method)란?"></a>메소드(Method)란?</h2><p>클래스 내부에서 클래스의 기능을 갖는 함수를 <code>메소드</code> 라 한다. 즉 함수가 좀더 포괄적인 개념이다. 하지만 서로 기능적인 차이는 거의 없다. 단지 자바 프로그래밍을 할 때 우리는 function 보다 method라는 단어를 더 많이 접하게 될 것이다.</p><h3 id="메소드-정의하기"><a href="#메소드-정의하기" class="headerlink" title="메소드 정의하기"></a>메소드 정의하기</h3><p>클래스를 정의할 때는 앞의 문자를 대문자로 하는 것이 일반적인 관례였다. 반대로 변수와 메소드명을 정의할 때는 소문자로 시작하고, 두 단어 이상이 사용되면 카멜케이스를 사용하는 것이 일반적인 관례이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//메소드 정의하기</span></span><br><span class="line">반환형 메소드명 (매개변수)&#123;몸통&#125;</span><br><span class="line">        ˇˇˇ</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>메소드는 위와 같이 반환형, 메소드명, 매개변수, 그리고 구현부로 이루어져있다. void는 반환값이 없을때 사용하는 키워드이다. 그리고 매개변수는 사용함에 따라 선언 유무는 상관이 없고, 다수의 변수를 선언해도 상관 없다. </p><p>다음 예제를 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//반환값이 없고 매개변수가 없는 메소드 정의</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//반환값이 없고 매개변수가 하나 있는 메소드 정의</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//반환값이 없고 매개변수가 두개 있는 메소드의 정의</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//물론 매개변수는 두개이상도 가능하다.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//매개변수의 타입은 필요에 따라 원하는 타입으로 선언할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(<span class="keyword">int</span> a, String str, <span class="keyword">double</span> d)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>그리고 메소드의 기능을 실행한뒤에 결과 값을 다른곳으로 반환하고 싶다면 아래와 같이 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반환형에 int를 명시해줬기 때문에 return되는 값은 int형이여야 한다. 물론 다른형으로도 명시가 가능하다.</p><h3 id="메소드의-return"><a href="#메소드의-return" class="headerlink" title="메소드의 return"></a>메소드의 return</h3><p>메소드의 return은 값을 반환함과 동시에 메소드를 종료시킴을 의미한다.</p><p>다음으로 매개변수를 받아 가공하여 반환 하는 메소드의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 메소드는 매개변수로 두 정수 값을 받아 더해서 반환하는 함수이다. 그리고 위 예제들의 모든 함수들은 정의만 하였고 사용되지 않았다.</p><h3 id="메소드-사용하기"><a href="#메소드-사용하기" class="headerlink" title="메소드 사용하기"></a>메소드 사용하기</h3><p>메소드는 메소드의 이름으로 호출 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello~ world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    helloWorld();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = addNum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메소드의 반환형 앞에 붙은 public과 static은 신경쓰지말자. 이것은 이후에 배울 접근 제어자와, static을 통해 알 수 있다. </p><p>이전에 클래스를 사용할 때도 main 메소드 내부에서 실행한 것을 알 수 있다. 이는 자바 프로그램이 main 이라는 이름의 메소드에서부터 시작하는것을 약속으로 한다.</p><p>위의 <code>addNum</code> 그리고 <code>helloworld</code> 메소드는 메인 메소드에서 호출하였다.</p><p>helloworld 메소드의 경우 내부적으로 println를 통해 문자열을 출력하는 일을 한다. </p><p>addNum의 경우 int형 인자값을 두개 받기로 약속하였기 때문에 정수값 두개를 넘겨주고 내부에서 사칙연산을 수행 이후 값을 반환하고 있다. 그리고 반환값이 int형이기 때문에 int 타입의 변수에 값으로 할당할 수 있게 된다. 이후 그 값을 잘 출력하는 것을 볼 수 있다.</p><h2 id="메소드와-메모리-스택-Stack"><a href="#메소드와-메모리-스택-Stack" class="headerlink" title="메소드와 메모리 스택(Stack)"></a>메소드와 메모리 스택(Stack)</h2><p>이전 클래스의 인스턴트 부분에서 메모리 구조에 대해 간략하게 소개한 적이 있다. 인스턴스는 메모리의 힙이라는 곳에 생성된다고 하였다. 반대로 메소드나, 메소드 내부에서 사용되는 변수(지역변수)들은 스택이라는 곳에 저장된다.</p><h3 id="Last-In-First-Out-LIFO"><a href="#Last-In-First-Out-LIFO" class="headerlink" title="Last In First Out (LIFO)"></a>Last In First Out (LIFO)</h3><p><em>스택은 후입선출의 방법으로 메모리를 관리한다. 즉 나중에 들어온 값이 가장 먼저 나가게 되는 것 이다.</em></p><p>예를 들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">func1();</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 메인함수가 먼저 실행이되고 메인 함수에서 <code>func1</code> 과 <code>func2</code>함수를 차례대로 호출하고 있다. </p><p>먼저 메인 메소드가 실행이 되면 다음과 같이 스택에 메인함수가 생성이 된다.<br><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%8A%A4%ED%83%9D3.png?raw=true" alt="스택 1"></p><p>그리고 메인메서드가 func1 메소드를 호출한다.</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%8A%A4%ED%83%9D1.png?raw=true" alt="스택 2"></p><p>위의 메소드는 내부적으로 기능을 완료하고 종료한다.<br><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%8A%A4%ED%83%9D3.png?raw=true" alt="스택 1"><br>그 이후 func2 메소드를 호출한다.<br><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%8A%A4%ED%83%9D2.png?raw=true" alt="스택 2"> </p><p>메소드는 이와같이 후입선출의 개념으로 스택영역에 저장되고, 소멸하게 된다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/JAVA-07-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 06. 객체지향 프로그래밍과 클래스</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/JAVA-06-%ED%81%B4%EB%9E%98%EC%8A%A4/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/JAVA-06-%ED%81%B4%EB%9E%98%EC%8A%A4/</guid>
      <pubDate>Mon, 27 Apr 2020 10:08:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체지향-프로그래밍-Object-Oriented-Programming-이란&quot;&gt;&lt;a href=&quot;#객체지향-프로그래밍-Object-Oriented-Programming-이란&quot; class=&quot;headerlink&quot; title=&quot;객체지향 프로그래밍(Object Oriented Programming )이란?&quot;&gt;&lt;/a&gt;객체지향 프로그래밍(Object Oriented Programming )이란?&lt;/h2&gt;&lt;p&gt;객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="객체지향-프로그래밍-Object-Oriented-Programming-이란"><a href="#객체지향-프로그래밍-Object-Oriented-Programming-이란" class="headerlink" title="객체지향 프로그래밍(Object Oriented Programming )이란?"></a>객체지향 프로그래밍(Object Oriented Programming )이란?</h2><p>객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. </p><a id="more"></a><h2 id="객체-Object-란"><a href="#객체-Object-란" class="headerlink" title="객체(Object) 란?"></a>객체(Object) 란?</h2><p>객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것을 의미한다.</p><h2 id="클래스-Class-란"><a href="#클래스-Class-란" class="headerlink" title="클래스(Class) 란?"></a>클래스(Class) 란?</h2><p>클래스는 객체지향 프로그래밍의 가장 기본적인 요소이며, ‘속성(변수)과 기능(메소드)’의 묶음으로 나뉜다. 그리고 객체를 생성하기 위한 설계도라고 할 수 있다. </p><p>클래스와 객체가 햇갈리는 부분이 있을 수 있는데 클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다. 다음 예제를 보자.</p><h3 id="클래스-정의하기"><a href="#클래스-정의하기" class="headerlink" title="클래스 정의하기"></a>클래스 정의하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//맴버변수</span></span><br><span class="line"><span class="keyword">int</span> studentId;</span><br><span class="line">String studentName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//메소드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//학생 정보 출력</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 학생을 추상화 한 Student 클래스의 정의 이다. 클래스는 정의 할때 다음과 같은 규칙이 있다.</p><ul><li>이름의 앞글자는 대문자를 사용(일반적인 관례)</li><li>클래스명은 파일명과 같아야 하고 public 키워드가 붙어야 한다.<br>(한 java 파일 안에 여러 클래스를 정의하는 것은 가능하지만 파일명과 같은 클래스만 public 키워드를 붙일 수 있다)</li></ul><p>위에도 언급하였지만, 클래스를 설계할 때 클래스는 속성과 기능의 묶음이고, 그 클래스로 부터 생성될 객체들은 서로 식별이 가능하도록 설계해야 한다. 그래서 맴버변수에 각 학생들이 식별될 수 있는 고유번호 studentNum을 만든 것을 알 수 있다.</p><p>위 Student 클래스는 정의만 하였고 사용되지 않았다. 이를 사용하는 예제를 보자.</p><h3 id="클래스-사용하기"><a href="#클래스-사용하기" class="headerlink" title="클래스 사용하기"></a>클래스 사용하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student studentLee = <span class="keyword">new</span> Student();</span><br><span class="line">        studentLee.studentId = <span class="number">1</span>;</span><br><span class="line">        studentLee.studentName = <span class="string">"이형석"</span>;</span><br><span class="line">     studentLee.showStudentInfo();</span><br><span class="line">        </span><br><span class="line">Student studentKim = <span class="keyword">new</span> Student();</span><br><span class="line">        studentKim.studentId = <span class="number">2</span>;</span><br><span class="line">        studentKim.studentName = <span class="string">"김종원"</span>;</span><br><span class="line">        studentKim.showStudentInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스는 <code>new Student()</code>라는 선언을 통해 비로소 <code>Student 객체</code>로 생성된 것이다.(객체의 생성을 ‘인스턴스화 되었다’ 라고 불리기도 한다) 그리고 Student 객체를 사용하기 위해 <code>Student 타입</code>의 studentLee 라는 참조 변수로 참조하고 있는 것을 볼 수 있다.(객체를 참조한다고 하였는데, 정확한 뜻은 객체의 주솟값을 참조하고 있는 것 이다)</p><p>이처럼 정의한 클래스를 객체로 생성할 때는 <code>new</code> 키워드를 통해 생성할 수 있다. 이때 ‘객체를 생성한다’ 또는 ‘인스턴스화 한다’라고 한다. </p><p>그리고 위의 예제에서 전달하고자 하는 다른 부분은 똑같은 Student 클래스의 객체를 참조하는 studentLee와 studentKim은 서로 다른 객체라는 것 이다. 두 객체는 서로 다른 공간에 생성되어 다른 주소 값을 가지는 것을 알아두자.</p><h2 id="인스턴스-Instance-메모리-힙-Heap"><a href="#인스턴스-Instance-메모리-힙-Heap" class="headerlink" title="인스턴스(Instance), 메모리 힙(Heap)"></a>인스턴스(Instance), 메모리 힙(Heap)</h2><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0.png?raw=true" alt="메모리 구조"></p><p>위 사진은 메모리의 구조를 나타낸다.</p><p>위 예제와 같이 새로운 객체를 생성하게 되면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>메모리의 힙이란 곳에 새로운 인스턴스가 만들어진다. (그래서 객체는 인스턴스라 불리기도 한다) 우리는 이것을 인스턴스화 한다라고 하고, 이 인스턴스는 자신의 주소 값을 가지고있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Student();  <span class="comment">// ex) 3fb6a447</span></span><br></pre></td></tr></table></figure><p>그리고 참조 변수는 이 인스턴스(객체)의 주소 값을 참조받는 것 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(); <span class="comment">// 3fb6a447 라는 주소 값을 참조한다.</span></span><br></pre></td></tr></table></figure><p>조금 더 살을 붙이자면 이렇듯 new 로 생성된 인스턴스들은 각자 다른 공간에 만들어지고 주솟값도 다르기때문에, 같은 클래스로 만들어진 인스턴트들은 서로 다르다고 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Student();<span class="comment">// 객체 1, 주소 값 ex) 3fb6a447</span></span><br><span class="line"><span class="keyword">new</span> Student();<span class="comment">// 객체 2, 주소 값 ex) 79b4d0f</span></span><br></pre></td></tr></table></figure><p><em>그리고 힙 영역은 프로그래머가 관리해야하는 영역이다. 생성된 객체가 사용되지 않으면 메모리에서 제거해주어야하는데, 자바는 가비지 컬랙터(Garbage Collector)가 필요한 타이밍에 알아서 관리해준다.</em></p><p>메모리 구조에 관한 내용은 원래 더욱 복잡한데, 다른 글에서 자세히 다루도록 하겠다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/JAVA-06-%ED%81%B4%EB%9E%98%EC%8A%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>기쿠지로의 여름 ost - Summer</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/</guid>
      <pubDate>Mon, 27 Apr 2020 10:05:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/5nn5Aq6l020&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/5nn5Aq6l020" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/#disqus_thread</comments>
    </item>
    
    <item>
      <title>말할 수 없는 비밀 - 쇼팽왈츠(편곡)</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/</guid>
      <pubDate>Mon, 27 Apr 2020 10:00:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/kRUhsCcztkQ&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/kRUhsCcztkQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>짱구는 못말려 - 히로시의 회상</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/</guid>
      <pubDate>Sun, 26 Apr 2020 15:42:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/Zi4YF__iYCM&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/Zi4YF__iYCM" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>fate stay night - 운명의 밤</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/</guid>
      <pubDate>Sun, 26 Apr 2020 15:42:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/pYz-v4Z9TZs&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/pYz-v4Z9TZs" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 04. 연산자</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/JAVA-04-%EC%97%B0%EC%82%B0%EC%9E%90/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/JAVA-04-%EC%97%B0%EC%82%B0%EC%9E%90/</guid>
      <pubDate>Wed, 22 Apr 2020 08:16:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;연산자란&quot;&gt;&lt;a href=&quot;#연산자란&quot; class=&quot;headerlink&quot; title=&quot;연산자란?&quot;&gt;&lt;/a&gt;연산자란?&lt;/h2&gt;&lt;p&gt;어떠한 기능 또는 어떤 대상체에 계산과 같은 처리를 수행하는 문자 또는 기호를 연산자라 한다. Java에서의 연산자는 크게 단항, 이항, 삼항, 대입 연산자로 나뉘며, 이항 연산자는 산술, 비교, 논리 연산자로 나뉠 수 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="연산자란"><a href="#연산자란" class="headerlink" title="연산자란?"></a>연산자란?</h2><p>어떠한 기능 또는 어떤 대상체에 계산과 같은 처리를 수행하는 문자 또는 기호를 연산자라 한다. Java에서의 연산자는 크게 단항, 이항, 삼항, 대입 연산자로 나뉘며, 이항 연산자는 산술, 비교, 논리 연산자로 나뉠 수 있다.<a id="more"></a></p><ul><li>연산자(operator) : 어떠한 기능을 수행하는 기호 (+, -, *, / 등)</li><li>피연산자(operand) : 연산자의 작업 대상 (변수, 상수, 수식 등)</li></ul><h2 id="연산자의-종류"><a href="#연산자의-종류" class="headerlink" title="연산자의 종류"></a>연산자의 종류</h2><h3 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자 (+, -, *, /, %)"></a>산술 연산자 (+, -, *, /, %)</h3><p>우리가 평소에 자주 사용하는 연산이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//사용 예제</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b =<span class="number">20</span>;</span><br><span class="line">System.out.println(a + b); <span class="comment">//더하기</span></span><br><span class="line">System.out.println(a - b); <span class="comment">//빼기</span></span><br><span class="line">System.out.println(a * b); <span class="comment">//곱하기</span></span><br><span class="line">System.out.println(a / b); <span class="comment">//나누기</span></span><br><span class="line">System.out.println(a % b); <span class="comment">//나눈 나머지</span></span><br></pre></td></tr></table></figure><h3 id="대입-연산자"><a href="#대입-연산자" class="headerlink" title="대입 연산자(=)"></a>대입 연산자(=)</h3><ul><li>오른쪽에서 왼쪽으로 할당</li><li>변수끼리 할당 가능</li><li>변수에 값이 존재하더라도 다른 값을 할당하면 마지막 할당된 값이 할당</li><li>연산자중에 우선순위가 제일 낮다</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">a = b; <span class="comment">// 변수의 자료형이 같다면 할당 가능 : a 값이 1로 update</span></span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 당연히 자료형에 맞는 타입의 값이면 할당 가능</span></span><br></pre></td></tr></table></figure><h3 id="복합-대입-연산자"><a href="#복합-대입-연산자" class="headerlink" title="복합 대입 연산자(+=, -=, *=, /=, %=)"></a>복합 대입 연산자(+=, -=, *=, /=, %=)</h3><p>연산자와 대입 연산자를 결합한 연산 후 대입 연산</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//복합 대입 연산자</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +=</span></span><br><span class="line">a += b; <span class="comment">// a = a+b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -=</span></span><br><span class="line">a -= b; <span class="comment">// a = a-b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *=</span></span><br><span class="line">a *= b; <span class="comment">// a = a*b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /=</span></span><br><span class="line">a /= b; <span class="comment">// a = a/b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// %=</span></span><br><span class="line">a %= b; <span class="comment">// a = a%b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;=</span></span><br><span class="line">a &amp;= b; <span class="comment">// a = a&amp;b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// |=</span></span><br><span class="line">a |= b; <span class="comment">// a = a | b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ^=</span></span><br><span class="line">a ^= b; <span class="comment">// a = a ^ b;</span></span><br></pre></td></tr></table></figure><h3 id="형변환-연산자-DataType"><a href="#형변환-연산자-DataType" class="headerlink" title="형변환 연산자((DataType))"></a>형변환 연산자(<code>(DataType)</code>)</h3><p>자동형변환의 경우 알아서 형변환이 일어나지만, 명시적으로 형변환을 필요로 할 때 사용가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iNum = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> sNum = (<span class="keyword">short</span>)iNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dNum = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">float</span> fNum = (<span class="keyword">float</span>)dNum;</span><br></pre></td></tr></table></figure><h3 id="증감-연산자"><a href="#증감-연산자" class="headerlink" title="증감 연산자(++, - -)"></a>증감 연산자(++, - -)</h3><ul><li>증가 연산자(++) : 피연산자의 값을 1 증가시킨다.</li><li>감소 연산자(-­ -­) : 피연산자의 값을 1 감소시킨다.</li></ul><p>증감연산자는 피연산자의 앞 또는 뒤에 붙일 수 있는데 그에따라 차이점을 보인다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//전위 형 : 값이 참조되기 전에 증가시키거나 감소시킨다.</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.out.println(++a); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//후위 형 : 값이 참조되고 난 이후 증가시키거나 감소시킨다.</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">System.out.println(b++); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//이 이후에 값이 증가 된상태</span></span><br><span class="line">System.out.println(b); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="비교-연산자-gt-gt-lt-lt-instanceof"><a href="#비교-연산자-gt-gt-lt-lt-instanceof" class="headerlink" title="비교 연산자(&gt;, &gt;=, &lt;, &lt;=, ==, !=, instanceof)"></a>비교 연산자(&gt;, &gt;=, &lt;, &lt;=, ==, !=, instanceof)</h3><p>비교 연산자는 제어문의 조건문이나 반복문에 자주 쓰인다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//사용 예시</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> , b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) <span class="comment">// a 보다 b가 크다 : 참</span></span><br><span class="line"><span class="keyword">if</span>(a &lt;= b) <span class="comment">// a 보다 b가 크거나 같다 : 참</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) <span class="comment">// a 가 b보다 크다 : 거짓</span></span><br><span class="line"><span class="keyword">if</span>(a &gt;= b) <span class="comment">// a 가 b보다 크거나 같다 : 거짓</span></span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="comment">// a 와 b가 같다 : 거짓</span></span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// p가 Person의 객체인지 참, 거짓으로 구분 : 참</span></span><br></pre></td></tr></table></figure><h3 id="비트-연산자-amp"><a href="#비트-연산자-amp" class="headerlink" title="비트 연산자(&amp;, |, ^, ~)"></a>비트 연산자(&amp;, |, ^, ~)</h3><p>데이터를 비트단위로 연산할 수 있는 연산자로 정수형또는 논리형에만 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0</span>&amp;<span class="number">1</span>); <span class="comment">// 비트 단위의 논리곱(AND)</span></span><br><span class="line">System.out.println(<span class="number">5</span>|<span class="number">1</span>); <span class="comment">// 비트 단위의 논리합(OR)</span></span><br><span class="line">System.out.println(<span class="number">0</span>^<span class="number">1</span>); <span class="comment">// 비트 단위의 배타적 논리합(AND)</span></span><br><span class="line">System.out.println(~<span class="number">1</span>); <span class="comment">// 비트 단위의 보수(부정)</span></span><br><span class="line">System.out.println(<span class="number">0</span>&gt;&gt;<span class="number">2</span>); <span class="comment">// 0을 2 만큼 오른쪽으로 이동시킴. 이동한 만큼의 왼쪽 비트는 부호 확장이 발생</span></span><br><span class="line">System.out.println(<span class="number">0</span>&gt;&gt;&gt;<span class="number">1</span>); <span class="comment">// 부호 확장이 없고 이동한 만큼의 왼쪽 비트는 항상 0 으로 채운다</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">true</span>&amp;<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="keyword">true</span>^<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="논리-연산자-amp-amp"><a href="#논리-연산자-amp-amp" class="headerlink" title="논리 연산자(&amp;&amp;, ||, !)"></a>논리 연산자(&amp;&amp;, ||, !)</h3><p>비트 논리 연산자의 경우 연산 대상이 정수형과 논리형에 모두 가능하지만, 논리 연산자의 경우 논리형에만 적용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">true</span> &amp;&amp; <span class="keyword">true</span>);  <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span>); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="keyword">true</span> || <span class="keyword">true</span>);  <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="keyword">true</span> || <span class="keyword">false</span>); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="keyword">false</span> || <span class="keyword">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(!<span class="keyword">true</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(!<span class="keyword">false</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="삼항-연산자"><a href="#삼항-연산자" class="headerlink" title="삼항 연산자( ? : )"></a>삼항 연산자( ? : )</h3><p>조건을 평가해서 소괄호 값이 참, 거짓이냐에 따라 수식1, 수식2 값을 대입한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//조건 연산자 예제</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> result = (<span class="keyword">false</span>) ? num1 : num2;</span><br><span class="line">System.out.println(<span class="string">"결과 : "</span>+ result);</span><br></pre></td></tr></table></figure><h2 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h2><table><thead><tr><th align="center">우선순위</th><th>연산자</th></tr></thead><tbody><tr><td align="center">1</td><td>()   []   .</td></tr><tr><td align="center">2</td><td>++ , - - , ~ , !</td></tr><tr><td align="center">3</td><td>* ,  / ,  %</td></tr><tr><td align="center">4</td><td>+ ,  -</td></tr><tr><td align="center">5</td><td>&gt;&gt; ,  &gt;&gt;&gt; ,  &lt;&lt;</td></tr><tr><td align="center">6</td><td>&gt; ,  &gt;= ,  &lt; ,  &lt;=</td></tr><tr><td align="center">7</td><td>== , !=</td></tr><tr><td align="center">8</td><td>&amp;</td></tr><tr><td align="center">9</td><td>^</td></tr><tr><td align="center">10</td><td>｜</td></tr><tr><td align="center">11</td><td>&amp;&amp;</td></tr><tr><td align="center">12</td><td>｜｜</td></tr><tr><td align="center">13</td><td>a ? b : c</td></tr><tr><td align="center">14</td><td>=</td></tr></tbody></table><p><em>tip. 우선순위에 상관 없이 ()를 사용하여 우선순위를 지정할 수 있다</em></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/JAVA-04-%EC%97%B0%EC%82%B0%EC%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 05. 제어문</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/JAVA-05-%EC%A0%9C%EC%96%B4%EB%AC%B8/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/JAVA-05-%EC%A0%9C%EC%96%B4%EB%AC%B8/</guid>
      <pubDate>Wed, 22 Apr 2020 08:16:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건문이란&quot;&gt;&lt;a href=&quot;#조건문이란&quot; class=&quot;headerlink&quot; title=&quot;조건문이란?&quot;&gt;&lt;/a&gt;조건문이란?&lt;/h2&gt;&lt;p&gt;조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="조건문이란"><a href="#조건문이란" class="headerlink" title="조건문이란?"></a>조건문이란?</h2><p>조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다. <a id="more"></a></p><h3 id="if문"><a href="#if문" class="headerlink" title="if문"></a>if문</h3><p>특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 키워드 if를 사용하면 된다. 그리고 두개의 문장 중 조건에 따라 하나만 실행하고 싶다면 거기에 else를 더 추가하면 된다. else는 if문 소괄호의 조건이 참이 아니라면 실행되는 곳이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if문 예제</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    <span class="comment">//조건 true 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"참입니다"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//조건 false 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"거짓입니다"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if ~ else if 문은 2개 이상의 조건을 주고싶을 때 사용할 수 있는 방법이다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if ~ else if문 예제</span></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1보다 num2가 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num2보다 num1이 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 == num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1과 num2는 같습니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"셋다 해당되지 않습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조건-연산자-삼항-연산자"><a href="#조건-연산자-삼항-연산자" class="headerlink" title="조건 연산자(삼항 연산자)"></a>조건 연산자(삼항 연산자)</h3><p>조건 연산자는 피연산자가 세 개인 연산자이다. 이러한 조건 연산자는 간단한 if~else문을 대체하는 용도로 주로 사용된다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//조건 연산자 예제</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> result = (<span class="keyword">false</span>) ? num1 : num2;</span><br><span class="line">System.out.println(<span class="string">"결과 : "</span>+ result);</span><br></pre></td></tr></table></figure><p>변수 num5 는 선언과 동시에 조건연산자에 의한 값을 할당한다. ()안의 조건이 참이면 num3이 저장될 것이고 , 거짓이라면 num4가 저장될 것 이다. 하지만 임의적으로 false라는 값을 줌으로써 변수 num5에는 num4의 값, 즉 20이 저장되는것을 알 수 있다.</p><h3 id="switch문"><a href="#switch문" class="headerlink" title="switch문"></a>switch문</h3><p>조건에 따라 실행할 문장을 구분한다는 측면에서 if문과 유사하다. else if가 많이 들어가는 상황에서는 switch문이 더 좋은 선택이 될 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    String animal = <span class="string">"고양이"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">        System.out.println(<span class="string">"강아지가 맞습니다"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>레이블(Label)</strong></p><p>위의 switch 내부에 존재하는 키워드 case와 default를 가리켜 레이블이라고 한다. 레이블 case와 default는 코드상에서 위치를 표시하기 위해 사용된다. case는 switch 의 조건과 같은 타입을 가져야하고 같은 결과 값일 경우 그 case 이후의 값들이 출력이된다. 이것은 이후에 나오는 break문으로 제어할 수 있다. </p><p>default는 case에서 switch와 같은 조건의 값이 없다면 실행되는 구문이다. 그리고 case와 default를 보면 들여쓰기가 되어있지 않다. 이는 책에 위치를 표시하는 레이블과 그 성격이 같다. 그리고 레이블은 책을 펼치기 전에 보여야 한다. 이와 마찬가지로 case와 default도 조금이라도 잘 보이도록 들여쓰기 대상에서 제외하는 것이 일반적이다.</p><p>일단 위의 결과를 보게되면 switch의 참거짓을 판단하는 매개변수로 animal이라는 변수를 주었다. 이 변수에 할당된 값은 ‘고양이’ 이다. 당연히 콘솔에 고양이가 맞습니다. 라고 찍힐 것이라고 예상할 수 있지만 결과는 고양이가 맞습니다. 이후에 나오는 모든 조건의 결과</p><p>고양이가 맞습니다.<br>고라니가 맞습니다.<br>해당하는 동물이 없습니다.</p><p>가 찍힌다.</p><p>이는 break 라는 키워드로 case의 실행구문이 끝난 이후 사용해 주어야 하위 case들이 실행 되는 것을 막을 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(animal) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">    System.out.println(<span class="string">"강아지가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">    System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 switch문과는 다르게 각 case가 끝나는 부분에 break가 추가 되었다. 그리고 결과로는 고양이가 맞습니다. 이후의 출력은 사라졌다. 즉 if, else처럼 해당하는 조건에 맞는 결과값만이 출력이 되는 것을 확인 할 수 있다. 이는 switch문의 일반적인 사용 모델이다.</p><hr><h2 id="반복문이란"><a href="#반복문이란" class="headerlink" title="반복문이란?"></a>반복문이란?</h2><p>반복문은 어떤 작업이 반복적으로 수행되도록 할 때 사용된다. while, do~while, for문등을 예로 들 수 있다.</p><h3 id="while문"><a href="#while문" class="headerlink" title="while문"></a>while문</h3><p>먼저 while 문 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//While문</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 결과는 I Like Java가 5번 출력되는 것을 알 수 있다.</p><ul><li>while문의 소괄호에는 반복의 조건을 명시한다. </li><li>true 또는 false가 와야 하므로 이를 반환하는 연산이 오게 된다. </li><li>그리고 그 조건이 true를 반환하는 동안에는 횟수에 상관없이 while문의 중괄호가 반복 실행되는데 , 다음의 패턴으로 반복이 된다.<ol><li>먼저 조건검사</li><li>그리고 결과가 true이면 중괄호 영역 실행</li></ol></li></ul><p>반면에 밑에 예제에서 다루는 do ~ while문은 다음의 패턴으로 진행한다.</p><ol><li>먼저 중괄호 영역 실행</li><li>그리고 조건 검사 후 결과가 true이면 반복 결정<br>밑의 예제를 확인해 보자.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_while문</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"I Like Java "</span> + num2);</span><br><span class="line">    num2++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num2 &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br><p>위 예제는 이전의 while문을 do-while로 바꾼것 뿐이다. 따라서 실행결과는 동일하다. 보는것처럼 while문으로 작성된 문장은 do-while로도 작성가능한 경우가 대부분다. </p><p>따라서 “조건에 따른 반복이 필요하다. 그런데 반드시 한 번은 실행을 해야 한다.” 라는 경우에는 do~while문을 사용하는 것이 괜찮다. 이 이외의 경우에는 while문 또는 이어서 소개하는 for문을 사용하는 것이 바람직하다. 그래야 선택하는 반복문에 더 많은 의미를 부여할 수 있다. </p><h3 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h3><p>이전에 다루었던 while문에서 했던 예제들은 거의 반복하는 값이 정해져있었다. 이처럼 ‘반복의 횟수가 정해져 있는 상황’ 에서는 for문을 이용해서 다음과 같이 작성하는 것이 더 간결하고 뜻도 더 잘 통한다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for문 예제</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Love Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서 실행 흐름을 보자면 </p><ol><li>변수의 선언및 초기화</li><li>반복 조건이 true인지 확인</li><li>반복 영역을 실행 (반복 조건이 true이면)</li><li>변수의 값 증가</li></ol><p>그리고 그 이후 두번째 반복부터는 첫번째 조건인 변수의 선언및 초기화 부분은 지나치게 된다. </p><h3 id="break-와-continue"><a href="#break-와-continue" class="headerlink" title="break 와 continue"></a>break 와 continue</h3><p>break 문은 앞서 switch문을 빠져나가는 용도로 다루었었는데, 마찬가지로 반복문을 빠져나가는 용도로도 사용된다.<br>보통 if문과 함께 사용되어 특정 조건이 만족될 때, 이를 감싸는 반복문을 빠져나가도록 구성이 된다. break는 이전에 다루던 것과 별 차이가 없기 때문에 따로 예제를 다루지 않는다.</p><p>continue문은 break문과 혼동하기 쉬워서 주의가 필요하다. 우선 continue는 반복문의 탈출과 거리가 멀다. 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건 검사 부분으로 이동시킨다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n++)&lt;<span class="number">5</span>) &#123;<span class="comment">//while 하단부에서 증가시켜줬던 구문을 이런식으로 작성할 수 있다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 구문을 실행시켜보면 총 4번 실행 되는 것을 알 수 있다. 0~4까지 총 5번 출력되는 것이 맞는 것 이라고 생각 할 수 있는데, 이유는 조건에 따른 continue 구문이 실행하게 되면 그 이후의 문장은 무시하고 다시 반복문의 조건 검사로 이동하게 되기때문이다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/JAVA-05-%EC%A0%9C%EC%96%B4%EB%AC%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 03. 상수와 형변환</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/JAVA-03-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/JAVA-03-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</guid>
      <pubDate>Wed, 22 Apr 2020 07:22:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;상수-Constant-란&quot;&gt;&lt;a href=&quot;#상수-Constant-란&quot; class=&quot;headerlink&quot; title=&quot;상수(Constant)란?&quot;&gt;&lt;/a&gt;상수(Constant)란?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;변하지 않는 수를 말한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="상수-Constant-란"><a href="#상수-Constant-란" class="headerlink" title="상수(Constant)란?"></a>상수(Constant)란?</h2><ul><li>변하지 않는 수를 말한다. <a id="more"></a></li></ul><h2 id="상수-선언"><a href="#상수-선언" class="headerlink" title="상수 선언"></a>상수 선언</h2><p>자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. </p><ul><li>값을 딱 한 번만 할당할 수 있다.</li><li>한 번 할당된 값은 변경이 불가능하다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tip.상수의 선언</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tip.선언된 상수에 값 할당</span></span><br><span class="line">NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tip.그 이후로 값의 변경은 불가능하다</span></span><br><span class="line">NUM = <span class="number">5</span>; <span class="comment">// 에러</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tip.변수와 마찬가지로 선언과 동시에 초기화가 가능하다.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> FINAL_NUMBER = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>상수의 관례</strong><br>그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다.</p><ul><li>상수의 이름은 모두 대문자로 짓는다.</li><li>이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.</li></ul><h2 id="리터럴-literal"><a href="#리터럴-literal" class="headerlink" title="리터럴(literal)"></a>리터럴(literal)</h2><p>프로그램에서 사용하는 모든 숫자, 문자, 논리 값 등을 가리켜 리터럴이라고 한다. 모든 리터럴(리터럴 상수라고도 한다)들은 상수 풀(Constant Pool)이라는 곳에 저장되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>; <span class="comment">//right value에 해당하는 100이 리터럴이다.</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'A'</span>; <span class="comment">//마찬가지로 A도 리터럴 이다.</span></span><br></pre></td></tr></table></figure><p><strong>리터럴(숫자, 문자, 논리 값) –로딩–&gt; Constant Pool(10, ‘A’, true) –대입, 복사–&gt; 변수</strong></p><h2 id="형변환"><a href="#형변환" class="headerlink" title="형변환"></a>형변환</h2><p>서로 다른 자료형의 값이 대입이 되는 경우 형변환이 일어난다.</p><p><strong>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</strong></p><p>일반적으로 위와 같이 화살표의 방향대로 대입이 되면 묵시적인 형변환이 일어나고 아닐 경우 직접 명시적인 형변환을 해주어야 한다.</p><h3 id="묵시적-형-변환-Implicit-Type-Conversion"><a href="#묵시적-형-변환-Implicit-Type-Conversion" class="headerlink" title="묵시적 형 변환(Implicit Type Conversion)"></a>묵시적 형 변환(Implicit Type Conversion)</h3><ul><li>작은 수에서 큰 수로 대입</li><li>덜 정밀한 수에서 더 정밀한 수로 대입(정수에서 실수)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ImplicitConterSionTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//정수</span></span><br><span class="line">  <span class="keyword">byte</span> bNum = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">short</span> sNum = bNum;</span><br><span class="line">  <span class="keyword">int</span> iNum = sNum;</span><br><span class="line">  <span class="keyword">long</span> lNum = iNum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//실수</span></span><br><span class="line">  <span class="keyword">float</span> fNum = lNum;</span><br><span class="line">  <span class="keyword">double</span> dNum = fNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제처럼 크기가 작은 수에서 큰 타입 순서로 대입을 할경우 자동적인 형변환이 일어난다.</p><h3 id="명시적-형-변환-Explicit-Type-Conversion"><a href="#명시적-형-변환-Explicit-Type-Conversion" class="headerlink" title="명시적 형 변환(Explicit Type Conversion)"></a>명시적 형 변환(Explicit Type Conversion)</h3><ul><li>변환되는 자료형을 명시(타입 캐스팅)<ul><li>이에 따른 자료의 손실이 발생할 수 있다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExplicitConterSionTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 예제 1</span></span><br><span class="line">  <span class="keyword">int</span> iNum = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">byte</span> bNum = (<span class="keyword">byte</span>)iNum;</span><br><span class="line">  <span class="comment">//형변환을 억지로 하면 데이터 손실을 불러올 수 있다.</span></span><br><span class="line">  System.out.println(bNum);<span class="comment">//-24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 예제 2</span></span><br><span class="line">  <span class="keyword">double</span> dNum = <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">float</span> fNum = <span class="number">0.9F</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> iNum1 = (<span class="keyword">int</span>)dNum + (<span class="keyword">int</span>)fNum; <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">int</span> iNum2 = (<span class="keyword">int</span>)(dNum + fNum); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">  System.out.println(iNum1);</span><br><span class="line">  System.out.println(iNum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제 1은 int형 변수에 1000의 값을 할당하였다. 그리고 byte에게 대입하려고 한다. 하지만 byte는 int보다 크기가 작음으로 <code>(byte)</code> 와같이 프로그래머가 직접 byte형으로 변환 하겠다고 명시해주어야한다. 그리고 명시적인 형변환을 하게 되면 데이터가 손실될 수 도 있다. 예제 1의 경우 byte가 담을 수 있는 크기를 초과하여 값이 잘려 -24가 출력 되는 것을 알 수 있다.</p><p>예제 2의 핵심은 두개의 실수를 더하여 정수형 변수에 대입하려고 하는 것 이다. <code>iNum1</code>의 경우엔 각 <code>dNum</code>, <code>fNum</code> 의 값을 형변환 하고 연산을 진행한다. 즉 각자의 값은 소숫점이 잘려나가 1, 0이된다. 결국 1+0의 연산을 통해 1이라는 값이 <code>iNum1</code>에 대입이 된다. <code>iNum2</code>의 경우 먼저 변수의 값이 연산을 진행 한 이후 타입캐스팅이 일어난다 1.2 + 0.9 = 2.1이 되고 그 이후 소숫점이 잘려 2라는 값이 대입이 되는 것을 알 수 있다. 이것은 이 다음에 다룰 연산자에서 연산 우선순위를 통해 알 수 있다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/JAVA-03-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
