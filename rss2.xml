<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jaebeom&#39;s Blog</title>
    <link>http://gojaebeom.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/98c3781dafc67dfe731441beeee5e4ec</url>
      <title>Jaebeom&#39;s Blog</title>
      <link>http://gojaebeom.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>재범의 기술 블로그 입니다.</description>
    <pubDate>Mon, 04 May 2020 04:51:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JAVA - 17. 객체지향</title>
      <link>http://gojaebeom.github.io/2020/05/02/java/java17-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/</link>
      <guid>http://gojaebeom.github.io/2020/05/02/java/java17-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/</guid>
      <pubDate>Sat, 02 May 2020 13:56:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체지향-프로그래밍-Object-Oriented-Programming-이란&quot;&gt;&lt;a href=&quot;#객체지향-프로그래밍-Object-Oriented-Programming-이란&quot; class=&quot;headerlink&quot; title=&quot;객체지향 프로그래밍(Object Oriented Programming )이란?&quot;&gt;&lt;/a&gt;객체지향 프로그래밍(Object Oriented Programming )이란?&lt;/h2&gt;&lt;p&gt;객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체란 하나의 역할을 수행하는 ‘메소드와 변수(데이터)’의 묶음으로 봐야 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="객체지향-프로그래밍-Object-Oriented-Programming-이란"><a href="#객체지향-프로그래밍-Object-Oriented-Programming-이란" class="headerlink" title="객체지향 프로그래밍(Object Oriented Programming )이란?"></a>객체지향 프로그래밍(Object Oriented Programming )이란?</h2><p>객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체란 하나의 역할을 수행하는 ‘메소드와 변수(데이터)’의 묶음으로 봐야 한다.<a id="more"></a></p><p>어느 유튜버의 강의을 보다가 가장 마음에 와닿았던 맨트가 있었다. 철학자 <strong>플라톤</strong>의 <strong>이데아 론</strong>을 객체지향(OOP)과 빗대어 설명한 부분이다.</p><p>“<em>목수의 머릿속엔 가장 이상적이고 완벽한 책상이 하나 존재한다. 목수가 현실에 책상을 만들때는 그 이상적인 세계에 존재하는 책상을 본따서 만든다고 한다. 즉 현실의 책상은 목수의 머릿속에 있는 책상의 이상적인 설계도를 본따서 만든다고 생각할 수 있다. 플라톤은 이 이상적인 세계를 <strong>이데아</strong>라고 불렀다. 그리고 현실에 존재하는 물건은 그 이상적인 세계에 있는 물건을 가져와 복제한 <strong>레플리카</strong>라고 했다.</em>“</p><p>갑자기 철학적인 이야기가 나와 이상하다고 생각할 수 있지만, 우리가 프로그래밍에 사용하는 class, object 들은 실제로 고대 그리스 <strong>플라톤의 이데아론</strong>에서 왔다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>우리는 위와 같이 클래스를 정의하고 사용해왔다. 하지만 위의 클래스는 단지 정의 되어져 있을 뿐 사용된 것은 아니다. 이것은 우리가 머릿속에서 생각하는 이상적인 설계도일 뿐이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Dog backgoo = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">  Dog rudy = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">  Dog jack = <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 머릿속의 개라는 이미지를 현실에 만들었을때(인스턴스화), 비로소 이것은 객체로써 존재하게 되는 것 이다. 우리는 이것을 머리에 암기하는 것이 아니라, 자연스러운 흐름대로 이해할 필요가 있다.</p><p>이제 객체지향의 특징들에 대해서 알아보자.</p><h3 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h3><ul><li><em>추상화</em></li><li><em>캡슐화</em></li><li><em>상속</em></li><li><em>다형성</em></li></ul><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><p>추상화에 사전적 정의는 다음과 같다.</p><blockquote><p>추상(抽象)은 사물을 정확하게 이해하기 위해서는 사물이 지니고 있는 여러 가지 측면 가운데서 특정한 측면만을 가려내어 포착하는 것이다. 어떤 일면만을 추상하는 것은 다른 측면을 버린다는 것과 같다. 이것을 ‘사상(捨象)’이라 한다.</p></blockquote><p>추상화에 대한내용은 생각하기에 따라 다르기도하고 설명이 너무 난잡해질 수 도 있는 것 같다. 정말 간단하게 생각하자면, <strong>자바에서 추상화란 공통된 속성(변수)과 행위(메소드)를 모아서 클래스를 만드는 것이다.</strong></p><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>객체지향에서 캡슐화란 두가지 특징이 있다.</p><ul><li><em>객체의 속성(맴버변수, data fields)과 행위(메서드, methods)를 하나로 묶는다.</em></li><li><em>실제 구현 내용 일부를 외부에 감추어 은닉한다.</em></li></ul><p>외부에 감추는 방법으로는 언어적 측면으로 접근제한자를 두어 은닉의 정도를 기술하여 구현한다. 이것이 캡슐화에서 중요한 <strong>정보은닉</strong>이다.</p><h3 id="정보은닉-개념"><a href="#정보은닉-개념" class="headerlink" title="정보은닉 개념"></a>정보은닉 개념</h3><p>정보은닉이란 캡슐화된 객체의 내부구현을 외부로부터 숨기는 것이다. 이전 포스트에서도 다루었는데, 자바에서 정보란 클래스의 인스턴스변수(맴버변수, 필드, 속성 등)를 말한다. 보통 이러한 정보들은 접근제한자를 두어 외부에서 직접 접근하지 못하게 하고 메소드를 통해서만 변수에 접근할 수 있게 하는 방식을 많이 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 Person은 사람의 기본적인 특징 ‘이름을 가지고있다’ 를 반영한 클래스이다. 이를 인스턴스화하여 다음과 같이 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Person jaebeom = <span class="keyword">new</span> Person();</span><br><span class="line">  jaebeom.setName(<span class="string">"고재범"</span>);</span><br><span class="line">  System.out.println(jaebeom.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 작성자인 본인이 만든 클래스이다. 이것을 만든 의도는 본인이 가장 잘 이해하고있다.(잘 만들었던 못 만들었던 만든사람의 의도가 명확하다) 그리고 작성자는 맴버변수인 name에 값을 바로 대입하지 않고 메소드를 통해서 값을 할당하고 사용되길 원한다. 하지만 위의 예제의 경우에 접근지시자(접근제한자)를 사용하지 않았다. 그로 인하여 다른 사용자가 잘못 사용하게되는 예를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Person jade = <span class="keyword">new</span> Person();</span><br><span class="line">  jade.name = <span class="string">"고재범"</span>;</span><br><span class="line">  System.out.println(jade.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 클래스의 맴버변수에 바로 접근하여 값을 할당하고 출력하는 모습을 볼 수 있다. 이는 작성자의 의도와 다르게 잘못된 방향으로 사용이 되고있다. 위의 경우 치명적인 문제가 생길 일은 없지만, 맴버변수 name을 위해 정의한 setName, getName 메소드가 불필요하게 되어버렸다. 이렇게 작성자의 의도와는 반대로 사용이 되어지는 것을 막기위해 우리는 정보를 은닉할 필요가 있다. 사실 위의 예제로는 정보은닉의 필요성을 못 느낄 수 도 있다. 그렇다면 내용을 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(weight &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"몸무게는 0보다 작거나 같을 수 없습니다! 다시 입력해주세요"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 클래스에 몸무게라는 속성을 추가하였다. 그리고 setWeight 메소드를 보면 몸무게는 0키로그램보다 작거나 같을 수 없기 때문에 예외적인 부분을 처리하고 있다. 하지만 사용자가 이외의 방법으로 접근하여 -999 같은 값을 입력할 수 있다면 이는 프로그램 실행의 문제로도 이어질 수 있는 부분이다. 위의 예제를 다음과 같이 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(weight &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"몸무게는 0보다 작거나 같을 수 없습니다! 다시 입력해주세요"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>접근 제한자 private 을 속성에 지정하여 외부에서의 접근을 막는다. 그리고 이 속성들은 오직 메소드(행동)을 통해서만 통제할 수 있도록 할 수 있다. (public 은 외부의 모든 곳에서 사용이 가능하지만 따로 접근 제한자를 명시하지 않으면 default 제한자와 같다. 이는 외부 패키지와 상속받은 클래스등에서는 사용할 수 없게 된다)</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다. 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하게 되는데, 이러한 작업을 <strong>‘오버라이딩(Overriding)’</strong>이라고 한다. 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> IMEI;<span class="comment">//고유번호</span></span><br><span class="line">  <span class="keyword">private</span> String model;<span class="comment">//폰의 기종 이름</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//객체를 생성시 기본정보를 기입받는 생성자</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//전화</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messege</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//메세지</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 Phone에 대한 클래스의 정의이다. 이 클래스는 외부에서 잘 사용되어 지고 있다. 하지만 시대가 변함에 따라 스마트 폰이 나오고 Phone 클래스에도 새로운 기능들을 넣으려고 한다. 만약 Phone의 클래스 내부의 값이나 메소드들의 로직을 직접 수정하게 되면 지금까지 Phone 클래스와 의존성이 있는 모든 클래스들을 다시 수정해야 한다. 예를 들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> IMEI;</span><br><span class="line">  <span class="keyword">private</span> String model;</span><br><span class="line">  <span class="keyword">private</span> String OS; <span class="comment">//새로 추가된 속성, 안드로이드 또는 ios 의 OS 탑재 가능</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//객체 생성시 기본정보를 입력받는 생성자 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model, String OS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    <span class="keyword">this</span>.OS = OS; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//새로 추가된 메소드, 웹 검색을 할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webSearch</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">//하지만 기존의 phone에서는 불가능하기때문에 스마트폰이아니면 불필요한 메소드가 된다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Phone myPhone = new Phone(000000, "모토로라"); //에러</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 기존에 사용하던 생성자는 매개변수를 2개만 받았는데</span></span><br><span class="line"><span class="comment">      * OS의 종류까지 초기에 입력받는 것으로 수정되었다.</span></span><br><span class="line"><span class="comment">      * 물론 메소드 오버로딩으로 기존의 생성자는 유지하고 새로운 생성자를 만들 수 도 있지만, </span></span><br><span class="line"><span class="comment">      * 이 밖에도 추가되고 수정되어야 할것이 많다고 가정해보자.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//결국 다음과 같이 수정해야 한다.</span></span><br><span class="line">      Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>, <span class="string">"OS 없음"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 내부적인 코드의 변화로 인해 Phone과 의존성이 있는 클래스들은 모두 수정해야 한다. 하지만 기존의 Phone 클래스는 수정하지 않고 Phone의 기능을 상속받아 새로 SmartPhone이라는 클래스를 정의한다면 어떻게 될까. 예제를 통해 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> IMEI;</span><br><span class="line"><span class="keyword">private</span> String model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String OS;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SmartPhone</span><span class="params">(<span class="keyword">int</span> IMEI, String model, String OS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(IMEI, model);<span class="comment">//부모 클래스 생성자에게 필요한 매개변수 전달</span></span><br><span class="line">    <span class="keyword">this</span>.OS = OS;<span class="comment">//추가적으로 OS 종류 전달</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bluetooth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//블루투스</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiFi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//와이파이</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>);<span class="comment">//기존 사용자는 손대지 않는다.</span></span><br><span class="line"></span><br><span class="line">    SmartPhone yourPhone = <span class="keyword">new</span> SmartPhone(<span class="number">000001</span>, <span class="string">"A90"</span>, <span class="string">"안드로이드"</span>);<span class="comment">// 새로 스마트폰을 사용하는 사용자만 바꾸어주면 된다.</span></span><br><span class="line">    yourPhone.wiFi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제와 같이 기존의 폰을 사용 사용하는 사람은 따로 변화를 주지 않아도 되고, 새로 스마트폰을 쓰는 사람들만 SmartPhone 객체로 생성해주면 되는 것 이다. 이건 어디까지나 글쓴이가 생각하는 예제이다. 본인한테 맞는 방법으로 생각하는 것이 좋을 것 같다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>객체 지향 언어에서 다형성이란 하나의 클래스나 메서드가 다양한 방식으로 동작이 가능 한 것을 의미한다. 다형성에는 오버로딩과 오버라이딩이 있다. </p><h3 id="오버라이딩-Overriding"><a href="#오버라이딩-Overriding" class="headerlink" title="오버라이딩(Overriding)"></a>오버라이딩(Overriding)</h3><p>상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello A"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello B"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.hello();</span><br><span class="line"></span><br><span class="line">    A b = <span class="keyword">new</span> B();<span class="comment">//B는 A를 상속받기 때문에 B객체를 A타입의 참조변수가 참조할 수 있다.</span></span><br><span class="line">    <span class="comment">//B b = new B(); // 물론 이 방법도 가능하다.</span></span><br><span class="line">    b.hello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 A클래스를 B클래스가 상속 받으면서 기존의 A클래스에 있는 Hello 메소드를 B클래스에서 재정의 하였다. 메소드명을 바꾼다거나, 매개변수를 바꾼다거나, 반환형을 바꾼다는 개념이 아니다. 메소드 내부 로직을 바꾸는 것을 의미한다. 위의 상속의 개념에서 사용되는 overriding은 상속을 보다 편리하게 해주는 장점이 있다.</p><h3 id="오버로딩-Overloading"><a href="#오버로딩-Overloading" class="headerlink" title="오버로딩(Overloading)"></a>오버로딩(Overloading)</h3><p>한 클래스 내에 동일한 이름의 메소드를 둘 이상 정의한느 것은 허용되지 않는다. 그러나 매개변수의 선언이 다르면 가능하다. 그리고 이것을 메소드 오버로딩이라 한다.</p><p><strong>메소드 오버로딩의 조건</strong></p><ul><li><em>메소드의 이름</em></li><li><em>메소드의 매개변수 정보</em></li></ul><p>실제로 우리가 자주 사용하는 println 메소드를 예로 들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br></pre></td></tr></table></figure><p>우리가 println을 쓰면서 String 값, int 값, double 값 등등의 값을 줄 수 있엇던 이유 역시 오버로딩이 있었기 때문에 가능하다. 만약 오버로딩이라는 것이 없었다면 아마 우리는 다음과 같은 메소드를 사용했을 것이다..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnBoolean</span><span class="params">(<span class="keyword">boolean</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnChar</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnString</span><span class="params">(String x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnDouble</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br></pre></td></tr></table></figure><p>원래 자바 포스트를 작성하기 이전에 다룰려고 했던 객체지향 특징이였다. 하지만 자바 문법에 어느정도 익숙해지고 예제를 이해하면서 넘어가면 더 자연스러울 거라고 생각하고 이 시점에 글을 작성하게 되었다.</p><p><em>이번 포스팅은 글쓴이의 주관적인 생각이 많이 들어가있는 글이기 때문에 틀리거나 추가 설명이 필요하다고 생각되는 부분은 지적해주시면 감사하겠습니다.(오타는 어디에나 존재합니다..)</em></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/02/java/java17-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 16. 인터페이스</title>
      <link>http://gojaebeom.github.io/2020/04/29/java/java16-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</link>
      <guid>http://gojaebeom.github.io/2020/04/29/java/java16-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</guid>
      <pubDate>Wed, 29 Apr 2020 13:56:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;인터페이스란&quot;&gt;&lt;a href=&quot;#인터페이스란&quot; class=&quot;headerlink&quot; title=&quot;인터페이스란?&quot;&gt;&lt;/a&gt;인터페이스란?&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleIF&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위의 예제는 인터페이스 선언의 모습이다. 기본 골격은 클래스와 동일하다. 그러나 class 대신 interface라는 키워드를 사용하고, 내부에 있는 메소드는 몸체 없이 세미콜론으로 마무리 된다. 위와 같이 몸체가 비어있는 메소드를 가리켜 &lt;strong&gt;추상 메소드(Abstract Methods)&lt;/strong&gt; 라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="인터페이스란"><a href="#인터페이스란" class="headerlink" title="인터페이스란?"></a>인터페이스란?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ExampleIF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 인터페이스 선언의 모습이다. 기본 골격은 클래스와 동일하다. 그러나 class 대신 interface라는 키워드를 사용하고, 내부에 있는 메소드는 몸체 없이 세미콜론으로 마무리 된다. 위와 같이 몸체가 비어있는 메소드를 가리켜 <strong>추상 메소드(Abstract Methods)</strong> 라 한다. <a id="more"></a></p><p>그리고 인터페이스를 대상으로 인스턴스 생성이 불가능하다. 다른 클래스에 의해 상속이 되어 사용될 뿐이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>클래스가 인터페이스를 상속하는 행위는 <strong>상속</strong> 이 아닌 <strong>구현(Implementation)</strong> 이라 한다. 문법 관계는 상속과 동일하지만 본질은 구현이기 때문이다. 위의 예제에 클래스에서 인터페이스를 상속할때 extends 라는 키워드 대신 implements가 사용되어진 것을 볼 수 있다.</p><h2 id="인터페이스의-특징"><a href="#인터페이스의-특징" class="headerlink" title="인터페이스의 특징"></a>인터페이스의 특징</h2><p>클래스의 인터페이스 구현을 조금 더 구체적으로 보자면 다음과 같은 특징이 있다.</p><ul><li><em>구현할 인터페이스를 명시할 때 키워드 implements를 사용한다.</em></li><li><em>한 클래스는 둘 이상의 인터페이스를 동시에 구현할 수 있다.</em></li><li><em>상속과 구현은 동시에 가능하다.</em></li><li><em>인터페이스의 형(타입)을 대상으로 참조변수의 선언이 가능하다.</em></li><li><em>인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.</em></li></ul><p>implements를 사용하는 것은 위의 예제에서 알 수 있고, 다수의 인터페이스를 상속한다는 것은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF01</span>, <span class="title">ExampleIF02</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>상속과 구현이 동시에 가능하다는 말은 이전까지 상속에 대하여 포스팅하였는데, 하위 클래스가 상위 클래스를 상속하는 행위와 인터페이스를 구현하는 행위를 동시에 할 수 있다는 뜻이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">extends</span> <span class="title">ExampleSuperClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF01</span>, <span class="title">ExampleIF02</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>그 이후의 특징들은 말이 조금 어렵게 느껴질 수도 있다. 먼저 인터페이스의 타입을 대상으로 참조변수의 선언이 가능하다는 말은 상속에서도 비슷한 예제를 다루었는데 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">extends</span> <span class="title">SuperExampleClass</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExampleClass object1 = <span class="keyword">new</span>  ExampleClass();</span><br><span class="line">        SuperExampleClass object2 = <span class="keyword">new</span> ExampleClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 ExampleClass 의 인스턴스를 생성하고 참조변수에 할당하려고한다. 그렇다면 참조변수의 타입은 ExampleClass의 인스턴스(객체) 이기때문에 당연히 ExampleClass가 될 것 이다. 그리고 ExampleClass가 상속한 SuperExampleClass도 ExampleClass의 부모클래스이기때문에 ExampleClass의 참조변수 타입으로써 인스턴스 할당이 가능 한 것이다. (물론 자식 클래스에서 새로 구현된 메소드는 부모클래스 형인 참조변수에서는 사용할 수 없다)</p><p>본론으로 돌아와 인터페이스를 대상으로 참조변수의 선언이 가능하다는것은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExampleIF obj = <span class="keyword">new</span> ExampleClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 상속클래스의 참조변수 선언 예제와 비슷하다. 구현한 ExampleIF 인터페이스 역시 ExampleClass 클래스의 인스턴트를 할당할 수 있는 참조변수가 된다는 것 이다.</p><p>그렇다면 자연스럽게 ‘인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다’ 라는 것도 단순하게 생각하면 된다. 인터페이스의 구현되지않은 추상메소드 역시 메소드임으로, 이를 상속하는 인터페이스의 메소드를 재정의(오버라이딩)해주어야 한다. 이는 선택사항이 아닌 강제성이 부여된다.</p><h2 id="인터페이스의-본질적-의미"><a href="#인터페이스의-본질적-의미" class="headerlink" title="인터페이스의 본질적 의미"></a>인터페이스의 본질적 의미</h2><p>인터페이스의 사전적 의미는 연결점 또는 접점으로 둘 사이를 연결하는 매개체를 뜻한다. 실제로 자바의 인터페이스는 그런 역할을 한다. 그럼 이와 관련하여 간단한 예를 하나 들겠다.</p><ul><li><em>몬스터의 종류는 다양하다. 몬스터는 이름과 각자의 특성이 있다. 이중 슬라임과 스켈레톤을 몬스터의 한 예로 볼 수 있다.</em></li></ul><p>이렇듯 몬스터와 슬라임, 스켈레톤 등이 연결되는 한 예를 보았다. 그렇다면 이것을 코드로 구현해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//이름</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//특성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slime</span> <span class="keyword">implements</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"슬라임"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"몸이 액체로 되어있음"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skeleton</span> <span class="keyword">implements</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"스켈레톤"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"뼈만 앙상한 언데드 몬스터"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Monster slime = <span class="keyword">new</span> Slime();</span><br><span class="line">slime.name();</span><br><span class="line">slime.characteristic();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Monster skeleton = <span class="keyword">new</span> Skeleton();</span><br><span class="line">skeleton.name();</span><br><span class="line">skeleton.characteristic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 몬스터들이 가지고있는 기본적인 속성들을 인터페이스에 추상메소드를 만들어놓고 각 Slime과 Skeleton 클래스들이 이것을 구현한 예제이다. Slime과 Skeleton은 대부분의 RPG 게임에서 많이 다루는 괴물들이기때문에 Monster라는 접점이 있다.</p><h2 id="인터페이스의-문법-구성"><a href="#인터페이스의-문법-구성" class="headerlink" title="인터페이스의 문법 구성"></a>인터페이스의 문법 구성</h2><p>인터페이스에 존재할 수 있는 메소드에는 추상 메소드, 디폴트 메소드, static 메소드가 있다. 그리고 인터페이스 간 상속도 가능하며 인터페이스의 타입 이름을 대상으로 instance of 연산을 할 수도 있다. 즉 많은 특성이 클래스와 유사하다.</p><p>위의 예제에서 다음같이 인터페이스를 정의하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 위 인터페이스에 정의된 추상 메소드에는 다음의 특징이 있다.</p><ul><li><em>인터페이스의 모든 메소드는 public 선언된 것으로 간주합니다.</em></li></ul><p>즉 인터페이스 내에 위치하는 메소드는 별도의 선언이 없어도 public이 된다. 때문에 위의 인터페이스 정의에서 메소드 앞에 public을 붙일 필요가 없다. 그리고 인터페이스에서도 변수를 선언할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> DEFAULT_HP = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> DEFAULT_PAWER = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이렇게 인터페이스 내에 선언되는 변수에는 다음의 특징이 있다. </p><ul><li><em>반드시 선언과 동시에 값으로 초기화를 해야 한다.</em></li><li><em>모든 변수는 public, static, final 이 선언된 것으로 간주한다.</em></li></ul><p>결론적으로 인터페이스 내에 선언된 변수는 상수이다. </p><h2 id="인터페이스-간-상속"><a href="#인터페이스-간-상속" class="headerlink" title="인터페이스 간 상속"></a>인터페이스 간 상속</h2><p>위에 다루었던 몬스터 인터페이스를 통해 구현된 몬스터들이 있다. 하지만 설계를 하던중 보스몬스터급인 녀석들은 차별을 두려고 한다. 하지만 몬스터 인터페이스에 메소드를 만들게 되면 구현하는 클래스에서는 이것이 강제가 되기때문에 모든 몬스터에게 불필요한 보스몬스터의 기능을 담은 메소드를 강제구현시켜야한다. 그렇다고 보스몬스터가 몬스터와 다른것은 아니다. 공통되는 부분도 존재하기 때문이다. 이런 경우 우리는 인터페이스간의 상속을통해서 문제를 해결할 수 있다. 글로만 이해하기 어려우니 예제를 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//이름</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//특성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BossMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BossSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BossItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minotaur</span> <span class="keyword">implements</span> <span class="title">BossMonster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"미노타우르스"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"소 머리에 인간의 몸을 한 거대한 몬스터"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보스 몬스터 한정 기술"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보스 몬스터 한정 아이템"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전의 Monster 인터페이스는 수정하지 않고, 새로운 BossMonster 인터페이스를 만들었다. 그리고 이전의 Monster 인터페이스를 상속하여 Monster의 기본적인 기능들은 가져오고 보스몬스터만의 새로운 기능이 추가가 된 것을 알 수 있다. 이것은 이전에 만들었던 슬라임과 스켈레톤의 코드는 수정할 필요없이 앞으로 추가될 보스몬스터만 BossMonster 인터페이스를 구현할 수 있다는 이점이 있다.</p><p>그리고 위의 인터페이스간 상속을 명시할때 extends 키워드를 사용하는데 이에 대한 내용을 정리하자면 다음과 같다.</p><ul><li><em>두 클래스 사이의 상속은 extends로 명시한다.</em></li><li><em>두 인터페이스 사이의 상속도 extneds 로 명시한다.</em></li><li><em>인터페이스와 클래스 사이의 구현만 implements로 명시한다.</em></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/29/java/java16-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 15. 상속 04</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/java15-%EC%83%81%EC%86%8D04/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/java15-%EC%83%81%EC%86%8D04/</guid>
      <pubDate>Mon, 27 Apr 2020 12:09:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Object-클래스&quot;&gt;&lt;a href=&quot;#Object-클래스&quot; class=&quot;headerlink&quot; title=&quot;Object 클래스&quot;&gt;&lt;/a&gt;Object 클래스&lt;/h2&gt;&lt;p&gt;클래스를 정의할 때 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Object-클래스"><a href="#Object-클래스" class="headerlink" title="Object 클래스"></a>Object 클래스</h2><p>클래스를 정의할 때 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>두 클래스의 정의는 동일하다.</p><p>물론 위의 설명에도 언급했듯이 상속하는 클래스가 있는 경우에는 Object 클래스를 상속하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>그러나 이 경우에도 OtherClass 또는 OtherClass가 상속하는 클래스가 Object 클래스를 상속한다. 결국 자바의 모든 클래스는 Object 클래스를 직접 혹은 간접적으로 상속하게 되어있다. 그렇다면 자바의 모든 클래스는 Object 클래스를 상속하도록 한 이유는 무엇일까?</p><p>이는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다. 한 예로 자바의 모든 인스턴스는 다음 메소드의 인자로 전달될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> <span class="comment">// System.out.println 메소드</span></span></span><br></pre></td></tr></table></figure><p>위 메소드의 매개변수 형이 Object이다. 따라서 자바의 모든 인스턴스는 위 메소드의 인자가 될 수 있다. 그리고 위의 메소드는 인자로 전달된 인스턴스의 다음 메소드를 호출한다. 이 메소드는 Object 클래스에 정의되어 있는 메소드이므로 모든 인스턴스를 대상으로 호출이 가능하다.</p><p>이 블로그엔 포스팅하지 않았지만 글쓴이의 github 에 <a href="https://github.com/gojaebeom/java_tutorial" rel="external nofollow noopener noreferrer" target="_blank">String 클래스 예제</a>에 대해 다루었다.(목차에서 String 클래스 부분의 글들을 찾아보면 된다) </p><p>이 예제에서 클래스를 정의하면서 toString 메소드를 정의한 바 있다. 그런데 사실 이것은 Object 클래스의 toString 메소드를 오버라이딩 한 것 이다. 이와 관련해서 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//오브젝트 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">super</span>.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"My Bread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreamBread</span> <span class="keyword">extends</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bread 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"my CreamBread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridingToString</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bread b1 = <span class="keyword">new</span> Bread();</span><br><span class="line">Bread b2 = <span class="keyword">new</span> CreamBread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//b1이 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2가 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="클래스와-메소드의-final-선언"><a href="#클래스와-메소드의-final-선언" class="headerlink" title="클래스와 메소드의 final 선언"></a>클래스와 메소드의 final 선언</h2><p>클래스를 정의하는데 있어서 해당 클래스를 다른 클래스가 상속하는 것을 원치 않는다면, 다음과 같이 final 선언을 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;...&#125; <span class="comment">//MyClass 는 다른 클래스가 상속 할 수 없음</span></span><br></pre></td></tr></table></figure><p>대표적인 final 클래스로 String 클래스가 있다. 따라서 우리는 String 클래스를 상속할 수 없다. 또한 다음과 같이 메소드의 정의에 final 선언을 추가하여 해당 메소드의 오버라이딩을 허용하지 않을 수 도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>자바 5에서 ‘어노테이션(Annotations)’이라는 것이 소개되었다. 그리고 이와 관련하여 이후에 별도로 설명을 하겠다. 그러나 상속, 정확히는 메소드 오버라이딩과 관련 있는 내용이 있어 이에 대한 부분만 먼저 소개하고자 한다. 다음 예제를 보자. 이 예제는 컴파일도 되고 실행도 잘 된다. 그러나 프로그래머의 실수가 일부 포함되어 있다. 그 실수가 무엇인지찾아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideMistake</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ParentAdder adder = <span class="keyword">new</span> ChildAdder();</span><br><span class="line">System.out.println(adder.add(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 ChildAdder 는 ParentAdder를 상속한다. 그리고 ParentAdder의 add를 오버라이딩 할 의도였음을 주석을 통해 알 수 있다. 그러나 부모 메소드와 매개변수 타입과 반환형이 달랐기 때문이다. 이러한 유형의 실수는 매우 흔하다. 그럼에도 불구하고 발견이 쉽지 않기 때문에 치명적인 실수가 될 수 있다. 제일 좋은 것은 컴파일 과정에서 실수가 확인되는 것이다. 그러나 이 경우 문법적으로는 오류가 없기 때문에 컴파일도 되고 실행도 된다.</p><p>이러한 상황을 방지하기 위해서 ‘어노테이션’ 이라는 것을 사용할 수 있다. 어노테이션은 일종의 메모이다. 그것도 ‘자바 컴파일러에게 메시지를 전달하는 목적의 메모’이다. ChildAdder 클래스를 설계하는 과정에서 add 메소드가 ParentAdder의 add 메소드를 오버라이딩 할 의도였다면 다음과 같이 메모를 달아준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 어노테이션을 정의하면 컴파일러는 오버라이딩이 제대로 되었는지 확인을 하고, 프로그래머의 의도대로 오버라이딩이 되지 않았다면 컴파일 단계에서 에러를 전달해준다.</p><p>메소드를 오버라이딩 해야 한다면, 이렇듯 어노테이션을 사용하여 컴파일 과정에서 확인되지 않는 오류의 발생을 차단하는 것이 좋다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/java15-%EC%83%81%EC%86%8D04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 14. 상속 03</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/java14-%EC%83%81%EC%86%8D03/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/java14-%EC%83%81%EC%86%8D03/</guid>
      <pubDate>Mon, 27 Apr 2020 11:01:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;메소드-오버라이딩-Method-Overriding-이란&quot;&gt;&lt;a href=&quot;#메소드-오버라이딩-Method-Overriding-이란&quot; class=&quot;headerlink&quot; title=&quot;메소드 오버라이딩(Method Overriding)이란?&quot;&gt;&lt;/a&gt;메소드 오버라이딩(Method Overriding)이란?&lt;/h2&gt;&lt;p&gt;상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="메소드-오버라이딩-Method-Overriding-이란"><a href="#메소드-오버라이딩-Method-Overriding-이란" class="headerlink" title="메소드 오버라이딩(Method Overriding)이란?"></a>메소드 오버라이딩(Method Overriding)이란?</h2><p>상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다. <a id="more"></a></p><p>다음 예제를 통해 메소드 오버라이딩의 결과를 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;<span class="comment">// Cake의 Yummy 메소드를 오버라이딩 함</span></span><br><span class="line">System.out.println(<span class="string">"Yummy Cheese Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeOverriding</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line"></span><br><span class="line">c1.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">c2.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  실행 결과 : Yummy Cheese Cake가 두번 출력 되는 것을 알 수 있다.</p><p>위의 CheeseCake 클래스는 Cake를 상속하면서, Cake에 정의된 yummy메소드와 다음 세 가지가 같은 메소드를 정의하였다.</p><ul><li>메소드의 이름</li><li>메소드의 반환형</li><li>메소드의 매개변수 선언</li></ul><p>위의 세가지가 같아야 메소드 오버라이딩이 성립한다.</p><p>즉 Cake의 yummy 메소드를 CheeseCake의 Yummy 메소드가 오버라이딩 하였다. 그리고 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 오버라이딩된 메소드를 대신하게 된다. </p><p>위의 예제의 main 메소드에서 다음과 같이 Cake 형 참조변수로 CheeseCake 인스턴스를 참조하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();</span><br></pre></td></tr></table></figure><p>그리고 다음과 같이 yummy 메소드를 호출하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy();</span><br></pre></td></tr></table></figure><p>앞서 설명한 바에 의하면 c1은 Cake형 참조변수이니, 위 문장의 경우 Cake의 yummy 메소드가 호출되어야 한다. CheeseCake 인스턴스를 참조하고 있는 상황이라도 말이다. 그러나 Cake의 yummy 메소드는 오버라이딩 되었다(무효화 되었다). 따라서 이 경우에는 CheeseCake의 yummy 메소드가 대신 호출이 된다.</p><h2 id="메소드-오버라이딩의-일반화"><a href="#메소드-오버라이딩의-일반화" class="headerlink" title="메소드 오버라이딩의 일반화"></a>메소드 오버라이딩의 일반화</h2><p>앞서 설명한 메소드 오버라이딩을 문법적으로 정리하기 위해서 클래스를 다음과 같이 정의하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 클래스를 정의한 경우 CheeseCake의 참조변수와 인스턴스의 생성문을 다음과 같이 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">StrawberryCheeseCake c3 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br></pre></td></tr></table></figure><p>그리고 다음 세 문장이 실행되었을 때 호출되는 메소드는 StrawberryCheeseCake의 yummy 메소드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c2.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c3.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br></pre></td></tr></table></figure><h2 id="오버라이딩된-메소드를-호출하는-방법"><a href="#오버라이딩된-메소드를-호출하는-방법" class="headerlink" title="오버라이딩된 메소드를 호출하는 방법"></a>오버라이딩된 메소드를 호출하는 방법</h2><p>위의 예제들에서도 알 수 있듯이 Cake, CheeseCake에 정의된 yummy 메소드들을 위의 방법처럼 호출하는 것은 불가능하다.</p><p>하지만 클래스 외부가 아닌 내부에서 Cake의 yummy 메소드를 호출하는 방법은 있다. 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch11_상속;</span><br><span class="line"><span class="comment">//오버라이딩 된 메소드를 호출하는 방법 예제</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.yummy();</span><br><span class="line">System.out.println(<span class="string">"Yummy CheeseCake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CheeseCake cake = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">cake.yummy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 상위 클래스의 생성자를 호출할 목적으로 키워드 super를 사용하였다. 그런데 위의 예제에서 보이듯이 상위 클래스에 정의된, 오버라이딩 된 메소드의 호출을 목적으로도 super가 사용될 수 있다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/java14-%EC%83%81%EC%86%8D03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 13. 상속 02</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/java13-%EC%83%81%EC%86%8D02/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/java13-%EC%83%81%EC%86%8D02/</guid>
      <pubDate>Mon, 27 Apr 2020 10:41:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;상위-클래스의-참조변수가-참조할-수-있는-대상의-범위&quot;&gt;&lt;a href=&quot;#상위-클래스의-참조변수가-참조할-수-있는-대상의-범위&quot; class=&quot;headerlink&quot; title=&quot;상위 클래스의 참조변수가 참조할 수 있는 대상의 범위&quot;&gt;&lt;/a&gt;상위 클래스의 참조변수가 참조할 수 있는 대상의 범위&lt;/h2&gt;&lt;p&gt;이전 상속의 &lt;a href=&quot;https://github.com/gojaebeom/java_tutorial/blob/master/src/ch11_%EC%83%81%EC%86%8D/IS_A_%EC%98%88%EC%A0%9C.java&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;IS - A 예제&lt;/a&gt; 에서 SmartPhone 클래스가 MobilePhone 클래스를 상속하는 형태로 클래스를 디자인한 바 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="상위-클래스의-참조변수가-참조할-수-있는-대상의-범위"><a href="#상위-클래스의-참조변수가-참조할-수-있는-대상의-범위" class="headerlink" title="상위 클래스의 참조변수가 참조할 수 있는 대상의 범위"></a>상위 클래스의 참조변수가 참조할 수 있는 대상의 범위</h2><p>이전 상속의 <a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch11_%EC%83%81%EC%86%8D/IS_A_%EC%98%88%EC%A0%9C.java" rel="external nofollow noopener noreferrer" target="_blank">IS - A 예제</a> 에서 SmartPhone 클래스가 MobilePhone 클래스를 상속하는 형태로 클래스를 디자인한 바 있다. <a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>따라서 다음과 같이 문장을 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그런데 다음과 같이 MobilePhone형 참조변수가 SmartPhone 인스턴스를 참조하게 할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>이렇듯 상위 클래스의 참조변수는 하위 클래스의 인스턴스를 참조할 수 있는데, 이 부분을 다음과 같이 이해하자.</p><ul><li>모바일폰을 상속하는 스마트폰도 일종의 모바일폰이다.<ul><li>Mobilephone을 상속하는 SmartPhone 인스턴스는 MobilePhone 인스턴스이기도 하다.</li></ul></li><li>따라서 MobilePhone형 참조변수는 SmartPhone 인스턴스를 참조할 수 있다.</li></ul><p>다음과 같이 상속 관계가 형성이 되면,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>다음 인스턴스는 Smartphone 인스턴스인 동시에 MobilePhone 인스턴스가 된다.<br><br>(이는 스마트폰을 가리키며 모바일폰이다. 라고 말할 수 있는 것과 이치가 같다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SmartPhone(<span class="string">"010-555-666"</span>,<span class="string">"Nougat"</span>);</span><br><span class="line"><span class="comment">//스마트폰 인스턴스이면서 동시에 모바일폰 인스턴스</span></span><br></pre></td></tr></table></figure><br><p>따라서 위에 말한것처럼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><p>SmartPhone 인스턴스를 참조하는 변수를 선언하는 두 가지 방법이 가능하다.</p><h3 id="지금까지-설명한-것을-예제를-통해-알아보자"><a href="#지금까지-설명한-것을-예제를-통해-알아보자" class="headerlink" title="지금까지 설명한 것을 예제를 통해 알아보자"></a><em>지금까지 설명한 것을 예제를 통해 알아보자</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Overriding_Exam01.class </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String number;<span class="comment">// 전화번호</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MobilePhone</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number  = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hi ~ from "</span> + number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//모바일폰을 상속받는 하위클래스 스마트폰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String androidVer;<span class="comment">// 안드로이드 운영체제 네임(버전)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmartPhone</span><span class="params">(String number, String ver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(number);</span><br><span class="line"><span class="keyword">this</span>.androidVer = ver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"App is running in "</span> + androidVer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding_Exam01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SmartPhone ph1 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-111-222"</span>, <span class="string">"Andro01"</span>);</span><br><span class="line">MobilePhone ph2 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-444-333"</span>, <span class="string">"Andro02"</span>);</span><br><span class="line"></span><br><span class="line">ph1.answers();</span><br><span class="line">ph1.playApp();</span><br><span class="line"></span><br><span class="line">ph2.answers();</span><br><span class="line"><span class="comment">//ph2.playApp();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서는 다음과 같이 인스턴스를 생성하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그리고 다음과 같이 mobilePhone 클래스에 정의된 메소드를 호출하는데 이는 당연히 가능한 일이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br></pre></td></tr></table></figure><br><p>그러나 다음과 같이 SmartPhone 클래스에 정의된 메소드의 호출은 불가능하다. 참조변수 ph2가 실제 참조 하는 인스턴스가 SmartPhone 인스턴스이지만 불가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.playApp(); <span class="comment">// 스마트폰 클래스에서 정의한 메소드</span></span><br></pre></td></tr></table></figure><br><p>참조변수 ph2는 MobilePhone형 참조변수이다. 이러한 경우 ph2를 통해서 접근이 가능한 멤버는 MobilePhone 클래스에 정의되었거나 이 클래스가 상속하는 클래스의 멤버로 제한된다.(ph2가 참조하는 인스턴스가 무엇인지는 상관이 없다)</p><p>지금 설명한 이 내용이 비합리적이라고 생각할 수 있다. 참조변수의 형에 상관없이, 참조하는 인스턴스에 따라서 접근가능한 멤버가 결정되어야 한다고 생각할 수 있다. 그러나 그렇게 설계하지 않은 이유가 두 가지 있는데 그중 하나는 다음과 같다.</p><ul><li><em>실행 시간을 늦추는 결과로 이어질 수 있습니다</em></li></ul><p>자바는 메소드 호출 시 참조변수의 형을 참조 하여 그 메소드 호출이 옳은 것인지 판단한다.예를 들면 다음과 같다.(다음과 같이 컴파일러가 판단하고 컴파일을 한다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br><span class="line"><span class="comment">//ph2가 MobilePhone형이므로 MobilePhone 클래스의 메소드 answer은 호출가능하다.</span></span><br></pre></td></tr></table></figure><br><p>이러한 형태의 판단은 그 속도가 빠르다.(컴파일 단계에서 쉽게 판단 가능하다) 그러나 실제 참조하는 인스턴스를 대상으로 메소드의 호출 가능성을 판단하는 일은 간단하지 않다. 참조하는 인스턴스의 종류는 코드의 흐름에 따라 얼마든지 달라질 수 있기 때문이다.</p><p>그런데 이러한 단점도 감수할 만한 가치가 있다면 감수했을 것이다. 그러나 이어서 언급하는 두 번째 이유는 이러한 단점을 감수할 필요가 없다는 결론을 내리게 한다. </p><ul><li><em>참조변수의 타입을 기준으로 접근 가능한 멤버를 제한하는 것은 코드를 단순하게 한다.</em></li></ul><p>단점이 많은 일부 기능을 제한함으로써 단순하고 명료한 코드의 작성을 유도하는 언어가 좋은 언어이다. 그런 측면에서 참조변수의 타입을 기준으로 접근 가능한 멤버를 제한한 것은 의미가 있는 일이다.<br><br></p><h2 id="클래스의-상속과-참조변수의-참조-가능성"><a href="#클래스의-상속과-참조변수의-참조-가능성" class="headerlink" title="클래스의 상속과 참조변수의 참조 가능성"></a>클래스의 상속과 참조변수의 참조 가능성</h2><p>다음과 같이 상속 관계를 맺은 세 클래스가 존재한다고 가정하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sweet</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">milky</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sour</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이때 StrawberryCheeseCake 인스턴스는 다음과 같이 말할 수 있다.- _StrawberryCheeseCake 인스턴스는 CheeseCake 인스턴스이면서 Cake 인스턴스 이다._<p>따라서 다음과 같이 인스턴스를 참조할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cake cake1 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">CheeseCake cake2 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br></pre></td></tr></table></figure><br>그러나 Cake형 참조변수 cake1을 통해서 호출할 수 있는 메소드는 다음 한 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cake1.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>그리고 CheeseCake형 참조변수 cake2를 통해서 호출할 수 있는 메소드는 다음 두 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cake2.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br><span class="line">cake2.milky();</span><br><span class="line"><span class="comment">//CheeseCake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>이렇듯 참조변수가 참조하는 인스턴스의 종류에 상관없이, 참조변수의 타입에 해당하는 클래스와 그 클래스가 상속하는 상위 클래스에 정의된 메소드들만 호출이 가능하다.<blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/java13-%EC%83%81%EC%86%8D02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 12. 상속 01</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/java12-%EC%83%81%EC%86%8D01/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/java12-%EC%83%81%EC%86%8D01/</guid>
      <pubDate>Mon, 27 Apr 2020 10:27:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;상속의-기본문법-이해&quot;&gt;&lt;a href=&quot;#상속의-기본문법-이해&quot; class=&quot;headerlink&quot; title=&quot;상속의 기본문법 이해&quot;&gt;&lt;/a&gt;상속의 기본문법 이해&lt;/h2&gt;&lt;p&gt;상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상옥에 대한 문법적인 이해가 선행되어야 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="상속의-기본문법-이해"><a href="#상속의-기본문법-이해" class="headerlink" title="상속의 기본문법 이해"></a>상속의 기본문법 이해</h2><p>상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상옥에 대한 문법적인 이해가 선행되어야 한다. <a id="more"></a></p><h2 id="상속이란"><a href="#상속이란" class="headerlink" title="상속이란?"></a>상속이란?</h2><p>상속의 이유와 목적을 물어보면 </p><ul><li>상속은 코드의 재활용를 위한 문법입니다.</li></ul><p>그러나 이는 정확한 표현은 아니다.</p><ul><li>연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다.</li></ul><p>위의 답변은 매우 모범적인 답변이다.</p><h3 id="상속의-가장-기본적인-특성"><a href="#상속의-가장-기본적인-특성" class="headerlink" title="상속의 가장 기본적인 특성"></a>상속의 가장 기본적인 특성</h3><p>상속을 단순하게 설명하면 , 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것이 상속이다. 예를 들어서 다음의 클래스가 정의되어 있다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">Animal(String name)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"이 동물의 이름은 "</span>+name+<span class="string">"입니다."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 위의 클래스를 상속하여 다음과 같이 새로운 클래스를 정의 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String cry;</span><br><span class="line"></span><br><span class="line">Cat(String name , String cry)&#123;</span><br><span class="line"><span class="keyword">super</span>(name);<span class="comment">//부모의 String타입의 매개변수를 받는 생성자 호출(super는 이후에 배우게 된다.)</span></span><br><span class="line"><span class="keyword">this</span>.cry = cry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name();<span class="comment">//Animal 클래스를 상속했기 때문에 호출 가능</span></span><br><span class="line">System.out.println(<span class="string">"울음소리는 "</span>+cry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제를 보면 새로운 super 키워드가 등장한 것을 알 수 있다. 이건 나중에 더 자세히 다루어보겠다.</p><h2 id="클래스-변수와-클래스-메소드의-상속이-가능한가"><a href="#클래스-변수와-클래스-메소드의-상속이-가능한가" class="headerlink" title="클래스 변수와 클래스 메소드의 상속이 가능한가?"></a>클래스 변수와 클래스 메소드의 상속이 가능한가?</h2><p>static 선언이 붙는 클래스 변수와 클래스 메소드도 상속의 대상에 포함이 되겠는가?</p><p>static 선언이 갖는 의미를 떠올리고 논리적으로 접근을 하면 이 질문에 스스로 답을 할 수 있다.</p><p>앞서 공부한 클래스 변수와 클래스 메소드의 특징을 정리하면 다음과 같다. </p><ul><li>인스턴스의 생성과 상관없이 접근이 가능하다.</li><li>클래스 내부와 외부에서 접근이 가능하다.</li><li>클래스 변수와 클래스 메소드가 위치한 클래스 내에서는 직접 접근이 가능하다.</li></ul><p>즉 클래스 변수와 클래스 메소드는 인스턴스에 속하지 않는, 딱 하나만 존재하는 변수와 메소드이다. <strong>따라서 상속의 대상이 아니다.</strong></p><p>그렇다면 다음 내용에 대해서는 생각을 해볼 필요가 있다. </p><ul><li>상위 클래스에 위치한 클래스 변수와 메소드에 하위 클래스에서 어떻게 접근하는가?</li></ul><p>결론을 말하자면 변수의 이름만으로 접근이 가능하다. 단 접근 수준 지시자가 접근을 허용해야 접근이 가능하다. 다음 예제를 통해 알아보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperClass sc1 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line">SuperClass sc2 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line"></span><br><span class="line">SubClass sub1 = <span class="keyword">new</span> SubClass();<span class="comment">//인스턴스 생성 과정에서 부모생성자가 호출 되므로 count 값 1 증가</span></span><br><span class="line">sub1.showCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//protected는 하위 클래스 접근을 허용</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서 변수 count의 접근 수준 지시자를 private으로 선언하면 이로 인해 컴파일 오류가 발생하는 것도 확인하기 바란다.</p><h2 id="IS-A"><a href="#IS-A" class="headerlink" title="IS - A"></a>IS - A</h2><p>두 클래스를 상속의 관계로 맺는 것이 도움이 되는 상황이 있고 도움이 되지 않는 상황이 있다. 그렇다면 언제 두 클래스를 상속의 관계로 맺어야 할까? </p><p>기본적으로 IS-A 관계라는 것이 성립해야 상속의 후보로 고려할 수 있다.</p><p>상속이 갖는 문법적 특성을 통해서 상위 클래스와 하위 클래스를 다음과 같이 이야기할 수 있다.</p><ul><li>하위 클래스는 상위 클래스의 모든 특성을 지닌다. </li><li>거기에 더하여 하위 클래스는 자신만의 추가적인 특성을 더하게 된다.</li></ul><p>이러한 상속의 특성을 현실 세계에서도 찾아볼 수 있다. 대표적인 예가 다음과 같다.</p><ul><li>모바일폰 vs 스마트폰</li></ul><p>모바일폰이 상위 클래스라면 스마트폰은 하위 클래스이다. 즉 이 둘을 객체지향의 관점에서 보면 다음과 같이 이야기할 수 있다. </p><ul><li>모바일폰을 스마트폰이 상속한다.</li></ul><p>스마트폰은 모바일폰이 갖는 특성을 모두 갖는다. 게다가 스마트폰은 앱의 설치 및 실행 등 컴퓨터의 특성을 추가적으로 갖고 있다. 따라서 클래스를 설계한다면 다음과 같은 설계가 논리적으로 타당하다.</p><ul><li>class 스마트폰 extends 모바일폰 {…}</li></ul><p>그런데 우리는 스마트폰도 모바일폰의 한 종류라 말한다. 즉 컴퓨터의 기능이 추가된 모바일폰이 스마트 폰인 것이다. 따라서 다음과 같이 이야기할 수 있다. </p><ul><li>스마트폰도 모바일폰이다.</li><li>스마트폰은 일종의 모바일폰이다.</li></ul><p>그리고 위의 문장들이 나타나는 관계를 가리켜 IS-A 관계라 하고, 이것이 상속의 관계를 맺기 위한 두 클래스의 기본 조건이 된다. 참고로 is a는 ~은 ~ 이다. 로해석 된다. 예를 들면 다음과 같다.</p><ul><li>Life is a journey - 인생은 여행이다. </li></ul><p>지금까지 설명한 내용을 정리하면 다음과 같다.</p><h3 id="IS-A-관계-총-정리"><a href="#IS-A-관계-총-정리" class="headerlink" title="IS-A 관계 총 정리"></a>IS-A 관계 총 정리</h3><ul><li>IS - A 관계는 ~은 ~이다. 로 표현되는 관계이다. </li><li>상속이 갖는 문법적 특성은 IS - A 관계의 표현에 적합하다.</li><li>따라서 상속 관계를 형성하기 위한 두 클래스는 IS -A 관계에 있어야 한다.</li></ul><h3 id="IS-A-관계-예제"><a href="#IS-A-관계-예제" class="headerlink" title="IS-A 관계 예제"></a>IS-A 관계 예제</h3><p>관련된 예제를 github에 올려두었다.</p><ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch11_%EC%83%81%EC%86%8D/IS_A_%EC%98%88%EC%A0%9C.java" rel="external nofollow noopener noreferrer" target="_blank">IS - A 예제</a></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/java12-%EC%83%81%EC%86%8D01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 11. 배열</title>
      <link>http://gojaebeom.github.io/2020/04/27/java/java11-%EB%B0%B0%EC%97%B4/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/java/java11-%EB%B0%B0%EC%97%B4/</guid>
      <pubDate>Mon, 27 Apr 2020 10:16:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배열이란&quot;&gt;&lt;a href=&quot;#배열이란&quot; class=&quot;headerlink&quot; title=&quot;배열이란?&quot;&gt;&lt;/a&gt;배열이란?&lt;/h2&gt;&lt;p&gt;배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란?"></a>배열이란?</h2><p>배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다. <a id="more"></a></p><h3 id="1차원-배열"><a href="#1차원-배열" class="headerlink" title="1차원 배열"></a>1차원 배열</h3><p>1차원 배열은 다음과 같이 정의할 수 있다.</p><ul><li>타입이 같은 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간</li></ul><p>그런데 자바는 배열도 인스턴스로 처리한다. 즉 자바에서는 배열도 인스턴스 이다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//길이가 5인 int형 1차원 배열의 생성문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위 문장에서 등호를 기준으로 왼편, 오른편에 위치한 것은 각각 참조변수의 선언과 배열의 생성이다. </p><p>물론 다음과 같이 참조변수의 선언과 배열 인스턴스의 생성을 구분할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ref;</span><br><span class="line">    ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//물론 int형 말고도 다양한 자료형으로 배열을 생성할 수 있다.</span></span><br><span class="line">    <span class="keyword">double</span>[] db = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>];</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//각 배열에 대한 길이 </span></span><br><span class="line">    System.out.println(db.length);</span><br><span class="line">    System.out.println(f.length);</span><br><span class="line">    System.out.println(str.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 보면 각 배열의 인스턴스 변수 length에 접근하여 배열의 길이 정보를 출력하였다. 이렇듯 인스턴스 변수에 접근이 가능하다는 것은 배열이 인스턴스임을 보인는 결과이기도 하다.</p><h2 id="배열-저장과-참조"><a href="#배열-저장과-참조" class="headerlink" title="배열 저장과 참조"></a>배열 저장과 참조</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>위 선언된 배열 arr에 첫 번째 공간에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><br><p>이렇듯 배열 요소의 위치를 지정하는 인덱스 값은 0에서부터 시작한다. 따라서 배열 arr의 두번째 , 새 번째 요소에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">//2번째</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">//3번째</span></span><br></pre></td></tr></table></figure><br><p>배열에 저장된 값을 참조하는 방법도 이와 유사하다. 다음은 배열 arr의 모든 요소에 저장된 값을 더하는 방법을 보여준다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = arr[<span class="number">0</span>] + arr[<span class="number">1</span>] + arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><br><h2 id="배열의-생성과-초기화"><a href="#배열의-생성과-초기화" class="headerlink" title="배열의 생성과 초기화"></a>배열의 생성과 초기화</h2><p>배열도 변수와 마찬가지로 생성과 동시에 초기화가 가능하다. 기본적인 배열의 생성 방식은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>이 배열을 생성과 동시에 초기화하려면 초기화할 값들을 다음과 같이 중괄호를 이용해서 나열하면 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int[] arr2 = new int[3] &#123;1, 2, 3&#125;; //컴파일 오류 발생</span></span><br></pre></td></tr></table></figure><br><p>그런데 위의 문장에서는 초기화할 값들의 수를 통해 배열의 길이 정보를 계산할 수 있으므로, 이경우 배열의 길이 정보를 생략하도록 약속하였다. 즉 위의 문장은 다음과 같이 수정해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 통해 생성되는 배열의 길이는 3이다. 그리고 위의 문장은 다음과 같이 줄여서 표현할 수 도있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><h3 id="배열의-선언-두가지-방법"><a href="#배열의-선언-두가지-방법" class="headerlink" title="배열의 선언 두가지 방법"></a>배열의 선언 두가지 방법</h3><p>다음과 같이 배열을 생성하는 문장에서도 이 둘은 동일한 의미로 사용이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ar1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//조금 더 선호하는 방법</span></span><br><span class="line"><span class="keyword">int</span> ar2[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><h3 id="배열의-참조-값과-메소드"><a href="#배열의-참조-값과-메소드" class="headerlink" title="배열의 참조 값과 메소드"></a>배열의 참조 값과 메소드</h3><p>배열도 인스턴스이므로 메소드 호출 시 참조 값의 전달이 가능하다. 예를 들어 다음과 같이 배열의 참조 값을 인자로 전달할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(sumOfAry(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//물론 아래 메소드처럼 메소드 생성시 배열의 참조변수를 매개변수로 선언해야 한다.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfAry</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>이 과정에서 배열이 새로 생성되는 것은 아니다. 그저 배열 인스턴스를 참조할 수 있는 참조 값만 인자로 전달이 되고, 이 값을 매개변수로 받을 뿐이다. 그리고 다음과 같이 배열의 참조 값을 반환하는 메소드를 정의하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] reIntArr(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line">    <span class="keyword">return</span> arr;<span class="comment">//배열의 참조값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-메서드의-매개변수"><a href="#main-메서드의-매개변수" class="headerlink" title="main 메서드의 매개변수"></a>main 메서드의 매개변수</h2><p>지금까지 배열에 대해서 알아보았다. 그렇다면 main메소드의 매개변수 선언이 무엇을 의미하는지 알 수 있을 것이다.</p><p>매개변수로 String 배열의 참조변수가 선언되었다. 따라서 다음과 같이 main 메소드를 호출해야 한다. (main 메서드를 직접 호출한다는 가정하에 작성된 코드이다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String []&#123;<span class="string">"Coffee"</span>, <span class="string">"Milk"</span>, <span class="string">"Orange"</span>&#125;;</span><br><span class="line">main(arr);</span><br></pre></td></tr></table></figure><br><p>물론 코드상에서 main메소드를 위와 같이 직접 호출하지는 않는다. 게다가 우리가 main 메소드에 전달할 String 배열을 만들지도 않는다. </p><p>그렇다면 어떻게 String 배열이 만들어지고 또 main 메소드의 인자로 전달되는 것일까?</p><p>String 배열을 구성하는 것도 main 메소드를 호출하는 것도 가상머신에 의해 이뤄지는 일이다. 다만 String 배열을 구성할 문자열은 프로그램 사용자가 전달해야 한다. </p><p>예를 들어서 Simple.class 에 위치한 main 메소드를 다음과 같이 호출한다고 가정해보자. </p><ul><li>C:\JavaStudy&gt; java Simple</li></ul><p>그러면 String 배열이 다음과 같이 구성이 되어 main 메소드에 전달이 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;&#125;;</span><br></pre></td></tr></table></figure><br><p>즉 빈 String 배열이 생성되어 main 메소드의 호출이 이뤄진다. 반면 다음과 같이 실행을 하면, </p><ul><li>C:/JavaStudy&gt; java Simple Coffee Mile Orange</li></ul><p>즉 실행 명령문에 이어서 공백을 구분 기준으로 문자열을 입력하면, 이 내용을 대상으로 String 배열이 구성되고, 이 배열의 참조 값이 전달되면서 main 메소드가 호출이 된다. 그럼 이러한 내용의 확인을 위해 다음 예제를 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">        System.out.println(args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>Coffee, Mile, Orange가 뜨는 것을 볼 수 있을 것이다.(참고로 이클립스에선 javac , java 명령어를 알아서 처리해주기때문에 cmd를 활용하여 명령어를 직접 입력해보는 것이 좋다)</p><p>이 밖에 다차원 배열등이 있지만 설명하는 것보단 직접 해보는 것이 더 효율적인 것 같다.</p><ul><li>배열 관련 예제코드<ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C01.java" rel="external nofollow noopener noreferrer" target="_blank">예제 01</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C02.java" rel="external nofollow noopener noreferrer" target="_blank">예제 02</a></li></ul></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/java/java11-%EB%B0%B0%EC%97%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>기쿠지로의 여름 ost - Summer</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/</guid>
      <pubDate>Mon, 27 Apr 2020 10:05:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/5nn5Aq6l020&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/5nn5Aq6l020" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-summer/#disqus_thread</comments>
    </item>
    
    <item>
      <title>말할 수 없는 비밀 - 쇼팽왈츠(편곡)</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/</guid>
      <pubDate>Mon, 27 Apr 2020 10:00:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/kRUhsCcztkQ&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/kRUhsCcztkQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>fate stay night - 운명의 밤</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/</guid>
      <pubDate>Sun, 26 Apr 2020 15:42:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/pYz-v4Z9TZs&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/pYz-v4Z9TZs" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>짱구는 못말려 - 히로시의 회상</title>
      <link>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/</link>
      <guid>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/</guid>
      <pubDate>Sun, 26 Apr 2020 15:42:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/Zi4YF__iYCM&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/Zi4YF__iYCM" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 10. this 키워드</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java10-this%20%ED%82%A4%EC%9B%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java10-this%20%ED%82%A4%EC%9B%8C%EB%93%9C/</guid>
      <pubDate>Sun, 26 Apr 2020 07:38:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;this의-의미&quot;&gt;&lt;a href=&quot;#this의-의미&quot; class=&quot;headerlink&quot; title=&quot;this의 의미&quot;&gt;&lt;/a&gt;this의 의미&lt;/h2&gt;&lt;p&gt;자바에서 제공하는 this 키워드는 인스턴스 자기 자신를 가리키는 키워드이다. 이 this 키워드를 통해 클래스 메서드 및 생성자에서 자기 자신의 데이터를 업데이트하거나 조작할 수 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="this의-의미"><a href="#this의-의미" class="headerlink" title="this의 의미"></a>this의 의미</h2><p>자바에서 제공하는 this 키워드는 인스턴스 자기 자신를 가리키는 키워드이다. 이 this 키워드를 통해 클래스 메서드 및 생성자에서 자기 자신의 데이터를 업데이트하거나 조작할 수 있다.<a id="more"></a></p><h2 id="this를-이용한-생성자-호출"><a href="#this를-이용한-생성자-호출" class="headerlink" title="this를 이용한 생성자 호출"></a>this를 이용한 생성자 호출</h2><p>this를 이용하여 생성자를 호출하는 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">this</span>를<span class="title">_</span>이용한<span class="title">_</span>생성자호출 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">"생성자 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)&#123;</span><br><span class="line">System.out.println(<span class="string">"생성자 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> num)&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"생성자 3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제를 보면 this 키워드를 이용하여 다른 생성자를 호출하고있다. 정수를 하나 받는 인스턴트를 새로 호출하자, 생성자2, 생성자3 이 콘솔에 출력된다. </p><p>생성자 3이 사용이 되었는데 생성자 3에서는 this(3, 4) 라는 키워드가 먼저 작성되어있다.<br>여기서 this는 오버로딩된 다른 생성자를 의미한다. 거기에 정수를 두개 받는 생성자를 찾기때문에 생성자 2가 먼저 호출이 되고 그다음 출력문을 만나 생성자 3이 콘솔에 찍히게 된다.</p><h2 id="this-인스턴수-변수-접근"><a href="#this-인스턴수-변수-접근" class="headerlink" title="this - 인스턴수 변수 접근"></a>this - 인스턴수 변수 접근</h2><p>앞서 키워드 this를 이용한 생성자의 호출에 대해 설명했는데, this는 다른 의미로도 사용이 된다. 이와 관련하여 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">this_</span>인스턴스변수<span class="title">_</span>접근 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 매개변수의 이름이 인스턴스 변수의 이름과 동일하게 선언된 경우, 선언된 지역 내에서의 해당 이름은 매개변수를 의미하게 된다.<br>하지만 키워드 this를 이용하면 이 영역 안에서도 인스턴스 변수에 접근할 수 있다. </p><p>즉 this.name에서 this가 의미하는 것은 ‘이 문장이 속한 인스턴스’ 이다. 따라서 this.name은 인스턴스 변수 name을 의미하는 것이 된다. </p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java10-this%20%ED%82%A4%EC%9B%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 09. 메소드 오버로딩(Overloading)</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java09-%EB%A9%94%EC%86%8C%EB%93%9C%20%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java09-%EB%A9%94%EC%86%8C%EB%93%9C%20%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/</guid>
      <pubDate>Sun, 26 Apr 2020 07:35:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;오버로딩-overloading&quot;&gt;&lt;a href=&quot;#오버로딩-overloading&quot; class=&quot;headerlink&quot; title=&quot;오버로딩(overloading)&quot;&gt;&lt;/a&gt;오버로딩(overloading)&lt;/h2&gt;&lt;p&gt;한 클래스 내에 동일한 이름의 메소드를 둘 이상 정의한느 것은 허용되지 않는다. 그러나 매개변수의 선언이 다르면 가능하다. 그리고 이것을 메소드 오버로딩이라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="오버로딩-overloading"><a href="#오버로딩-overloading" class="headerlink" title="오버로딩(overloading)"></a>오버로딩(overloading)</h2><p>한 클래스 내에 동일한 이름의 메소드를 둘 이상 정의한느 것은 허용되지 않는다. 그러나 매개변수의 선언이 다르면 가능하다. 그리고 이것을 메소드 오버로딩이라 한다.<a id="more"></a></p><p>메소드 오버로딩의 조건</p><ul><li>메소드의 이름</li><li>메소드의 매개변수 정보</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 메소드<span class="title">_</span>오버로딩 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exMethod</span><span class="params">(<span class="keyword">int</span> num1)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exMethod</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exMethod</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제를 보면 알 수 있듯이 메소드의 이름이 같지만 오류를 일으키지 않고 선언이 가능하다.</p><ul><li>첫번째 메소드는 매개변수가 없다.</li><li>두번째 메소드는 매개변수를 한개 받는다</li><li>세번째 메소드는 매개변수를 두개 받는다.(물론 그 이상도 가능하다.)</li><li>네번째 메소드는 두 번째와 같이 매개변수를 하나 받지만 매개변수의 형이 String으로 2번째인 int형과 다르기 때문에 가능하다. 즉 매소드의 매개변수가 타입과, 받는 개수가 다르다면 오버로딩이 성립한다.</li></ul><p>하지만 다음과 같은 애매한 상황이 있다. 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"메소드 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">double</span> p2)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"메소드 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Example ex = <span class="keyword">new</span> Example();</span><br><span class="line">ex.simple(<span class="number">1</span>, <span class="string">'K'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 메소드 호출은 애매하다. 이유는 메소드의 인자 전달 과정에서 발생하는 형 변환 때문이다. 사실 위의 Example 클래스에는 정수와 ‘문자’를 인자로 전달받는 simple 메소드가 정의되어 있지 않다. 때문에 자동 형 변환 규칙을 적용하여 호출할 메소드를 찾게 된다. </p><p>그런데 문제는 클래스에 정의된 두 simple 메소드 모두 형 변환 규칙을 적용했을 때 호출이 가능하다는데 있다. 그래서 위의 메소드 호출문은 애매하다고 하는 것이 좋다. 결론을 말하자면 이러한 상황에서는 자동 형 변환 규칙을 적용하되 가장 가까운 위치에 놓여있는 자료형으로의 형 변환을 우선 시도한다. 때문에 위의 메소드 호출문에 의해 int형 정수 두개를 받는 simple 메소드가 실행된다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java09-%EB%A9%94%EC%86%8C%EB%93%9C%20%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 08. 클래스 메소드</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/</guid>
      <pubDate>Sun, 26 Apr 2020 07:09:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;클래스-메소드-static-메소드&quot;&gt;&lt;a href=&quot;#클래스-메소드-static-메소드&quot; class=&quot;headerlink&quot; title=&quot;클래스 메소드(static 메소드)&quot;&gt;&lt;/a&gt;클래스 메소드(static 메소드)&lt;/h2&gt;&lt;p&gt;클래스 내에 정의된 메소드에 static 선언을 하면 ‘클래스 메소드’가 된다. 그리고 클래스 메소드는 그 성격이 클래스 변수와 유사하다.&lt;br&gt;접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 클래스 변수와 동일하다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스-메소드-static-메소드"><a href="#클래스-메소드-static-메소드" class="headerlink" title="클래스 메소드(static 메소드)"></a>클래스 메소드(static 메소드)</h2><p>클래스 내에 정의된 메소드에 static 선언을 하면 ‘클래스 메소드’가 된다. 그리고 클래스 메소드는 그 성격이 클래스 변수와 유사하다.<br>접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 클래스 변수와 동일하다.<a id="more"></a></p><h3 id="클래스-메소드의-정의와-호출"><a href="#클래스-메소드의-정의와-호출" class="headerlink" title="클래스 메소드의 정의와 호출"></a>클래스 메소드의 정의와 호출</h3><p>이전 글에서 공부한 클래스 변수의 특성 두 가지는 다음과 같다.</p><ul><li>인스턴스 생성 이전부터 접근이 가능하다.</li><li>어느 인스턴스에도 속하지 않는다.</li></ul><p>이 두 가지는 클래스 메소드도 동일하게 갖는 특성이다. 따라서 이 사실을 다음 예제를 통해서 확인해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스메소드<span class="title">_</span>정의 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NumberPrinter.showInt(<span class="number">50</span>);<span class="comment">// 클래스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 사실 위의 문장만 보더라도 클래스 메소드가 어느 인스턴스에도 속하지 않는다는 사실을 알 수 있다.</span></span><br><span class="line"><span class="comment"> * 인스턴스 생성 이전에 호출이 되었기 때문이다. </span></span><br><span class="line"><span class="comment"> * 그리고 예제의 주석에서 설명하고 있듯이 클래스의 내부와 외부에서 클래스 메소드를 호출하는 방법은</span></span><br><span class="line"><span class="comment"> * 클래스 변수에 접근하는 방법과 차이가 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">NumberPrinter np = <span class="keyword">new</span> NumberPrinter();</span><br><span class="line">np.showDouble(<span class="number">3.15</span>); <span class="comment">// 인스턴스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"></span><br><span class="line">np.setMyNumber(<span class="number">30</span>);</span><br><span class="line">np.showMyNumber();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> myNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//클래스 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDouble</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;<span class="comment">//클래스 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">myNum = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyNumber</span><span class="params">()</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">showInt(myNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 질문에 답해보자. </p><ul><li>클래스 메소드에서 같은 클래스에 선언된 인스턴스 변수에 접근이 가능한가?</li></ul><p>이는 다음과 같은 코드의 작성이 가능한지를 묻는 질문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스메소드<span class="title">_</span>심화 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int num =0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void addNum(int n) &#123;</span></span><br><span class="line"><span class="comment">//num = n;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 문장에 주석을 풀면 에러가 난다. 논리적으로 생각을 하면 위와 같은 문장 구성이 불가능하다는 것을 알 수 있다.</p><p>인스턴스 변수는 인스턴스에 속한다. 더불어 인스턴스가 생성이 되어야 메모리 공간에 존재하게 된다. 반면 클래스 메소드는 인스턴스 생성 이전부터 호출이 가능하다. 따라서 위 질문에 대해서 다음과 같이 대답할 수 있다.</p><ul><li>클래스 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수에 접근이 불가능하다.</li><li>같은 이유로 클래스 메소드는 인스턴스 메소드의 호출도 불가능하다.</li></ul><p>그러나 클래스 메소드 같은 클래스에 정의되어 있는 다른 클래스 메소드나 성격이 동일한 클래스 변수에는 접근이 가능하다.(당연한 얘기지만..)</p><h2 id="System-out-println-그리고-main-메소드"><a href="#System-out-println-그리고-main-메소드" class="headerlink" title="System.out.println 그리고 main 메소드"></a>System.out.println 그리고 main 메소드</h2><p>지금까지 main 메소드를 정의할 때 그 앞에 static 선언을 붙여왔다. 그리고 인스턴스의 생성 없이 println 메소드를 호출해 왔다.</p><h3 id="System-out-println-에서-out과-println의-정체는"><a href="#System-out-println-에서-out과-println의-정체는" class="headerlink" title="System.out.println()에서 out과 println의 정체는?"></a>System.out.println()에서 out과 println의 정체는?</h3><p>static 선언의 의미를 알았으니 sysout의 구성을 이해할 수 있다. 일단 System은 자바에서 제공하는 클래스로 java.lang 패키지에 묶여있다.  따라서 원칙적으로는 다음과 같이 호출해야 한다.</p><ul><li>java.lang.System.out.println(…);</li></ul><p>그러나 컴파일러가 다음 문장은 삽입 해주기때문에 패키지의 이름부분은 생략할 수 있다. </p><ul><li>import java.lang.*;</li></ul><p>그리고 out은 System.out으로 접근을 하니, 이는 분명 static으로 선언된 클래스 변수가 분명하다.<br>클래스의 이름을 통해 접근하니 말이다.<br>실제로 out은 System 클래스 내에 다음과 같이 선언된 클래스 변수이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out; <span class="comment">//참조변수</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 println은 PrintStream 클래스의 인스턴스 메소드이다. 따라서 다음 문장을 보면서,</p><ul><li>System.out.println(…);</li></ul><p>다음과 같이 이해 할 수 있어야 한다.</p><ul><li>System에 위치한 클래스 변수 out이 참조하는 인스턴스의 println 메소드를 호출하는 문장</li></ul><h3 id="main-메소드가-public-이고-static인-이유에-대해서-알아보자"><a href="#main-메소드가-public-이고-static인-이유에-대해서-알아보자" class="headerlink" title="main 메소드가 public 이고 static인 이유에 대해서 알아보자."></a>main 메소드가 public 이고 static인 이유에 대해서 알아보자.</h3><p>main 메소드는 반드시 다음의 모양새를 갖춰야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 main 메소드는 public 으로 그리고 static으로 선언해야 한다. 이는 일종의 약속이다. </p><p>main메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당함을 알 수 있다. 그리고 main메소드는 인스턴스가 생성되기 이전에 호출된다. 따라서 static 선언하는 것이 옳음을 알 수 있다.</p><p>다음의 예제를 보자. Car클래스와 Boat 클래스를 정의 하였다. 다음의 main 메소드가 호출이 되어 실제 실행이 되게 하려고 한다면 어떤 클래스에 두어야 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"밴츠"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBoat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보트"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 메소드는 static 메소드이기 때문에, 즉 특정 인스턴스의 맴버로 존재하는 메소드가 아니기 때문에 정답은 어디든 상관은 없다. (물론 실행방식에선 차이가 발생한다. Car클래스에 두었으면 java Car 를 호출, Boat면 java Boat 호출)</p><p>그렇다면 Car클래스에 두었다고 가정해보자. main 메소드를 Car 클래스 내에 위치시켰는데 그 안에서 Car 인스턴스를 생성하고 있다. 혹시 이부분이 조금 난해하게 느껴지는가? 그렇다면 다음과 같이 생각하자.</p><ul><li>Car클래스와 static으로 선언된 main메소드는 사실상 별개다.</li><li>다만 Car 클래스가 main 메소드에게 공간을 제공했을 뿐이다. </li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 07. 클래스 변수</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/</guid>
      <pubDate>Sun, 26 Apr 2020 06:43:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;클래스-변수-static-변수&quot;&gt;&lt;a href=&quot;#클래스-변수-static-변수&quot; class=&quot;headerlink&quot; title=&quot;클래스 변수(static 변수)&quot;&gt;&lt;/a&gt;클래스 변수(static 변수)&lt;/h2&gt;&lt;p&gt;인스턴스 변수는 인스턴스가 생성되었을 때, 생성된 인스턴스 안에 존재하는 변수이다. 그러나 클래스 변수는 인스턴스의 생성과 상관없이 존재하는 변수이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스-변수-static-변수"><a href="#클래스-변수-static-변수" class="headerlink" title="클래스 변수(static 변수)"></a>클래스 변수(static 변수)</h2><p>인스턴스 변수는 인스턴스가 생성되었을 때, 생성된 인스턴스 안에 존재하는 변수이다. 그러나 클래스 변수는 인스턴스의 생성과 상관없이 존재하는 변수이다. <a id="more"></a></p><p>클래스 내에 선언된 변수 앞에 static 키워드를 붙이면 이는 인스턴스 변수가 아닌 클래스 변수가 된다. 이러한 클래스 변수의 특성을 파악하기 위해서 다음 예제를 관찰하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> instNum = <span class="number">0</span>;<span class="comment">// 클래스변수 (static 변수)</span></span><br><span class="line"></span><br><span class="line">InstCnt()&#123;<span class="comment">//생성자</span></span><br><span class="line">instNum++; <span class="comment">//static으로 선언된 변수의 값 증가</span></span><br><span class="line">System.out.println(<span class="string">"인스턴스 생성:"</span>+instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Static</span>변수<span class="title">_</span>선언 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InstCnt cnt1 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">InstCnt cnt2 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">InstCnt cnt3 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 InstCount의 생성자에서 static으로 선언된 변수 instNum의 값을 하나 증가시킨  다음에 그 결과를 출력하고 있다. 그런데 출력 결과를 보면 그 값이 인스턴스 생성 시마다 1씩 증가함을 알 수 있다. 그리고 이를 통해 다음 사실을 알 수 있다.</p><ul><li>static으로 선언된 변수는 변수가 선언된 클래스의 모든 인스턴스가 공유하는 변수이다. </li></ul><p>클래스 변수는 인스턴스 내에 존재하는 변수가 아니라 ‘어떠한 인스턴스에도 속하지 않는 상태로 메모리 공간에 딱 하나만 존재하는 변수’ 이다. 다만 이 변수가 선언된 클래스의 인스턴스들은 이 변수에 바로 접근할 수 있는 권한이 있을 뿐 이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote><h2 id="클래스-변수-접근-방법"><a href="#클래스-변수-접근-방법" class="headerlink" title="클래스 변수 접근 방법"></a>클래스 변수 접근 방법</h2><p>클래스 변수도 ‘접근 수준 지시자’ 의 규칙을 그대로 적용받기 때문에 public으로 선언되면 어디서든 접근이 가능하다. 물론 접근 방법에 있어서는 차이를 보이는데 이와 관련된 내용은 이어서 설명하겠다.</p><p>클래스 변수에 접근하는 방법은 접근 영역을 기준으로 다음과 같이 크게 두 가지로 나뉜다.</p><ul><li>클래스 내부 접근 : 변수의 이름을 통해 직접 접근</li><li>클래스 외부 접근 : 클래스 또는 인스턴스의 이름을 통해 접근</li></ul><p>다음예제를 보면서 클래스 변수의 접근 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessWay</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AccessWay()&#123;</span><br><span class="line">incrCnt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++; <span class="comment">//클래스 내부에서 이름을 통한 접근</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example01</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AccessWay way = <span class="keyword">new</span> AccessWay();</span><br><span class="line">way.num++; <span class="comment">//외부에서 인스턴스의 이름을 통한 접근</span></span><br><span class="line">AccessWay.num++; <span class="comment">//외부에서 클래스의 이름을 통한 접근</span></span><br><span class="line">System.out.println(<span class="string">"num = "</span> + AccessWay.num);<span class="comment">// 총 3이 찍힌다.</span></span><br><span class="line"></span><br><span class="line">AccessWay way2 = <span class="keyword">new</span> AccessWay();<span class="comment">//way2라는 새로운 AccessWay의 인스턴스를 생성하였다.</span></span><br><span class="line">System.out.println(way2.num);<span class="comment">//그리고 way2의 클래스변수 num을 조회 하였는데 값은 4가 찍힌다.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인스턴스의 이름을 통한 접근 방법을 보면서, 클래스 변수를 인스턴스 내부에 위치한 것으로 오해하면 안된다. 그리고 클래스 변수 num은 default로 선언되었다. 따라서 클래스 내부는 물론 클래스 외부이더라도 동일 패키지로 묶여 있으면 접근이 가능하다.</p><h2 id="클래스-변수의-초기화"><a href="#클래스-변수의-초기화" class="headerlink" title="클래스 변수의 초기화"></a>클래스 변수의 초기화</h2><p>클래스 변수는 인스턴스의 생성과 상관이 없다고 하였다. 그렇다면 클래스 변수는 언제 메모리 공간에 할당되고 초기화될까? 이와 관련하여 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> instNum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">InstCnt()&#123;</span><br><span class="line">instNum++;</span><br><span class="line">System.out.println(<span class="string">"인스턴스 생성: "</span>+instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스변수<span class="title">_</span>초기화 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InstCnt.instNum -=<span class="number">15</span>; <span class="comment">//인스턴스 생성 없이 instNum에 접근</span></span><br><span class="line">System.out.println(InstCnt02.instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제를 통해서 언급하고 싶은 내용은 다음과 같다.</p><ul><li>클래스 변수는 인스턴스 생성 이전에 메모리 공간에 존재한다.</li></ul><p>결론을 말하면, 클래스 변수는 해당 클래스 정보가 가상머신에 의해 읽히는 순간 메모리 공간에 할당되고 초기화 된다. 그리고 한 가지 확실한 것은 이러한 할당과 초기화는 위의 예제에서 보이듯이 인스턴스의 생성과 문관하게 이뤄진다는 점이다. 따라서 다음과 같이 생성자를 통한 클래스 변수의 초기화를 진행하지 않도록 주의해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> instNum =<span class="number">100</span>; <span class="comment">//클래스 변수의 정상적인 초기화 방법</span></span><br><span class="line"> </span><br><span class="line"> InstCnt()&#123;</span><br><span class="line"> instNum = <span class="number">0</span>;<span class="comment">// 클래스 변수의 초기화가 아니다!</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 변수 instNum 은 100으로 초기화 된다. 클래스 정보가 가상머신에 의해 읽히는 순간 100으로 초기화된다. 그런데 생성자에서 변수 instNum을 0으로 다시 초기화 한다. 따라서 인스턴스가 생성될 때마다 instNum은 매번 그 값이 0으로 바뀌게 된다.</p><h3 id="클래스로딩"><a href="#클래스로딩" class="headerlink" title="클래스로딩"></a>클래스로딩</h3><p>앞서 설명에서 클래스 정보를 가상머신이 읽는다 는 표현을 썼는데, 이렇듯 가상머신이 특정 클래스 정보를 읽는 행위를 가리켜 클래스 로딩 이라 한다. 그리고 특정 클래스의 인스턴스 생성을 위해서는 해당 클래스가 반드시 가상머신에 의해 로딩되어야 한다. 즉 인스턴스 생성보다 클래스 로딩이 먼저이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 06. 정보은닉과 캡슐화</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/</guid>
      <pubDate>Sun, 26 Apr 2020 05:55:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;정보은닉&quot;&gt;&lt;a href=&quot;#정보은닉&quot; class=&quot;headerlink&quot; title=&quot;정보은닉&quot;&gt;&lt;/a&gt;정보은닉&lt;/h2&gt;&lt;p&gt;자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 다음 예제를 다루어보면서 정보은닉이 필요한 이유에 대해서 알아보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="정보은닉"><a href="#정보은닉" class="headerlink" title="정보은닉"></a>정보은닉</h2><p>자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 다음 예제를 다루어보면서 정보은닉이 필요한 이유에 대해서 알아보자.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 정보은닉<span class="title">_</span>예제</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle c = <span class="keyword">new</span> Circle(<span class="number">1.5</span>);</span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">        c.setRad(<span class="number">2.5</span>);</span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">        c.radius = <span class="number">5</span>;<span class="comment">//옳지 않은 접근 방법, 그리고 문제가 되는 부분</span></span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//원의 너비를 구하는 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;<span class="comment">//원의 반지름</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;<span class="comment">//원주율</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        setRad(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRad</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) &#123;<span class="comment">//반지름은 0보다 작을 수 없으므로</span></span><br><span class="line">            radius = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//아무것도 반환하지 않고 메소드에서 빠저나간다.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (radius * radius) * PI;<span class="comment">//원의 너비 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제 18, 19번째 줄에서 보이듯이 인스턴스 변수는 선언과 동시에 초기화를 할 수 있다. 특히 PI의 경우 그 값이 상수이므로 생성자를 통한 초기화보다 위의 방식의 초기화가 더 어울린다. </p><p>그렇다면 25번째 줄의 setRad 메소드를 보자. 위 메소드 정의를 통해서 Circle 클래스를 정의한 이의 다음 의도를 읽을 수 있다.</p><ul><li>반지름의 길이 radius에 0 보다 작은 값이 저장되는 일이 발생하지 않도록 하겠다.</li></ul><p>때문에 이러한 의도를 따르기 위해서라도 반지름의 길이를 변경할 때에는 반드시 위의 메소드 호출을 통해서만 변경을 진행해야 한다. 이렇듯 인스턴스 변수에 저장되는 값의 종류와 범위는 해당 클래스를 정의한 사람이 가장 정확히 안다. 따라서 클래스 사용자가 잘못된 값을 인스턴스 변수에 저장하지 않도록 위와 같은 유형의 메소드를 제공해야한다. 그런데 위의 예제에서는 프로그램 사용자의 실수로 다음과 같은 잘못된 접근이 발생하였다.</p><ul><li>10번째 줄의 c.radius = 5;</li></ul><p>이렇듯 인스턴스 변수의 직접적인 접근을 허용하면, 컴파일 과정에서 드러나지 않는 중대한 실수가 발생할 수 있다. 이러한 오류는 실행 결과에서도 드러나지 않아 더 큰 문제가 된다. 때문에 위와 같은 접근을 허용하지 않도록 클래스를 설계할 필요가 있다. 그리고 이러한 클래스의 설계를 가리켜 ‘정보 은닉’ 이라 한다.</p><h2 id="Getter-와-Setter"><a href="#Getter-와-Setter" class="headerlink" title="Getter 와 Setter"></a>Getter 와 Setter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Getter</span>와<span class="title">Setter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 이전에서 만든 클래스를 '정보 은닉'의 조건을 충족하게 다시 만들어보자. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Circle02 c = <span class="keyword">new</span> Circle02(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"반지름: "</span> + c.getRadius());</span><br><span class="line">System.out.println(<span class="string">"넓 이:"</span> + c.getArea());</span><br><span class="line"></span><br><span class="line">c.setRadius(<span class="number">3.5</span>);</span><br><span class="line">System.out.println(<span class="string">"반지름: "</span> + c.getRadius());</span><br><span class="line">System.out.println(<span class="string">"넓 이:"</span> + c.getArea());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle02</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle02</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">setRadius(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">radius = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">radius = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (radius*radius)*PI;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이전과 다른점들을 살펴보자. 일단 21, 22 번줄의 인스턴스 변수의 선언 앞에 private라는 접근 수준 지시자(접근제한자가 붙어있다.) 그리고 이것이 의미하는 바는 다음과 같다.<ul><li>클래스 내부에서만 접근을 허용하겠다.</li></ul><p>따라서 클래스 외부에서 prviate으로 선언된 변수에 접근할 경우 컴파일 오류가 발생한다. 그렇다면 저 변수를 어떻게 사용해야 할까?</p><p>자바에서는 상태는 외부로부터 숨기고 오직 동작(메소드)를 통해서만 상태를 제어할 수 있는 방식을 권장하고 있다. 따라서 위의 두 유형의 메소드를 통해 값을 설정하고, 전달하는 일을 할 수있다.</p><p>상단의 setRadius는 값의 설정을 위한 메소드이고, 메소드 getRadius는 값의 참조를 위한 메소드이다. 이렇듯 값의 설정과 참조를 위한 메소드를 가리켜 각각 다음과 같이 부른다. </p><ul><li><p>getter</p><ul><li>인스턴스 변수의 값을 참조하는 용도로 정의된 메소드</li><li>변수의 이름이 name일 때, 메소드의 이름은 getName으로 짓는 것이 관계</li></ul></li><li><p>setter</p><ul><li>인스턴스 변수의 값을 설정하는 용도로 정의된 메소드</li><li>변수의 이름이 name일 때 , 메소드의 이름은 setName으로 짓는 것이 관례</li></ul></li></ul><p>private으로 선언된 모든 인스턴스 변수를 대상으로 게터와세터를 반드시 정의해야 하는 것은 아니다. 필요에 따라 정의하면 된다. 그러나 당장 필요하지 않더라도 나중을 고려하여 게터와 세터를 정의하기도 한다.</p><h2 id="접근-수준-지시자"><a href="#접근-수준-지시자" class="headerlink" title="접근 수준 지시자"></a>접근 수준 지시자</h2><p>앞의 예제에서 인스턴스 변수를 대상으로 private 선언을 하였는데, 이러한 유형의 키워드를 가리켜 ‘접근 수준 지시자 (Access-level Modifiers)’ 라 한다. 또는 ‘접근 제한자’ 라고도 한다. 이름 그대로 접근의 허용 수준을 결정할 때 선언하는 키워드이다.</p><p>접근제한자의 종류는 다음과 같이 4가지 이다.</p><ul><li>public, protected, private, default</li></ul><p>이중에서 default는 키워드가 아닌, 아무런 선언도 하지 않은 상황을 의미한다. 비록 이는 키워드가 아닌 일종의 상황이지만 이 역시 접근 제한자의 한 종류로 구분을 한다. </p><p>그리고 이러한 선언을 할 수 있는 대상은 다음 두 가지이다.</p><ul><li>클래스의 정의</li><li>클래스의 인스턴스 변수와 메소드</li></ul><p>클래스의 정의를 대상으로는 다음 두 가지 선언이 가능하다.</p><ul><li>클래스 정의대상 : public ,default</li></ul><p>그리고 인스턴스 변수와 메소드를 대상으로는 다음 네 가지 선언이 모두 가능하다.</p><ul><li>public, protected, private, default</li></ul><p>그럼 이제 각각의 기능을 알아보자. </p><h3 id="클래스-정의-대상의-public-과-default-선언이-갖는-의미"><a href="#클래스-정의-대상의-public-과-default-선언이-갖는-의미" class="headerlink" title="클래스 정의 대상의 public 과 default 선언이 갖는 의미"></a>클래스 정의 대상의 public 과 default 선언이 갖는 의미</h3><ul><li>public : 어디서든 인스턴스(객체) 생성이 가능하다. </li><li>default : 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용한다.</li></ul><h3 id="인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미"><a href="#인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미" class="headerlink" title="인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미"></a>인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미</h3><table><thead><tr><th>접근제한자</th><th>클래스 내부</th><th align="right">동일 패키지</th><th align="center">상속 받은 클래스</th><th align="right">이외의 영역</th></tr></thead><tbody><tr><td>private</td><td>o</td><td align="right">x</td><td align="center">x</td><td align="right">x</td></tr><tr><td>default</td><td>o</td><td align="right">o</td><td align="center">x</td><td align="right">x</td></tr><tr><td>protected</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">x</td></tr><tr><td>public</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">o</td></tr></tbody></table><p>위의 표에서 말하는 이외의 영역은 다른 패키지에 속한 클래스를 뜻한다. 즉 서로 다른 패키지에 속한 두 클래스 사이의 접근을 의미한다. 그리고 위 표의 내용을 기준으로 접근 허용 범위에 대하여 다음과 같이 이해하고 있는 것도 도움이 된다. </p><ul><li>public &gt;  protected &gt; default &gt; private</li></ul><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>캡슐화는 정보 은닉과 더불어 객체지향 기반의 클래스 설계에 있어 가장 기본이면서 중요한 원칙 중 하나이다. 캡슐화는 문법적인 내용은 아니다. 클래스 안에 ‘무엇을 넣을까’ 에 대한 이론을 제시한는 내용이다.</p><p>캡슐화를 다음과 같이 정의할 수 있다. </p><ul><li>하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 캡슐에 담아 두는 것</li></ul><p>물론 객체지향 관점에서 위의 캡슐은 클래스에 해당한다. 즉 위의 문장은 다음과 같이 다시 쓸 수 있다.</p><ul><li>하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 클래스에 담아 두는 것</li></ul><p>무조건 많이 담는다고 해서 캡슐화가 아니다. 부족해도 안되고 넘쳐도 문제가 된다. 그리고 상황 및 목적에 따라서 동일한 이름의 클래스에도 담기는 내용이 달라진다. 캡슐화에 대한 예제들은 github 에 올려두었던 다음 예제들을 참고하면 괜찮을 것 같다.</p><ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9401.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 01</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9402.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 02</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9403.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 03</a></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 05. 클래스의 정의</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/</guid>
      <pubDate>Sun, 26 Apr 2020 05:45:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;클래스와-인스턴스&quot;&gt;&lt;a href=&quot;#클래스와-인스턴스&quot; class=&quot;headerlink&quot; title=&quot;클래스와 인스턴스&quot;&gt;&lt;/a&gt;클래스와 인스턴스&lt;/h2&gt;&lt;p&gt;자바로 작성된 코드를 관찰해보면 종류에 상관 없이 모든 프로그램은 다음 두가지로 이뤄진다는 사실을 알 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 : 프로그램상에서 유지하고 관리해야 할 데이터&lt;/li&gt;
&lt;li&gt;기능 : 데이터를 처리하고 조작하는 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이중에서 데이터는 ‘변수의 선언’ 을 통해 유지 및 관리가 되고, 또 변수에 저장된 데이터는 ‘메소드의 호출’을 통해 처리가 된다. 이와 관련해서 다음 예제를 살펴보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스와-인스턴스"><a href="#클래스와-인스턴스" class="headerlink" title="클래스와 인스턴스"></a>클래스와 인스턴스</h2><p>자바로 작성된 코드를 관찰해보면 종류에 상관 없이 모든 프로그램은 다음 두가지로 이뤄진다는 사실을 알 수 있다.</p><ul><li>데이터 : 프로그램상에서 유지하고 관리해야 할 데이터</li><li>기능 : 데이터를 처리하고 조작하는 기능</li></ul><p>이중에서 데이터는 ‘변수의 선언’ 을 통해 유지 및 관리가 되고, 또 변수에 저장된 데이터는 ‘메소드의 호출’을 통해 처리가 된다. 이와 관련해서 다음 예제를 살펴보자.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BankAccountPO.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankAccountPO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> balance = <span class="number">0</span>; <span class="comment">// 예금 잔액</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        deposit(<span class="number">10000</span>); <span class="comment">//입금 진행</span></span><br><span class="line">        checkMyBalance();</span><br><span class="line">        withdraw(<span class="number">3000</span>);</span><br><span class="line">        checkMyBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;<span class="comment">//입금을 담당하는 메소드</span></span><br><span class="line">        balance += amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;<span class="comment">//출금을 담당하는 메소드</span></span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span></span>&#123;<span class="comment">//예금 조회를 담당하는 메소드</span></span><br><span class="line">        System.out.println(<span class="string">"잔액: "</span> +balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 BankAcountPO 를 보면 맴버변수 balance 와 메소드 deposit, withdraw, checkMyBalance 는 긴밀히 연관되어 있다. 긴밀히 연관되어있다는 것은 다음 내용을 뜻한다.</p><ul><li>메소드 deposit, withdraw, checkMyBalance는 맴버변수 balance를 위한 메소드이다.</li></ul><p>이렇듯 연관 잇는 변수와 메소드를 묶기 위해 ‘클래스’라는 것이 존재한다. 클래스를 이용하면 다음과 같이 변수 balance 그리고 이와 연관 있는 모든 메소드를 하나로 묶을 수 있다. 위의 코드를 가르켜 <strong>‘클래스 정의’</strong>라 한다.</p><h2 id="인스턴트-만들기"><a href="#인스턴트-만들기" class="headerlink" title="인스턴트 만들기"></a>인스턴트 만들기</h2><p>상단에 선언된 변수 balance는 ‘인스턴트 변수’ 라고 한다. (또는 멤버변수, 필드 라고 불리기도 한다.) 인스턴트 변수 balance를 위해 존재하는 하위 메소드들은 ‘인스턴트 메소드’라고 한다.</p><p>인스턴트 변수는 앞서 변수의 스코프에서 다루었던 지역변수가 아니다.  인스턴트 변수가 선언된 위치는 메소드 내부가 아니므로 이 둘은 성격이 다르다. 이러한 인스턴스 변수의 중요한 특징 중 하나는 다음과 같다.</p><ul><li>인스턴스 변수는 같은 클래스 내에 위치한 메소드 내에서 접근이 가능하다.</li></ul><p>다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccountPO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"잔액: "</span> +balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 인스턴스만들기 </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @인스턴스</span></span><br><span class="line"><span class="comment">         * 위의 문장을 실행하면 밑에 만들어둔 BankEx 에 정의된 변수와 메소드를 담고 있는 '인스턴스'라는 것이 </span></span><br><span class="line"><span class="comment">         * 만들어진다. 만들어져서 실제 메모리 공간에 존재하게 된다.</span></span><br><span class="line"><span class="comment">         * (인스턴스는 다른말로 객체라고도 한다. 인스턴스의 생성과 객체의 생성은 그 의미가 완전히 동일하다.)</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 물론 다음과 같이 둘, 혹은 그 이상도 만들 수 있다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 이렇게 메모리상에 인스턴스를 만들기만 해서는 사용할 수가 없다. </span></span><br><span class="line"><span class="comment">         * 만들어진 인스턴스를 참조할 수 있는 무언가가 필요하다. </span></span><br><span class="line"><span class="comment">         * 그리고 이 무엇인가를 가리켜 '참조변수(Reference Variable)'이라고 한다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BankAccountPO june; <span class="comment">//참조변수 myAcnt1의 선언</span></span><br><span class="line">        BankAccountPO james; <span class="comment">//참조변수 myAcnt2의 선언</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 즉 다음과 같이 참조변수를 선언하고 이를 통해서 새로 생성되는 인스턴스(객체)를 가리키게 할 수 있다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        june = <span class="keyword">new</span> BankAccountPO02();<span class="comment">//참조변수 june 이 새로 생성되는 인스턴스를 가리킴</span></span><br><span class="line">        james = <span class="keyword">new</span> BankAccountPO02();<span class="comment">//참조변수 james 가 새로 생성되는 인스턴스를 가리킴</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@new</span></span></span><br><span class="line"><span class="comment">          * 키워드 new 를 통해서 인스턴스를 생성하면 생성된 인스턴스의 주솟값이 반환된다.</span></span><br><span class="line"><span class="comment">            즉 참조변수에는 생성된 인스턴스의 주솟값이 저장되는 셈이다. </span></span><br><span class="line"><span class="comment">            하지만 다음과 같이 표현하고 인식하자. 이것보다 일반적인 표현이다.</span></span><br><span class="line"><span class="comment">            (주솟값은 참조변수에 저장된 값이기에 본서에서는 이 값을 '참조 값' 이라고 한다.)</span></span><br><span class="line"><span class="comment">            - 참조변수는 인스턴스를 참조한다.</span></span><br><span class="line"><span class="comment">            - 참조변수는 인스턴스를 가리킨다.</span></span><br><span class="line"><span class="comment">            그리고 참조변수를 통해서 해당 인스턴스의 메소드를 호출하는것은 다음과 같다.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//각 인스턴스를 대상으로 예금을 진행</span></span><br><span class="line">          june.deposit(<span class="number">10000</span>);</span><br><span class="line">          james.deposit(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//각 인스턴스를 대상으로 잔액을 조회</span></span><br><span class="line">          System.out.println(<span class="string">"myAcnt1의 잔액 :"</span>);</span><br><span class="line">          june.checkMyBalance();</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"myAcnt2의 잔액 :"</span>);</span><br><span class="line">          james.checkMyBalance();</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 코드와 실행 결과를 보면, 참조변수 준과 제임스가 가리키는 인스턴스가 </span></span><br><span class="line"><span class="comment">           * 서로 다른 인스턴스인 것을 알 수 있다.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * @참조변수에 null 대입</span></span><br><span class="line"><span class="comment">              때로는 참조변소가 참조하는 인스턴스와의 관계를 끊고 아무런 인스턴스도 참조하지 않도록</span></span><br><span class="line"><span class="comment">              할 필요가 있다. 그리고 이때에는 다음과 같이 참조변수에 null을 대입하면 된다.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            james = <span class="keyword">null</span>;</span><br><span class="line">            june = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="인스턴스의-구분"><a href="#인스턴스의-구분" class="headerlink" title="인스턴스의 구분"></a>인스턴스의 구분</h2><p>앞서 정의한 BankAccount클래스를 다시 관찰해보자. 은행에서는 고객이 계좌를 개설할 때마다 이 클래스의 인스턴스를 생성해야 한다.</p><p>그런데 문제는 인스턴스를 구분할 수 있는 정보가 빠졌다는 것이다. 즉 이전 예제에 최소한 다음 두가지 정도는 추가가 되어야 한다. 그래야 누구의 계좌인지 구분할 수 있다.</p><ul><li>계좌번호 </li><li>주민번호 </li></ul><p>이것을 반영하여 새로운 클래스를 만들어보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 인스턴트만들기</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BankAccount jaebeom = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line">jaebeom.initAccount(<span class="string">"123-456-789"</span>, <span class="string">"950621"</span>, <span class="number">10000</span>);</span><br><span class="line">jaebeom.deposit(<span class="number">5000</span>);</span><br><span class="line">jaebeom.checkMyBalance();</span><br><span class="line"></span><br><span class="line">BankAccount jongwon = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line">jongwon.initAccount(<span class="string">"321-654-987"</span>, <span class="string">"960113"</span>, <span class="number">10000</span>);</span><br><span class="line">jongwon.withdraw(<span class="number">3000</span>);</span><br><span class="line">jongwon.checkMyBalance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span></span>&#123;</span><br><span class="line">String accNumber;<span class="comment">//계좌번호</span></span><br><span class="line">String ssNumber;<span class="comment">//주민번호</span></span><br><span class="line"><span class="keyword">int</span> balance = <span class="number">0</span>;<span class="comment">//예금 잔액</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화를 위한 메소드</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAccount</span><span class="params">(String acc, String ss, <span class="keyword">int</span> bal)</span> </span>&#123;</span><br><span class="line">accNumber = acc;</span><br><span class="line">ssNumber = ss;</span><br><span class="line">balance = bal; <span class="comment">//계좌 개설 시 예금액으로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance +=amount;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance -=amount;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"계좌번호:"</span>+accNumber);</span><br><span class="line">System.out.println(<span class="string">"주민번호:"</span>+ssNumber);</span><br><span class="line">System.out.println(<span class="string">"잔액:"</span>+balance+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>이번 예제에서는 새로운 메소드 initAccount가 추가되었다. 이 메소드는 다음과 같은 부분에서 다른 메소드들과 성격상 구분이 된다. </p><p>-인스턴스의 초기화를 위한 메소드이다.<br>-때문에 인스턴스 생성 시 반드시 한번 호출해서 초기화를 진행해야한다.</p><p>그러나 위와 같이 메소드를 정의하지 않고 <strong>‘생성자(Constructor)’</strong>라는 것을 정의해서 인스턴스의 초기화를 진행할 수도 있다. 생성자는 인스턴스 생성 과정에서 초기화를 위해 자동으로 호출되는 일종의 메소드이다. </p><h2 id="생성자의-정의"><a href="#생성자의-정의" class="headerlink" title="생성자의 정의"></a>생성자의 정의</h2><p>생성자는 메소드와 모습이 같다. 따라서 생성자를 ‘생성자 메소드’ 로 표현하는 경우도 있다. 그러나 생성자는 다음과 같은 부분에서 메소드와 차이가 있다. 달리 말하면 이는 생성자가 되기 위한 조건이기도 하다.</p><ul><li>생성자의 이름은 클래스의 이름과 동일해야 한다.</li><li>생성자는 값을 반환하지 않고 반환형도 표시하지 않는다. </li></ul><p>위의 조건을 모두 만족하면 이는 자바 컴파일러에 의해서 생성자로 인식된다. 따라서 인스턴스 생성 시 자동으로 호출되어 인스턴스를 초기화 하게 된다. 그럼 앞서 예제에서 인스턴스 초기화를 위해 생성자를 만들어보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">//this키워드는 class의 인스턴스 변수 자신을 가리킨다. 나중에 더 자세히 다루어보자.</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"저의 이름은 "</span> +name+<span class="string">" 입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"나이는 "</span>+ age +<span class="string">" 입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에 생성자를 보면 클래스와 이름이 동일하다. 그리고 반환하지 않으며 , 반환형도 선언하지 않았다. 따라서 생성자의 조건을 모두 갖췄다. 그리고 인스턴스를 메소드 main에서 생성할때 매개변수로 이름과 나이가 전달이 된다.</p><p>즉 위와같이 문장을 구성하면 ‘인스턴스 생성 마지막 단계’ 에서 다음의 생성자가 호출되면서 값들이 전달된다. 그리고 이 값들로 인스턴스 변수가 초기화 된다.</p><p>생성자와 관련하여 다음 사실을 반드시 기억해야 한다.</p><ul><li>인스턴스 생성의 마지막 단계는 생성자 호출이다.</li><li>어떠한 이유로든 생성자 호출이 생략된 인스턴스는 인스턴스가 아니다.</li></ul><h3 id="디폴트-생성자-Default-Constructor"><a href="#디폴트-생성자-Default-Constructor" class="headerlink" title="디폴트 생성자(Default Constructor)"></a>디폴트 생성자(Default Constructor)</h3><p>인스턴스 생성의 마지막 단계는 생성자 호출이라 하였다. 그리고 생성자 호출이생략된 인스턴스는 인스턴스가 아니라고 하였다. 하지만 앞서 생성자가 없는 클래스를 수차례 정의하였고 이들을 대상으로 인스턴스를 생성한 바 있다. 그렇다면 이렇게 생성된 인스턴스는 인스턴스가 아니란 뜻인가?<br>사실 다음과 같이 생성자를 생략한 상태의 클래스를 정의하면 자바 컴파일러가 ‘디폴트 생성자’ 라는 것을 클래스의 정의에 넣어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">//디폴트 생성자</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 보이듯이, 디폴트 생성자는 인자를 전달받지 않는 형태로 정의되어 삽입된다. 물론 내부적으로 하는 일도 없다. 하지만 이로 인해서 인스턴스의 생성 규칙인 ‘생성자의 호출’ 은 유지가 된다. 생성자를 정의하지 않더라도 말이다. 그런데 컴파일러에 의해서 디폴트 생성자가 삽입이 되더라도 생성자는 직접 정의해주는것이 좋다.    아주 예외적인 상황이 아니라면, 생성자가 필요 없는 클래스는 잘 정의된 클래스가 아닐 확률이 높기 때문이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 04. 메소드와 변수의 스코프</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
      <pubDate>Wed, 22 Apr 2020 09:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;메소드의-정의&quot;&gt;&lt;a href=&quot;#메소드의-정의&quot; class=&quot;headerlink&quot; title=&quot;메소드의 정의&quot;&gt;&lt;/a&gt;메소드의 정의&lt;/h2&gt;&lt;p&gt;앞서 예제를 작성하고 호출하기 위해 main메소드 안에서 작업한것을 알 수 있다. main메서드는 클래스의 내부에 존재해야한다.&lt;/p&gt;
&lt;p&gt;지금까지 만들어온 메서드의 이름이 항상 main인 이유는 다음 약속에 근거한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="메소드의-정의"><a href="#메소드의-정의" class="headerlink" title="메소드의 정의"></a>메소드의 정의</h2><p>앞서 예제를 작성하고 호출하기 위해 main메소드 안에서 작업한것을 알 수 있다. main메서드는 클래스의 내부에 존재해야한다.</p><p>지금까지 만들어온 메서드의 이름이 항상 main인 이유는 다음 약속에 근거한다. <a id="more"></a> 자바 프로그램은 main이라는 이름의 메소드에서부터 시작을 한다. 따라서 추가로 만들게 될 메소드의 이름은 다음과 같이 직접 결정하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hiEveryone</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"좋은 아침입니다."</span>);</span><br><span class="line">    System.out.println(<span class="string">"제 나이는 "</span> + age+<span class="string">" 입니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드 내용을 가리켜 ‘메소드 정의’라 한다. 즉 위의 코드는 ‘메소드 hiEveryone의 정의’이다. hiEveryone의 오른편 소괄호에는 정수형 변수 age가 있다. 이 변수가 어떻게 활용되는지 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    hiEveryone(<span class="number">26</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 결과를 보면 </p><p>‘좋은 아침입니다. 제 나이는 26입니다.’</p><p>가 출력되는 것을 볼 수 있다.</p><p>즉 main 메서드에서 hiEveryone메서드를 호출하고 파라미터로 26을 전달하는 것 이다. 일단 public 과 static은 무시하고  여기서 알 수 있는건 메서드를 정의 할때는</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">자료형(리턴타입) | 메서드명 | (매개변수를 받으면 소괄호안에 해당하는 타입의 변수를 작성)&#123;</span><br><span class="line"><span class="comment">//중괄호 안에 로직 작성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>으로 만들 수 있고, 메서드 사용시에는 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">메서드명(매개변수를 만들었다면, 전달할 인자값 작성);</span><br></pre></td></tr></table></figure><p>으로 사용할 수 있다. 물론 매개변수는 하나 이상 사용이 가능하다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myInfo</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"제 이름은 "</span>+ name+<span class="string">" 이고, 나이는 "</span> + age+<span class="string">" 입니다."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    myInfo(<span class="string">"고재범"</span>, <span class="number">26</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 매개변수를 두개, 혹은 그이상도 사용할 수 있다.</p><h2 id="메소드의-반환값"><a href="#메소드의-반환값" class="headerlink" title="메소드의 반환값"></a>메소드의 반환값</h2><p>이전에 다루었던 method는 매개변수를 사용하는 정도까지 알아보았다. 하지만 method의 실제 사용되는 모습이랑은 많이 다르다. 이번엔 method를 정의할 때 값을 반환 하는 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 메소드를 보면 void였던 부분에 int 가 들어가있다. 저 부분은 반환형을 지정하는 곳 인데, 지금까지 값을 반환하지 않았기 때문에 void를 사용하였다. </p><p>void는 값을 return 하지 않는다고 선언하는 방법이다. 하지만 위의 예제는 정수타입의 값을 return하고 있기때문에 반환형으로 int를 사용하였다. 그럼 return의 정확한 의미는 무엇일까? 다음과 같다.</p><ul><li>메소드를 호출한 영역으로 값을 반환</li><li>메소드의 종료</li></ul><p>메소드의 종료는 알겠는데, 메소드를 호출한 영역으로 값을 반환한다는건 무슨 소리일까? 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정수형 변수 num을 선언하고 add()메소드로 초기화하고있다. 메소드 add는 반환 타입이 정수였다. 그렇기때문에 정수형 변수의 값으로 담을 수 있게 되는 것 이다. 이때는 정확히 메소드 add의 반환 값이 담긴다고 생각하면 되겠다.</p><p>이것은 위에서 설명한 메소드를 호출한 영역으로 값을 반환한다는 것과 같은 맥락이다. 위의 목적은 메소드 add에게 값을 전달해 연산을 하도록하여 연산된 값을 이부분에서 출력해보기 위한 것 같다. 그렇다면 저렇게 변수에 담지 않고 바로 출력하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(add(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="변수의-스코프"><a href="#변수의-스코프" class="headerlink" title="변수의 스코프"></a>변수의 스코프</h2><p>지금까지 중괄호 {…}가 사용되었던 때를 정리해 보면 다음과 같다.</p><ul><li>if문 또는 switch문 같은 조건문에 사용되었다</li><li>for , while등의 반복문에 사용되었다.</li><li>메소드의 몸체 부분을 감싸는 용도로 사용되었다. </li></ul><p>이처럼 중괄호는 다양한 경우에 사용된다. 그런데 이렇듯 중괄호로 특정 영역을 감싸면, 해당 영역은 변수에 관한 별도의 스코프를 형성하게 된다. 예를 들어서 다음과 같이 if문 안에 변수가 선언되게 되면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(num); 주석을 처리하면 에러가 난다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if문 밖에서는 변수 num을 사용할 수 없다. 이 변수 num은 중괄호 내에서만 접근이 가능하며,중괄호를 벗어나는 순간 소멸되어 접근이 불가능한 변수가 된다. 좋은 예는 아니지만 이말은 즉 똑같은 변수명으로 괄호 밖에서 다시 선언할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(num); 주석을 처리하면 에러가 난다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지 설명한 중괄호 내에 선언된 변수들을 가리켜 ‘지역변수(Local Variable)’라 한다. 그리고 for문의 초기화 부분에서 선언되는 변수화 매개변수까지도 지역변수의 범주에 포함된다. 그런데 이러한 지역변수들이 갖는 중요한 특징이 하나 있다.</p><ul><li>지역변수는 선언된 지역을 벗어나면 메모리 공간에서 소멸된다.</li></ul><p>즉 선언된 지역을 벗어나면 단순히 접근만 불가능해지는 것이 아니라 메모리상에서 삭제가 되는 것이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 03. 실행흐름의 컨트롤</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/</guid>
      <pubDate>Wed, 22 Apr 2020 08:16:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건문이란&quot;&gt;&lt;a href=&quot;#조건문이란&quot; class=&quot;headerlink&quot; title=&quot;조건문이란?&quot;&gt;&lt;/a&gt;조건문이란?&lt;/h2&gt;&lt;p&gt;조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="조건문이란"><a href="#조건문이란" class="headerlink" title="조건문이란?"></a>조건문이란?</h2><p>조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다. <a id="more"></a></p><h3 id="if문"><a href="#if문" class="headerlink" title="if문"></a>if문</h3><p>특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 키워드 if를 사용하면 된다. 그리고 두개의 문장 중 조건에 따라 하나만 실행하고 싶다면 거기에 else를 더 추가하면 된다. else는 if문 소괄호의 조건이 참이 아니라면 실행되는 곳이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if문 예제</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    <span class="comment">//조건 true 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"참입니다"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//조건 false 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"거짓입니다"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if ~ else if 문은 2개 이상의 조건을 주고싶을 때 사용할 수 있는 방법이다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if ~ else if문 예제</span></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1보다 num2가 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num2보다 num1이 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 == num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1과 num2는 같습니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"셋다 해당되지 않습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조건-연산자"><a href="#조건-연산자" class="headerlink" title="조건 연산자"></a>조건 연산자</h3><p>조건 연산자는 피연산자가 세 개인 연산자이다. (자바스크립트의 삼항연산자와 비슷하다.) 이러한 조건 연산자는 간단한 if~else문을 대체하는 용도로 주로 사용된다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//조건 연산자 예제</span></span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num5 = (<span class="keyword">false</span>) ? num3 : num4;</span><br><span class="line">System.out.println(<span class="string">"결과 : "</span>+ num5);</span><br></pre></td></tr></table></figure><p>변수 num5 는 선언과 동시에 조건연산자에 의한 값을 할당한다. ()안의 조건이 참이면 num3이 저장될 것이고 , 거짓이라면 num4가 저장될 것 이다. 하지만 임의적으로 false라는 값을 줌으로써 변수 num5에는 num4의 값, 즉 20이 저장되는것을 알 수 있다.</p><h3 id="switch문"><a href="#switch문" class="headerlink" title="switch문"></a>switch문</h3><p>조건에 따라 실행할 문장을 구분한다는 측면에서 if문과 유사하다. else if가 많이 들어가는 상황에서는 switch문이 더 좋은 선택이 될 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    String animal = <span class="string">"고양이"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">        System.out.println(<span class="string">"강아지가 맞습니다"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>레이블(Label)</strong></p><p>위의 switch 내부에 존재하는 키워드 case와 default를 가리켜 레이블이라고 한다. 레이블 case와 default는 코드상에서 위치를 표시하기 위해 사용된다. case는 switch 의 조건과 같은 타입을 가져야하고 같은 결과 값일 경우 그 case 이후의 값들이 출력이된다. 이것은 이후에 나오는 break문으로 제어할 수 있다. </p><p>default는 case에서 switch와 같은 조건의 값이 없다면 실행되는 구문이다. 그리고 case와 default를 보면 들여쓰기가 되어있지 않다. 이는 책에 위치를 표시하는 레이블과 그 성격이 같다. 그리고 레이블은 책을 펼치기 전에 보여야 한다. 이와 마찬가지로 case와 default도 조금이라도 잘 보이도록 들여쓰기 대상에서 제외하는 것이 일반적이다.</p><p>일단 위의 결과를 보게되면 switch의 참거짓을 판단하는 매개변수로 animal이라는 변수를 주었다. 이 변수에 할당된 값은 ‘고양이’ 이다. 당연히 콘솔에 고양이가 맞습니다. 라고 찍힐 것이라고 예상할 수 있지만 결과는 고양이가 맞습니다. 이후에 나오는 모든 조건의 결과</p><p>고양이가 맞습니다.<br>고라니가 맞습니다.<br>해당하는 동물이 없습니다.</p><p>가 찍힌다.</p><p>이는 break 라는 키워드로 case의 실행구문이 끝난 이후 사용해 주어야 하위 case들이 실행 되는 것을 막을 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(animal) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">    System.out.println(<span class="string">"강아지가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">    System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 switch문과는 다르게 각 case가 끝나는 부분에 break가 추가 되었다. 그리고 결과로는 고양이가 맞습니다. 이후의 출력은 사라졌다. 즉 if, else처럼 해당하는 조건에 맞는 결과값만이 출력이 되는 것을 확인 할 수 있다. 이는 switch문의 일반적인 사용 모델이다.</p><hr><h2 id="반복문이란"><a href="#반복문이란" class="headerlink" title="반복문이란?"></a>반복문이란?</h2><p>반복문은 어떤 작업이 반복적으로 수행되도록 할 때 사용된다. while, do~while, for문등을 예로 들 수 있다.</p><h3 id="while문"><a href="#while문" class="headerlink" title="while문"></a>while문</h3><p>먼저 while 문 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//While문</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 결과는 I Like Java가 5번 출력되는 것을 알 수 있다.</p><ul><li>while문의 소괄호에는 반복의 조건을 명시한다. </li><li>true 또는 false가 와야 하므로 이를 반환하는 연산이 오게 된다. </li><li>그리고 그 조건이 true를 반환하는 동안에는 횟수에 상관없이 while문의 중괄호가 반복 실행되는데 , 다음의 패턴으로 반복이 된다.<ol><li>먼저 조건검사</li><li>그리고 결과가 true이면 중괄호 영역 실행</li></ol></li></ul><p>반면에 밑에 예제에서 다루는 do ~ while문은 다음의 패턴으로 진행한다.</p><ol><li>먼저 중괄호 영역 실행</li><li>그리고 조건 검사 후 결과가 true이면 반복 결정<br>밑의 예제를 확인해 보자.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_while문</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"I Like Java "</span> + num2);</span><br><span class="line">    num2++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num2 &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br><p>위 예제는 이전의 while문을 do-while로 바꾼것 뿐이다. 따라서 실행결과는 동일하다. 보는것처럼 while문으로 작성된 문장은 do-while로도 작성가능한 경우가 대부분다. </p><p>따라서 “조건에 따른 반복이 필요하다. 그런데 반드시 한 번은 실행을 해야 한다.” 라는 경우에는 do~while문을 사용하는 것이 괜찮다. 이 이외의 경우에는 while문 또는 이어서 소개하는 for문을 사용하는 것이 바람직하다. 그래야 선택하는 반복문에 더 많은 의미를 부여할 수 있다. </p><h3 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h3><p>이전에 다루었던 while문에서 했던 예제들은 거의 반복하는 값이 정해져있었다. 이처럼 ‘반복의 횟수가 정해져 있는 상황’ 에서는 for문을 이용해서 다음과 같이 작성하는 것이 더 간결하고 뜻도 더 잘 통한다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for문 예제</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Love Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서 실행 흐름을 보자면 </p><ol><li>변수의 선언및 초기화</li><li>반복 조건이 true인지 확인</li><li>반복 영역을 실행 (반복 조건이 true이면)</li><li>변수의 값 증가</li></ol><p>그리고 그 이후 두번째 반복부터는 첫번째 조건인 변수의 선언및 초기화 부분은 지나치게 된다. </p><h3 id="break-와-continue"><a href="#break-와-continue" class="headerlink" title="break 와 continue"></a>break 와 continue</h3><p>break 문은 앞서 switch문을 빠져나가는 용도로 다루었었는데, 마찬가지로 반복문을 빠져나가는 용도로도 사용된다.<br>보통 if문과 함께 사용되어 특정 조건이 만족될 때, 이를 감싸는 반복문을 빠져나가도록 구성이 된다. break는 이전에 다루던 것과 별 차이가 없기 때문에 따로 예제를 다루지 않는다.</p><p>continue문은 break문과 혼동하기 쉬워서 주의가 필요하다. 우선 continue는 반복문의 탈출과 거리가 멀다. 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건 검사 부분으로 이동시킨다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n++)&lt;<span class="number">5</span>) &#123;<span class="comment">//while 하단부에서 증가시켜줬던 구문을 이런식으로 작성할 수 있다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 구문을 실행시켜보면 총 4번 실행 되는 것을 알 수 있다. 0~4까지 총 5번 출력되는 것이 맞는 것 이라고 생각 할 수 있는데, 이유는 조건에 따른 continue 구문이 실행하게 되면 그 이후의 문장은 무시하고 다시 반복문의 조건 검사로 이동하게 되기때문이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 02. 상수와 형변환</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</guid>
      <pubDate>Wed, 22 Apr 2020 07:22:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;상수의-특징&quot;&gt;&lt;a href=&quot;#상수의-특징&quot; class=&quot;headerlink&quot; title=&quot;상수의 특징&quot;&gt;&lt;/a&gt;상수의 특징&lt;/h3&gt;&lt;p&gt;자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값을 딱 한 번만 할당할 수 있다.&lt;/li&gt;
&lt;li&gt;한 번 할당된 값은 변경이 불가능하다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="상수의-특징"><a href="#상수의-특징" class="headerlink" title="상수의 특징"></a>상수의 특징</h3><p>자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. </p><ul><li>값을 딱 한 번만 할당할 수 있다.</li><li>한 번 할당된 값은 변경이 불가능하다.<a id="more"></a></li></ul><p>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span> CONST_CHAR = <span class="string">'상'</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CONST_ASSIGNED; </span><br><span class="line">    CONST_ASSIGNED = <span class="number">12</span>; <span class="comment">//할당하지 않았던 상수의 값 할당.</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(MAX_SIZE);</span><br><span class="line">    System.out.println(CONST_CHAR);</span><br><span class="line">    System.out.println(CONST_ASSIGNED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서는 다음과 같이 변수의 선언에 final을 추가하였다. 따라서 이 변수는 값의 변경이 불가능한 상수가 된다. CONST_ASSIGNED처럼 선언만해놓았다면 딱 한번 값을 할당할 수 있다. 물론 그이후로는 불가능 하다.</p><p><strong>상수의 관례</strong><br>그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다.</p><ul><li>상수의 이름은 모두 대문자로 짓는다.</li><li>이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.</li></ul><h2 id="리터럴-상수에-대한-이해"><a href="#리터럴-상수에-대한-이해" class="headerlink" title="리터럴 상수에 대한 이해"></a>리터럴 상수에 대한 이해</h2><p>다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">157</span>;</span><br></pre></td></tr></table></figure><p>대입연산자의 오른편에 위치한 숫자 157을 리터럴 또는 리터럴 상수 라고한다. 컴파일러는 위 변수에 대입한 숫자 157을 무엇으로 인식할까?   결론은 int형 정수로 인식한다. 다음 예제를 통해 좀더 이해를 도와보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> num = <span class="number">3146234266</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>에러처리가 나서 주석처리를 하였다. </p><p><em>The literal 3146234266 of type int is out of range</em></p><p>라는  에러가 뜨는 것을 확인하였다. 숫자 3146234266 는 int형 정수여야하는데 값이 너무크다라고 한다. 이게 이해가 가지 않는다 당연히 큰숫자인것을 알고있기때문에 일부러 int가 아닌 long자료형의 변수에 값을 할당했는데 이런 오류가 나다니..</p><p>위에서도 언급하지만, 왼편에 있는 변수의 자료형에 상관없이 정수는 int형으로 표현하기로 약속되어있다. 그래서 위와같은 오류 메시지가 발생하는 것이다. 그렇다면 long형 변수에 다음과같은 큰 값을 어떻게 저장할 수 있을까?</p><h3 id="형-변환"><a href="#형-변환" class="headerlink" title="형 변환"></a>형 변환</h3><p><strong>자동 형변환</strong><br>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">long</span> num2 = <span class="number">3147483647L</span>;</span><br><span class="line">System.out.println(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 상황에서는 int형 변수에 담긴 값을 long형으로 변환해야 데이터의 손실 없이 연산이 가능하다. 따라서 다음의 과정을 거쳐서 연산을 마무리한다.</p><ul><li>변수 num1에 저장된 값을 long형으로 변환하여 메모리에 임시 저장한다.</li><li>이어서 이 변환된 값과 num2에 저장된 값을 대상으로 덧셈을 진행한다.</li></ul><p>이러한 일련의 과정을 가리켜 ‘자료형 변환’ 또는 줄여서 ‘형 변환’ 이라고 한다. 그리고 위의 예제의 특징으로 자동 형 변환 이라고 한다.  프로그래머가 명시한 형 변환이 아니고 필요한 상황에서 자동으로 형 변환이 일어났기 때문이다. 이렇듯 형 변환이 필요한 상황에서는 다음 두 규칙에 근거하여 자동으로 형 변환이 일어난다.</p><p><strong>자동 형변환 규칙</strong></p><ol><li>자료형의 크기가 큰 방향으로 형 변환이 일어난다.</li><li>자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.</li></ol><p>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</p><p><strong>자동 형변환의 예</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num3 = <span class="number">30</span>; <span class="comment">//int형 정수 30은 double형으로 자동 형 변환 한다.</span></span><br><span class="line">System.out.println(<span class="number">60L</span> + <span class="number">34.5</span>); <span class="comment">//long형 정수 60L은 double형으로 자동 형 변환 한다.</span></span><br></pre></td></tr></table></figure><p><strong>명시적 형변환</strong><br>자동형변환의 특징을 봤을땐 </p><p>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</p><p>의 특징을 가지고있었다. 그럼 거꾸로 실수에서 정수형으로 형변환을 하려고하는 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="comment">//int wholeNumber = pi; double형의 pi를 int형 wholeNumer에 할당하려 하자 에러가난다. 이것을 명시적으로 형변환하면 아래와 같다.</span></span><br><span class="line">    <span class="keyword">int</span> wholeNumer = (<span class="keyword">int</span>)pi; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//이전 예제였던 short의 합 명시적 형변환으로 해결</span></span><br><span class="line">    <span class="keyword">short</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">short</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">short</span> num3 = (<span class="keyword">short</span>) (num1+ num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 문장에 10번째 줄에 소괄호가 두번 등장하였다. 하나는 num1과 num2의 덧셈연산을 묶을 목적으로, 또 하나는 형 변환을 목적으로 등장하였다.      이중에서 형 변환에서 사용된 소괄호는 연산자로 분류한다. 반면에 묶거나 구분하는 목적으로 사용이 되는 소괄호는 ‘구분자’라 하여 그 성격이 연산자와 다르다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
