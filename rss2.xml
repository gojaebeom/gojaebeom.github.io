<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jaebeom&#39;s Blog</title>
    <link>http://gojaebeom.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/98c3781dafc67dfe731441beeee5e4ec</url>
      <title>Jaebeom&#39;s Blog</title>
      <link>http://gojaebeom.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>재범의 기술 블로그 입니다.</description>
    <pubDate>Mon, 27 Jul 2020 05:01:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>자료형</title>
      <link>http://gojaebeom.github.io/2020/07/27/8.%20javascript/js06/</link>
      <guid>http://gojaebeom.github.io/2020/07/27/8.%20javascript/js06/</guid>
      <pubDate>Mon, 27 Jul 2020 04:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트에서 값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트에서 값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속한다.</p><a id="more"></a><p>자바스크립트의 변수는 자료형에 관계없이 모든 데이터를 넣을 수 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//no error</span><br><span class="hljs-keyword">let</span> message = <span class="hljs-string">"hello"</span>;<br>message = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 ‘동적 타입(dynamically typed)’ 언어라 부른다.</p><p>자바스크립트엔 여덟 가지 기본 자료형이 있다. </p><h2 id="숫자형"><a href="#숫자형" class="headerlink" title="숫자형"></a>숫자형</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span>;<br>num = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>숫자형은 정수 및 부동소수점 숫자를 나타낸다.</p><p>숫자형엔 일반적인 숫자 외에 <code>Infinity</code>, <code>-Infinity</code>, <code>NaN</code> 같은 ‘특수 숫자 값’이 포함된다.</p><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><p><code>Infinity</code>는 어떤 숫자보다 큰 특수 값, 무한대를 나타낸다. 어느 숫자든 0으로 나누면 무한대를 얻을 수 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// 무한대</span><br></code></pre></td></tr></table></figure><p><code>Infinity</code>를 직접 참조할 수도 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-literal">Infinity</span>);<span class="hljs-comment">// 무한대</span><br></code></pre></td></tr></table></figure><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code>은 계산 중에 에러가 발생했다는 것을 나타내주는 값이다. 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 <code>NaN</code>이 반환된다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">"숫자가 아님"</span>/<span class="hljs-number">2</span>); <span class="hljs-comment">//NaN , 문자열을 숫자로 나누면 오류가 발생</span><br></code></pre></td></tr></table></figure><p>연산 과정 어디에서 <code>NaN</code>이 반환되었다면, 이는 모든 결과에 영향을 준다.</p><h3 id="수학-연산은-안전하다"><a href="#수학-연산은-안전하다" class="headerlink" title="수학 연산은 안전하다"></a>수학 연산은 안전하다</h3><p>자바스크립트에서 행해지는 수학 연산은 안전하다고 볼 수 있다. 0으로 나눈다거나 숫자가 아닌 문자열을 숫자로 취급하는 등의 이례적인 연산이 자바스크립트에선 가능하다.</p><p>말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽지 않는다. <code>NaN</code>을 반환하며 연산이 종료될 뿐 이다.</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>내부 표현 방식 때문에 자바스크립트에선 <code>(2&lt;sup&gt;53&lt;/sup&gt;-1)(9007199254740991)</code>보다 큰 값 혹은 <code>-(2&lt;sup&gt;53&lt;/sup&gt;-1)</code>보다 작은 정수는 ‘숫자형’을 사용해 나타낼 수 없다. 사실 대부분의 상황에서 이런 제약사항은 문제가 되지 않는다. 그렇지만 암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때는 이런 큰 숫자가 필요하다.</p><p><code>BigInt</code>형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있다.</p><p><code>BigInt</code>형 값은 정수 리터럴 끝에 <code>n</code>을 붙이면 만들 수 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bigInt = <span class="hljs-number">1000000000000000000000000000000000n</span>;<br></code></pre></td></tr></table></figure><h2 id="문자형"><a href="#문자형" class="headerlink" title="문자형"></a>문자형</h2><p>자바스크립트에선 문자열(String)을 따옴표로 묶는다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">"Hello"</span>;<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">'Hello'</span>;<br><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">'gjb'</span>;<br><span class="hljs-keyword">let</span> str3 = <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p>따옴표는 세 종류가 있다.</p><ol><li>큰따옴표 : “”</li><li>작은따옴표 : ‘’</li><li>역 따옴표(백틱, backtick): ``</li></ol><p>큰따옴표와 작은 따옴표는 기본적인 따옴표로, 자바스크립트에선 이 둘의 차이를 두지 않는다.</p><p>역따옴표는 변수나 표현식을 감싼 후 <code>${...}</code> 안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중안에 손쉽게 넣을 수 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'John'</span>;<br>alert( <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br><br>alert( <span class="hljs-string">`the result is <span class="hljs-subst">$&#123;<span class="hljs-number">1</span> + <span class="hljs-number">2</span>&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="불린형-boolean"><a href="#불린형-boolean" class="headerlink" title="불린형(boolean)"></a>불린형(boolean)</h2><p>불린형(논리 타입)은 <code>true</code>와 <code>false</code> 두 가지 값밖에 없는 자료형이다.</p><p>불린형은 긍정이나 부정을 나타내는 값을 저장할 때 사용된다. <code>true</code>는 긍정, <code>false</code>는 부정을 의미한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>;<br>bool = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>불린값은 비교 결과를 저장할 때도 사용된다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bool = <span class="hljs-number">4</span> &gt; <span class="hljs-number">1</span>;<br><br>alert(bool);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="null-값"><a href="#null-값" class="headerlink" title="null 값"></a>null 값</h2><p><code>null</code> 값은 지금까지 소개한 자료형 중 어느 자료형에도 속하지 않는 값이다.</p><p><code>null</code> 값은 오로지 <code>null</code>값만 포함하는 별도으 자료형을 만든다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>자바스크립트의 <code>null</code>은 자바스크립트 이외 언어의 <code>null</code>과 성격이 다르다. 다른 언어에선 <code>null</code>을 존재하지 않는 객체에 대한 참조나 널 포인터를 나타낼 때 사용한다.</p><p>하지만 자바스크립트에선 <code>null</code>을 존재하지 않는 값, 비어 있는 값, 알 수 없는 값을 나타내는 데 사용한다.</p><h2 id="undefined-값"><a href="#undefined-값" class="headerlink" title="undefined 값"></a>undefined 값</h2><p><code>undefined</code> 값도 <code>null</code>값처럼 자신만의 자료형을 형성한다.</p><p><code>undefined</code>는 값이 할당되지 않은 상태를 나타낼 때 사용한다.</p><p>변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 <code>undefined</code>가 자동으로 할당된다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age;<br><br>alert(age); <span class="hljs-comment">// `undefined`가 출력</span><br></code></pre></td></tr></table></figure><p>변수에 <code>undefined</code>를 명시적으로 할당하는 것도 가능하다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age = <span class="hljs-literal">undefined</span>;<br><br>alert(age); <span class="hljs-comment">// `undefined`</span><br></code></pre></td></tr></table></figure><p>하지만 이렇게 <code>undefined</code>를 직접 할당하는 걸 권장하진 않는다. 변수가 비어있거나 알 수 없는 상태라는 걸 나타내려면 <code>null</code>을 사용하면 된다. </p><h2 id="객체와-심볼"><a href="#객체와-심볼" class="headerlink" title="객체와 심볼"></a>객체와 심볼</h2><p>객체(obejct)형은 특수한 자료형이다.</p><p>객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다. 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있다.</p><p>이런 특징 때문에 자바스크립트에서 객체는 좀 더 특별한 취급을 받는다. 객체는 다른 글에서 자세히 다루도록 한다. </p><p>심볼(symbol)형은 객체의 고유한 식별자를 만들 때 사용된다. </p><h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><p><code>typeof</code> 연산자는 인수의 자료형을 반환한다. 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용하다.</p><p><code>typeof</code> 연산자는 두 가지 형태의 문법을 지원한다.</p><ol><li>연산자 : <code>typeof x</code></li><li>함수 : <code>typeof(x)</code></li></ol><p>괄호가 있든 없는 결과가 동일하다.</p><p><code>typeof</code>를 호출하면 인수의 자료형을 나타내는 문자열을 반환한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// "undefined"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> <span class="hljs-comment">// "number"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">10n</span> <span class="hljs-comment">// "bigint"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// "boolean"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">"foo"</span> <span class="hljs-comment">// "string"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"id"</span>) <span class="hljs-comment">// "symbol"</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span> <span class="hljs-comment">// "object"  (1)</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// "object"  (2)</span><br><br><span class="hljs-keyword">typeof</span> alert <span class="hljs-comment">// "function"  (3)</span><br></code></pre></td></tr></table></figure><p>마지막 세줄은 다음과 같다.</p><ol><li><code>Math</code>는 수학 연산을 제공하는 내장 객체이므로 <code>object</code>가 출력된다.</li><li><code>null</code>의 결과는 <code>object</code>이다. <code>null</code>은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨둔 상황이다. 언어 자체의 오류이므로 <code>null</code>이 객체가 아님에 유의하자.</li><li><code>alert()</code>는 <code>function</code>을 출력한다. 그런데 함수형은 따로 없다. 함수는 객체형에 속한다. 이런 동작 방식이 형식적으론 잘못되긴 했지만, 아주 오래전에 만들어진 규칙이기 때문에 하위 호완성 유지를 위해 남겨진 상태다.(한편 실무에선 이런 특징이 매우 유용하게 사용된다고 한다)</li></ol>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/27/8.%20javascript/js06/#disqus_thread</comments>
    </item>
    
    <item>
      <title>변수와 상수</title>
      <link>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js05/</link>
      <guid>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js05/</guid>
      <pubDate>Sun, 26 Jul 2020 13:15:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;대다수의 자바스크립트 애플리케이션은 사용자나 서버로부터 입력받은 정보를 처리하는 방식으로 동작한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;온라인 쇼핑몰 - 판매 중인 상품이나 장바구니 등의 정보&lt;/li&gt;
&lt;li&gt;채팅 애플리케이션 - 사용자 정보, 메시지 등의 정보
      
      </description>
      
      
      <content:encoded><![CDATA[<p>대다수의 자바스크립트 애플리케이션은 사용자나 서버로부터 입력받은 정보를 처리하는 방식으로 동작한다. </p><ol><li>온라인 쇼핑몰 - 판매 중인 상품이나 장바구니 등의 정보</li><li>채팅 애플리케이션 - 사용자 정보, 메시지 등의 정보<a id="more"></a></li></ol><p>변수는 이러한 정보를 저장하는 용도로 사용된다.</p><h2 id="변수-variable"><a href="#변수-variable" class="headerlink" title="변수(variable)"></a>변수(variable)</h2><p>변수는 데이터를 저장할 때 쓰이는 ‘이름이 붙은 저장소’ 이다.</p><p>자바스크립트에선 <code>let</code> 키워드를 사용해 변수를 생성한다.</p><p>아래 문은 <code>message</code>라는 이름을 가진 변수를 생성(선언)을 의미한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message;<br></code></pre></td></tr></table></figure><p>할당 연산자 <code>=</code>를 사용해 변수 안에 데이터를 저장할 수 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message;<br>message = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">// 문자열 저장</span><br></code></pre></td></tr></table></figure><p>문자열이 변수와 연결된 메모리 영역에 저장되었기 때문에, 변수명을 이용해 문자열에 접근할 수 있게 된다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message;<br>message = <span class="hljs-string">'Hello'</span>;<br><br>alert(message); <span class="hljs-comment">// 변수에 저장된 값을 보여줌</span><br></code></pre></td></tr></table></figure><p>아래와 같이 변수 선언과 값 할당을 한줄에 작성할 수도 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">// 변수 정의 및 값 할당</span><br></code></pre></td></tr></table></figure><p>한 줄에 여러 변수를 선언하는 것도 가능하다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">'John'</span>, age = <span class="hljs-number">25</span>, message = <span class="hljs-string">'Hello'</span>;<br></code></pre></td></tr></table></figure><p>위와 같은 작성법은 코드가 더 짧아 보이긴 하지만 권장하는 방법은 아니다. 가독성을 위해 한줄에는 하나의 변수를 작성하는 것이 좋다. </p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">'John'</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>;<br><br><span class="hljs-comment">//또는 </span><br><br><span class="hljs-keyword">let</span> user = <span class="hljs-string">'John'</span>,<br>    age = <span class="hljs-number">25</span>,<br>    message = <span class="hljs-string">'Hello'</span>;<br>  <br><span class="hljs-comment">//와 같은 방식도 있다.</span><br></code></pre></td></tr></table></figure><p>위의 방식은 기술적인 차이는 없다. 개인의 취향에 따라 원하는 방식으로 코드를 작성해도 된다.</p><h3 id="let-대신-var-🚨"><a href="#let-대신-var-🚨" class="headerlink" title="let 대신 var 🚨"></a>let 대신 var 🚨</h3><p>만들어진 지 오래된 스크립트에서 <code>let</code> 대신 <code>var</code> 라는 키워드를 발견하는 경우가 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">'Hello'</span>;<br></code></pre></td></tr></table></figure><p><code>var</code>는 <code>let</code>과 거의 동일하게 동작한다. 다만 <code>var</code>는 오래된 방식이다. <code>var</code>에 대해선 다른 글에서 다루도록 하겠다. </p><h3 id="변수-값"><a href="#변수-값" class="headerlink" title="변수 값"></a>변수 값</h3><p>변수의 값은 변경할 수 있다. 값이 변경되면, 이전 데이터는 변수에서 제거된다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message;<br><br>message = <span class="hljs-string">'Hello'</span>;<br><br>message = <span class="hljs-string">'World'</span>;<br><br>alert(message);<br></code></pre></td></tr></table></figure><p>결과는 ‘World’라는 문자열이 알림창에 출력된다. </p><p>변수 두개를 선언하고, 한 변수의 데이터를 다른 변수에 복사할 수도 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> Hello = <span class="hljs-string">'Hello world!'</span>;<br><br><span class="hljs-keyword">let</span> message;<br><br><span class="hljs-comment">//Hello의 'Hello world' 값을 message 변수의 값으로 복사 </span><br>message = Hello; <br><br><span class="hljs-comment">// 두 변수는 같은 데이터를 가진다.</span><br>alert(Hello);<br>alert(message);<br></code></pre></td></tr></table></figure><h3 id="변수-명명-규칙"><a href="#변수-명명-규칙" class="headerlink" title="변수 명명 규칙"></a>변수 명명 규칙</h3><p>자바스크립트에선 변수 명명 시 두 가지 제약사항이 있다.</p><ol><li>변수명에는 오직 문자와 숫자, 그리고 기호 <code>$</code>와 <code>_</code>만 들어갈 수 있다.</li><li>첫 글자는 숫자가 될 수 없다.</li></ol><p>여러 단어를 조합하여 변수명을 만들 땐 ‘카멜 표기법(camelCase)’가 흔히 사용된다.</p><h2 id="상수-constant"><a href="#상수-constant" class="headerlink" title="상수(constant)"></a>상수(constant)</h2><p>변하지 않는 변수를 선언할 땐, <code>let</code> 대신 <code>const</code>를 사용한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myBirthday = <span class="hljs-string">'1995.06.21'</span>;<br></code></pre></td></tr></table></figure><p>이렇게 <code>const</code>로 선언한 변수를 상수라고 부른다. 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에러가 발생한다.</p><h3 id="대문자-상수"><a href="#대문자-상수" class="headerlink" title="대문자 상수"></a>대문자 상수</h3><p>기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습이다.</p><p>이런 상수는 다음과 같이 대문자와 밑줄로 구성된 이름으로 명명한다. </p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> COLOR_RED = <span class="hljs-string">"#F00"</span>;<br><span class="hljs-keyword">const</span> COLOR_GREEN = <span class="hljs-string">"#0F0"</span>;<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js05/#disqus_thread</comments>
    </item>
    
    <item>
      <title>엄격 모드</title>
      <link>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js04/</link>
      <guid>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js04/</guid>
      <pubDate>Sun, 26 Jul 2020 12:15:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트는 오랫동안 호환성 이슈 없이 발전해왔다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트는 오랫동안 호환성 이슈 없이 발전해왔다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었다. </p><a id="more"></a><p>덕분에 기존에 작성한 코드는 절대 망가지지 않는다는 장점도 있다. 하지만 자바스크립트 창시자들이 했던 실수나 불완전한 결정이 언어 안에 영원히 박제된다는 단점도 생겼다.</p><p>이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었다. 그런데 새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있는데, 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었다. 대신 <code>use strict</code>라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았다.</p><h2 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h2><p>지시자 <code>&quot;use strict&quot;</code> , 혹은 <code>&#39;use strict&#39;</code>는 단순한 문자열처럼 생겼다. 하지만 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 ‘모던한’ 방식으로 동작한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;<br><span class="hljs-comment">// 이 코드는 모던한 방식으로 실행된다.</span><br></code></pre></td></tr></table></figure><h3 id="‘use-strict’는-반드시-최상단에-🚨"><a href="#‘use-strict’는-반드시-최상단에-🚨" class="headerlink" title="‘use strict’는 반드시 최상단에 🚨"></a>‘use strict’는 반드시 최상단에 🚨</h3><p><code>use strict</code>는 스크립트 최상단에 있어야 한다. 그렇지 않으면 엄격 모드가 활성화되지 않을 수 있다. </p><h2 id="브라우저-콘솔"><a href="#브라우저-콘솔" class="headerlink" title="브라우저 콘솔"></a>브라우저 콘솔</h2><p>개발한 기능을 테스트하기 위해 브라우저 콘솔을 사용하는 경우, 기본적으로 <code>use strict</code>가 적용되어있지 않다.</p><p>콘솔에서 <code>use strict</code>를 사용하기 위해선 <code>&#39;use strict&#39;</code>를 입력한 후, <code>shift+Enter키</code>를 눌러 줄바꿈 해 원하는 스크립트를 입력하면 된다.</p><h2 id="use-strict는-꼭-사용해야-하나"><a href="#use-strict는-꼭-사용해야-하나" class="headerlink" title="use strict는 꼭 사용해야 하나?"></a>use strict는 꼭 사용해야 하나?</h2><p><code>use strict</code>는 꼭 사용할 필요는 없다. 모던 자바스크립트는 ‘클래스’와 ‘모듈’이라 불리는 진일보한 구조를 제공한다. 이 둘을 사용하면 <code>use strict</code>가 자동으로 적용된다. 따라서 이 둘을 사용하고 있다면 스크립트에서 <code>use strict</code>를 붙일 필요가 없다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/26/8.%20javascript/js04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코드 구조</title>
      <link>http://gojaebeom.github.io/2020/07/25/8.%20javascript/js03/</link>
      <guid>http://gojaebeom.github.io/2020/07/25/8.%20javascript/js03/</guid>
      <pubDate>Sat, 25 Jul 2020 05:15:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;본격적으로 자바스크립트 문법에 대해 알아보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>본격적으로 자바스크립트 문법에 대해 알아보자.</p><a id="more"></a><h2 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h2><p>문은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미한다. 코드엔 원하는 만큼 문을 작성할 수 있다. 이때, 서로 다른 문은 세미콜론으로 구분한다.</p><p>아래 코드는 ‘Hello World’를 두 개의 alert 문으로 나눈 예시 이다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">'hello'</span>); alert(<span class="hljs-string">'World'</span>);<br></code></pre></td></tr></table></figure><p>코드의 가독성을 높이기 위해 각 문은 서로 다른 줄에 작성하는 것이 일반적이다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">'Hello'</span>);<br>alert(<span class="hljs-string">'World'</span>);<br></code></pre></td></tr></table></figure><h2 id="세미콜론-semicolon"><a href="#세미콜론-semicolon" class="headerlink" title="세미콜론(semicolon)"></a>세미콜론(semicolon)</h2><p>줄 바꿈이 있다면 세미콜론은 생략할 수 있다.<br>아래 코드는 에러 없이 동작한다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">'Hello'</span>)<br>alert(<span class="hljs-string">'Hello'</span>)<br></code></pre></td></tr></table></figure><p>자바스크립트는 줄 바꿈이 있으면 이를 ‘암시적’ 세미콜론으로 해석한다. 이런 동작 방식을 ‘세미콜론 자동 삽입(automatic semicolon insertion)’ 이라 부른다.</p><p>아래와 같이 줄 바꿈이 세미콜론을 의미하지 않는 경우도 있다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-number">3</span> +<br><span class="hljs-number">1</span><br>+ <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>어떤 줄이 “+” 로 끝나면, 그 줄은 ‘불완전한 표현식’ 이므로 세미콜론이 필요하지 않다는 걸 직감할 수 있다. </p><p>반면, 세미콜론이 정말로 필요하지만 자바스크립트가 이를 추정하지 못하는 상황도 존재한다.</p><h3 id="에러-예제-🚨"><a href="#에러-예제-🚨" class="headerlink" title="에러 예제 🚨"></a>에러 예제 🚨</h3><p>자바스크립트가 세미콜론을 자동으로 삽입해주지 못하는 구체적인 상황은 다음과 같다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].forEach(alert)<br></code></pre></td></tr></table></figure><p>지금은 대괄호 ‘[]’와 <code>forEach</code>는 아직 배우지 않았으므로, 깊이 생각하지 말고 코드를 살펴보자. 이들에 대해선 추후에 학습할 예정이다. 코드를 실행하면 결과가 1과 2가 출력된다는 사실만 기억하자. </p><p>이제 위에서 작성한 코드 앞쪽에 세미콜론을 붙이지 않은 채 <code>alert</code>를 추가해 보자.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">"에러가 발생합니다."</span>)<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].forEach(alert)<br></code></pre></td></tr></table></figure><p>예제를 실행해 보면 새롭게 추가한 <code>alert</code>만 제대로 출력되고 에러가 발생하는 걸 확인할 수 있다. <code>alert</code> 끝에 세미콜론을 추가해 다시 실행하면 코드는 잘 작동한다.</p><p>세미콜론이 없을 때 에러가 발생했던 이유는 자바스크립트가 대괄호 ‘[…]’ 앞에는 세미콜론이 있다고 가정하지 않기 때문이다. 따라서 세미콜론 자동 삽입이 일어나지 않고 첫 번째 예제는 단일 문으로 처리된다. 자바스크립트 엔진이 보게될 코드는 다음과 같다.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">"에러가 발생합니다."</span>)[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].forEach(alert)<br></code></pre></td></tr></table></figure><p>줄 바꿈으로 문을 나눴더라도, 문 사이엔 세미콜론을 넣는 것이 좋다. 자바스크립트 커뮤니티에서도 이를 규칙으로 정해 권장하고 있다.</p><h2 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h2><p>프로그램을 할땐 코드에 대한 설명을 해주는 ‘주석(comment)’이 필요할 때가 있다. 주석은 어느 곳에나 작성할 수 있다.</p><p><strong>한 줄짜리 주석</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//알림창이 뜨는 코드</span><br>alert(<span class="hljs-string">'Hello World'</span>);<br></code></pre></td></tr></table></figure><p><strong>여러 줄의 주석</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 알림창이 뜨는 코드</span><br><span class="hljs-comment">*/</span><br>alert(<span class="hljs-string">'Hello World'</span>);<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/25/8.%20javascript/js03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트 기초</title>
      <link>http://gojaebeom.github.io/2020/07/24/8.%20javascript/js02/</link>
      <guid>http://gojaebeom.github.io/2020/07/24/8.%20javascript/js02/</guid>
      <pubDate>Fri, 24 Jul 2020 05:15:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트를 실행할 수 있는 환경은 보통 브라우저다. Node.js를 사용하면 로컬 환경에서 자바스크립트를 실행할 수 있지만, 먼저 브라우저를 통해 학습을 진행하도록 하겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트를 실행할 수 있는 환경은 보통 브라우저다. Node.js를 사용하면 로컬 환경에서 자바스크립트를 실행할 수 있지만, 먼저 브라우저를 통해 학습을 진행하도록 하겠다.</p><a id="more"></a><h2 id="‘script’-태그"><a href="#‘script’-태그" class="headerlink" title="‘script’ 태그"></a>‘script’ 태그</h2><p><code>&lt;script&gt;</code> 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 어느 곳에나 삽입할 수 있다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello js!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">    alert( <span class="hljs-string">'Hello, world!'</span> );</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;script&gt;</code> 태그엔 몇 가지 속성(attribute)가 있다.<br><strong>type 속성</strong><br>HTML4에선 type을 명시하는 것이 필수였다. 따라서 <code>type=&quot;text/javascript&quot;</code> 속성이 붙은 스크립트를 붙여서 표시했다. 이젠 타입 명시가 필수가 아니다. 게다가 모던 HTML 표준에선 이 속성의 의미가 바뀌었다. 이제 이 속성은 자바스크립트 모듈에 사용할 수 있다. 모듈은 다른 파트에서 다루겠다.</p><p><strong>language 속성</strong><br>이 속성은 현재 사용하고 있는 스크립트 언어를 나타낸다. 지금은 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색된 상황이다. 더는 사용할 필요가 없다.</p><h2 id="외부-스크립트"><a href="#외부-스크립트" class="headerlink" title="외부 스크립트"></a>외부 스크립트</h2><p>자바스크립트 코드의 양이 많은 경우엔, <code>src</code> 속성을 통해 파일로 소분하여 저장할 수 있다. </p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>복수의 스크립트를 HTML에 삽입하고 싶다면 스크립트 태그를 여러 개 사용하면 된다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app1.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app2.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>주의 🚨</strong><br>HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용한다. 스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋다. </p><p>스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 ‘캐시(cache)’에 저장하기 때문에, 성능상의 이점이 있다.</p><p>그리고 <code>&lt;script&gt;</code> 태그는 <code>src</code> 속성과 내부 코드를 동시에 가지지 못한다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello!"</span>) <span class="hljs-comment">// src 속성이 사용되었으므로 이 코드는 무시된다.</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/24/8.%20javascript/js02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트란?</title>
      <link>http://gojaebeom.github.io/2020/07/23/8.%20javascript/js01/</link>
      <guid>http://gojaebeom.github.io/2020/07/23/8.%20javascript/js01/</guid>
      <pubDate>Thu, 23 Jul 2020 05:15:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트는 웹페이지에 생동감을 넣기 위해 만들어진 프로그래밍 언어이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트는 웹페이지에 생동감을 넣기 위해 만들어진 프로그래밍 언어이다.</p><a id="more"></a><p>스크립트는 특별한 준비나 컴파일 없이 보통의 문자 형태로 작성할 수 있고, 실행도 할 수 있다. 이런 관점에서 자바스크립트는 자바와 매우 다른 언어라고 할 수 있다.</p><h2 id="왜-자바스크립트인가"><a href="#왜-자바스크립트인가" class="headerlink" title="왜 자바스크립트인가?"></a>왜 자바스크립트인가?</h2><p>초기 자바스크립트의 이름은 <code>LiveScript</code>였다. 당시 자바의 인기가 높은 상황이여서 관련인들은 LiveSciprt를 자바의 ‘동생’ 격인 언어로 홍보하면 도움이 될 것이라는 의사결정을 내리고 이름을 바꿨다.</p><p>결국 자바스크립트는 자바와는 독자적인 언어이다. 꾸준한 발전을 거듭하여 ECMASciprt라는 명세를 갖춘 언어가 되었다.</p><h2 id="자바스크립트-엔진"><a href="#자바스크립트-엔진" class="headerlink" title="자바스크립트 엔진"></a>자바스크립트 엔진</h2><p>자바스크립트는 브라우저뿐만 아니라 서버에서도 실행할 수 있다. 이 외에도 ‘자바스크립트 엔진’이라 불리는 특별한 프로그램이 들어 있는 모든 디바이스에서도 동작한다.</p><p>그리고 브라우저엔 ‘자바스크립트 가상 머신’이라 불리는 엔진이 내장되어 있다. 엔진의 종류는 다음과 같다.</p><ul><li>V8 : 크롬, 오페라</li><li>SpiderMonkey : Firefox</li><li>IE는 버전에 따라 ‘Trident’, ‘Chakra’라 불리는 엔진을 사용</li></ul><h2 id="엔진의-동작"><a href="#엔진의-동작" class="headerlink" title="엔진의 동작"></a>엔진의 동작</h2><p>기본적인 원리는 다음과 같다. </p><ol><li>브라우저 내장 엔진이 스크립트를 읽는다(파싱).</li><li>읽어 들인 스크립트를 기계어로 전환한다(컴파일).</li><li>기계어로 전환된 코드가 실행된다.</li></ol><h2 id="브라우저에서-할-수-있는-일"><a href="#브라우저에서-할-수-있는-일" class="headerlink" title="브라우저에서 할 수 있는 일"></a>브라우저에서 할 수 있는 일</h2><ul><li>페이지에 새로운 HTML을 추가하거나 기존 HTML, 혹은 스타일 수정하기</li><li>마우스 클릭이나 포인터의 움직임, 키보드 키 눌림 등과 같은 사용자 행동에 반응하기</li><li>네트워크를 통해 원격 서버에 요청을 보내거나, 파일 다운로드, 업로드하기(AJAX나 COMET과 같은 기술 사용)</li><li>쿠키를 가져오거나 설정하기. 사용자에게 질문을 건네거나 메시지 보여주기</li><li>클라이언트 측에 데이터 저장하기(로컬 스토리지)</li></ul><h2 id="자바스크립트의-강점"><a href="#자바스크립트의-강점" class="headerlink" title="자바스크립트의 강점"></a>자바스크립트의 강점</h2><ul><li>HTML/CSS와 완전히 통합할 수 있음</li><li>간단한 일은 간단하게 처리할 수 있게 해줌</li><li>모든 주요 브라우저에서 지원하고, 기본 언어로 사용됨</li></ul><h2 id="자바스크립트-‘너머의’-언어들"><a href="#자바스크립트-‘너머의’-언어들" class="headerlink" title="자바스크립트 ‘너머의’ 언어들"></a>자바스크립트 ‘너머의’ 언어들</h2><p>자바스크립트 문법은 모든 사람의 요구를 충족시키진 못한다. 사람마다 각기 다른 기능을 원하기 때문이다. </p><p>자바스크립트로 트랜스파일이 가능한 언어 몇가지</p><ul><li>CoffeeScript : 짧은 문법을 도입하여 명료하고 이해하기 쉬운 코드를 작성할 수 있다. Ruby 개발자들이 좋아한다.</li><li>TypeScript : 개발을 단순화 하고 복잡한 시스템을 지원하려는 목적으로 ‘자료형의 명시화’에 집중해 만든 언어. Microsoft에서 개발함.</li><li>Flow : TypeScript와 같이 자료형을 강제하는데 다른 방식을 사용한다. Facebook이 개발함.</li><li>Dart는 모바일 앱과 같이 브라우저가 아닌 환경에서 동작하는 고유의 엔진을 가진 독자적 언어이다. Google이 개발함. </li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/23/8.%20javascript/js01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring MVC - JDBC과 Mybatis 연결</title>
      <link>http://gojaebeom.github.io/2020/07/02/7.%20spring/spring07/</link>
      <guid>http://gojaebeom.github.io/2020/07/02/7.%20spring/spring07/</guid>
      <pubDate>Wed, 01 Jul 2020 18:39:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 글에서 스프링 프로젝트의 가장 기본이 되는 설정을 하였다. 이 후 클라이언트에서 넘어오는 데이터 저장에 대한 처리를 위해 데이터베이스를 프로젝트에 연결해 주어야 하는데, 이번 프로젝트에선 데이터베이스로 &lt;code&gt;MYSQL&lt;/code&gt;을 사용할 예정이다. 그리고 데이터베이스 저장 작업을 쉽게 하기위한 프레임워크인 &lt;code&gt;Mybatis&lt;/code&gt;도 함께 사용하도록 하겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이전 글에서 스프링 프로젝트의 가장 기본이 되는 설정을 하였다. 이 후 클라이언트에서 넘어오는 데이터 저장에 대한 처리를 위해 데이터베이스를 프로젝트에 연결해 주어야 하는데, 이번 프로젝트에선 데이터베이스로 <code>MYSQL</code>을 사용할 예정이다. 그리고 데이터베이스 저장 작업을 쉽게 하기위한 프레임워크인 <code>Mybatis</code>도 함께 사용하도록 하겠다.</p><a id="more"></a><h2 id="작업-순서"><a href="#작업-순서" class="headerlink" title="작업 순서"></a>작업 순서</h2><p>스프링 웹 프로젝트에 db를 연결하는 방법은 다음과 같다.</p><ol><li>pom.xml에 db관련 디펜던시 설정<ul><li>jdbc를 보다 쉽게 사용할 수 있게 spring에서 제공하는 spring-jdbc 디펜던시 적용</li><li>커넥션 풀을 사용할 수 있는 commons-dbcp 디펜던시 적용</li><li>jdbc에 연결할 mysql 커넥터 적용</li><li>sql을 java 파일과 분리시키고 보다 편리하게 쿼리 작성을 할 수 있는 mybatis 적용</li></ul></li><li>web.xml에 디스패처 서블릿이 실행되기 이전 웹과 관련없는 빈들을 설정할 root-context.xml의 경로 설정</li><li>root-context.xml에 jdbc, mybatis 설정</li><li>jdbc.properties 파일을 별도로 분리해 db관련 정보를 저장해준다.(git에 올리거나, 공유시 보안을 위함)</li></ol><h2 id="db관련-디펜던시"><a href="#db관련-디펜던시" class="headerlink" title="db관련 디펜던시"></a>db관련 디펜던시</h2><p><strong>pom.xml</strong></p><script src="https://gist.github.com/gojaebeom/95c0a05d6146baeeb7241e44590cc1d7.js"></script><h2 id="root-context-xml-경로-설정"><a href="#root-context-xml-경로-설정" class="headerlink" title="root-context.xml 경로 설정"></a>root-context.xml 경로 설정</h2><p><strong>web.xml</strong></p><script src="https://gist.github.com/gojaebeom/b2ad43856dd2969f9166faf49cf3d247.js"></script><h2 id="root-context-xml-설정"><a href="#root-context-xml-설정" class="headerlink" title="root-context.xml 설정"></a>root-context.xml 설정</h2><p><strong>root-context.xml</strong></p><script src="https://gist.github.com/gojaebeom/3aba147670e708d4dfe29f3eed231759.js"></script><h2 id="jdbc-properties-설정"><a href="#jdbc-properties-설정" class="headerlink" title="jdbc.properties 설정"></a>jdbc.properties 설정</h2><p><strong>jdbc.properties</strong></p><script src="https://gist.github.com/gojaebeom/2f16fc09e7235f76702fc77ab6aefa1e.js"></script><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/02/7.%20spring/spring07/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring MVC - 프로젝트 생성, 설정</title>
      <link>http://gojaebeom.github.io/2020/07/01/7.%20spring/spring06/</link>
      <guid>http://gojaebeom.github.io/2020/07/01/7.%20spring/spring06/</guid>
      <pubDate>Tue, 30 Jun 2020 18:39:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바 웹 프로그램을 만들때 자주 사용되는 빌드 툴은 maven이라고 할 수 있다. (물론 gradle도 많이 사용된다고는 한다)&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바 웹 프로그램을 만들때 자주 사용되는 빌드 툴은 maven이라고 할 수 있다. (물론 gradle도 많이 사용된다고는 한다)</p><a id="more"></a><p>글쓴이는 스프링 웹 프로젝트를 만들때 메이븐을 이용하여 spring mvc 프로젝트를 진행해 보려고 한다. 순서는 다음과 같다.</p><ol><li>maven 프로젝트 생성</li><li>spring mvc 를 사용하기 위한 dependency 설정</li><li>web.xml을 통해 dispatcher servlet 설정</li><li>그 외 웹과 관련없는 bean들을 설정할 root-context 설정</li><li>기본적인 틀만 만들어놓고 톰캣에 배포해보기(물론 이클립스의 도움으로 이클립스 톰캣으로 실행)</li></ol><p>이번 글에선 단순히 spring mvc 프로젝트를 만들기 위한 프로젝트의 셋팅만 다루어 보겠다.</p><h2 id="mvc를-위한-pom-설정"><a href="#mvc를-위한-pom-설정" class="headerlink" title="mvc를 위한 pom 설정"></a>mvc를 위한 pom 설정</h2><p>먼저 생성된 maven 프로젝트의 pom.xml의 최소한의 설정은 다음과 같이 하면 된다.</p><p><strong>pom.xml</strong></p><script src="https://gist.github.com/gojaebeom/f67a1022893a56233f33450f9c851a28.js"></script><p>Spring-context는 스프링 프레임워크를 사용하기 위한 핵심이다. 내부적으로 스프링 core, bean, aop, context, logging 등을 포함하고 있다.</p><p>spring-mvc는 말 그대로 spring mvc 프로젝트를 할 수 있게 도와주는 디펜던시다. </p><p>설정이후 이클립스 툴을 쓰고있다면 프로젝트에 에러가 날것이다. 원인은 여러가지가 있는데, 패키징 타입을 war로 하였기때문에 webapp 폴더 하위에 WEB-INF가 존재하고 web.xml을 가지고 있는 형태가 완성되야 war 패키징 타입을 만족하기 때문이다. webapp 폴더 하위에 아무것도 안만들어져 있다면 WEB-INF/web.xml 을 만들어주자.</p><h2 id="web-xml-설정"><a href="#web-xml-설정" class="headerlink" title="web.xml 설정"></a>web.xml 설정</h2><p>웹 프로젝트를 실행하기 위해 본 프로젝트를 톰캣을 이용하여 실행할 텐데, 톰캣은 프로젝트에 WEB-INF 폴더 하위에 존재하는 web.xml 파일을 읽어 프로그램을 실행하게 된다.</p><p><strong>web.xml</strong></p><script src="https://gist.github.com/gojaebeom/da5b773e4fb8f884cded4c8a349115ed.js"></script><p>물론 위의 코드는 최소한의 설정이다. 톰캣에게 디스페처 서블릿 클래스의 위치를 알려주고 톰캣은 그것을 실행시키는데, 이전의 서블릿 프로젝트는 하나의 서블릿에 한 페이지를 만들었다. 그 결과 서블릿의 수가 상당히 많아지게 되었는데, 스프링 mvc에서는 dispatcher servlet이 오는 모든 요청을 받아 각 컨트롤러의 맞는 url로 분기시키는 작업을 한다.</p><h2 id="컨트롤러-뷰-설정"><a href="#컨트롤러-뷰-설정" class="headerlink" title="컨트롤러 , 뷰 설정"></a>컨트롤러 , 뷰 설정</h2><p><strong>servlet-context.xml</strong></p><script src="https://gist.github.com/gojaebeom/704eef7c78dfab38ac9ef41894b4d961.js"></script><p>view와 관련된 파일을 어디 폴더에 둘지, 컴포너트를 스캔할 패키지는 어떤건지 작성해준다.</p><p><strong>HomeController</strong></p><script src="https://gist.github.com/gojaebeom/2f142dc819d5948c9bff8123e136805a.js"></script><p>servlet-context.xml 에서 명시해준 패키지에 해당 클래스를 만들어준다. Controller 어노테이션은 Component 어노테이션을 포함하고 있기때문에 해당 어노테이션을 가지는 클래스를 컨트롤러 클래스로 인식하게 된다. 그리고 각 메서드에 매핑된 url로 요청이 오면 return 값인 이름의 jsp 파일로 응답해준다.</p><p><strong>home.jsp</strong></p><script src="https://gist.github.com/gojaebeom/3213325d3be849fcf90349ca80048d8a.js"></script><p>프로그램이 잘 작동하는지 보여주기 위해 간단히 작성한다. </p><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>최근 게시판 프로젝트 만드는데 열중하다보니, 만든 프로젝트를 다시 설명하면서 다루는게 보통일이 아닌것 같다,,</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/07/01/7.%20spring/spring06/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Annotation으로 Bean 등록하기</title>
      <link>http://gojaebeom.github.io/2020/06/25/7.%20spring/spring05/</link>
      <guid>http://gojaebeom.github.io/2020/06/25/7.%20spring/spring05/</guid>
      <pubDate>Wed, 24 Jun 2020 18:39:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;어노테이션으로 스프링 빈들을 관리할 경우 &lt;code&gt;@ComponentScan&lt;/code&gt; 을 지정한 클래스에서 관리를 할 수 있지만, 먼저 이전에 다루었던 xml 파일에서 하나씩 어노테이션으로 바꾸면서 알아가 보도록 하겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>어노테이션으로 스프링 빈들을 관리할 경우 <code>@ComponentScan</code> 을 지정한 클래스에서 관리를 할 수 있지만, 먼저 이전에 다루었던 xml 파일에서 하나씩 어노테이션으로 바꾸면서 알아가 보도록 하겠다.</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Exam exam = new Exam();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.entity.Exam"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 오버로드 생성자를 통해 주입 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"30"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"40"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><br>  <span class="hljs-comment">&lt;!-- ExamConsole console = new InlinExamConsole();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xml.spring.di.ui.InlineExamConsole"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 오버로드 생성자를 통해 주입 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"exam"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이전의 xml 파일 내용이다. 먼저 Exam객체에서 일반 자료형의 값을 주입 받고 있는데 과감하게 위의 부분은 지우도록 한다. 그리고 다음과 같이 <code>&lt;context:annotation-config/&gt;</code>을 명시해준다. context 네임스페이스를 사용하기 위해선 상단의 빈의 속성에 <code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code>를 명시해 주어야 한다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 등록한 객체들에게 어노테이션이 있는지 확인 하라는 네임스페이스 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Exam exam = new Exam();  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 과목의 점수를 오버로드 생성자로 받는 부분이 사라짐 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.entity.Exam"</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- ExamConsole console = new InlinExamConsole();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xml.spring.di.ui.InlineExamConsole"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 오버로드 생성자를 통해 주입 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"exam"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>각 과목의 점수를 받는 부분이 사라졌다 위의 값은 어떻게 받을 수 있을까?</p><h2 id="Value-어노테이션"><a href="#Value-어노테이션" class="headerlink" title="@Value 어노테이션"></a>@Value 어노테이션</h2><p>Exam.java 파일의 맴버변수들에 <code>value</code> 어노테이션을 통해 위 xml 부분을 대체할 수 있다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-meta">@Value</span>(<span class="hljs-string">"30"</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> kor;<br>  <span class="hljs-meta">@Value</span>(<span class="hljs-string">"40"</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> eng;<br>  <span class="hljs-meta">@Value</span>(<span class="hljs-string">"40"</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> math;<br>  <span class="hljs-meta">@Value</span>(<span class="hljs-string">"40"</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> com;<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Autowired-어노테이션"><a href="#Autowired-어노테이션" class="headerlink" title="@Autowired 어노테이션"></a>@Autowired 어노테이션</h2><ul><li>객제의 의존성 주입을 해주는 어노테이션이다.</li><li>맴버변수, 생성자, setter 모두 명시해 줄 수 있다.</li></ul><p>먼저 xml 파일에서 다시 InlineExamConsole의 생성자로 exam객체를 주입받는 부분을 제거해 준다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 등록한 객체들에게 어노테이션이 있는지 확인 하라는 네임스페이스 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Exam exam = new Exam();  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 과목의 점수를 오버로드 생성자로 받는 부분이 사라짐 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.entity.Exam"</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- ExamConsole console = new InlinExamConsole();  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- exam 객체를 주입받는 오버로드 생성자 부분이 사라짐 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xml.spring.di.ui.InlineExamConsole"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>그리고 다음과 같이 해당 클래스에서 의존성을 주입 받는 생성자, setter, 또는 맴버변수중 <code>@Autowired</code>를 명시해주면 된다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InlineExamConsole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExamConsole</span></span><br><span class="hljs-class"></span>&#123;<br><br>  <span class="hljs-keyword">private</span> Exam exam; <span class="hljs-comment">//맴버변수를 통해 주입</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExamConsole</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExamConsole</span><span class="hljs-params">(Exam exam)</span> <span class="hljs-comment">//오버로드 생성자를 통해 주입</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">this</span>.exam = exam;<br>  &#125;<br><br>  <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//세터를 통해 주입</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExam</span><span class="hljs-params">(Exam exam)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">this</span>.exam = exam;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Component-어노테이션"><a href="#Component-어노테이션" class="headerlink" title="@Component 어노테이션"></a>@Component 어노테이션</h2><p>이제 xml 파일에 남은 등록된 빈들을 모조리 지워주자. 그리고 <code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code> 태그만 정의 해주면 되는데 설명은 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  - 이 페키지 경로에 컴포넌트가 있는지 찾아달라, 있으면 객체화 시키기 </span><br><span class="hljs-comment">  - 만약 해당 컴포넌트를 찾을 경우, 클래스를 읽으면서 Autowired 어노테이션이 붙은</span><br><span class="hljs-comment">    맴버변수또는 생성자 또는 세터를 찾기때문게 굳이 annotation-config 태그를 사용할</span><br><span class="hljs-comment">    필요가 없다.</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"spring.di2.ui, spring.di2.entity"</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>위와 같이 컴포넌트가 존재하는 페키지 경로를 <code>component-scan</code> 태그에 명시해 줄 경우, 해당 패키지에 @Component 어노테이션이 붙은 클래스 파일을 찾고 그 클래스에 있는 어노테이션들을 다 채크하기 때문에 이제 xml 파일에 spring bean 파일을 따로 명시해 주지 않아도 된다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExamConsole</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Console</span></span>&#123;...&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>위와 같이 빈으로 등록할 클래스에 <code>@Component</code>를 붙여주면 된다. 이제 <code>spring bean configuration</code> 파일에는 component-scan에 대한 태그만 등록되어 있고 빈 태그들은 존재하지 않게 되었다. 하지만 bean configuration 파일에서 컴포넌트들이 있는 패키지를 명시하기 때문에 @Component 클래스를 읽을 수 있는 것 이다. 이제 완전히 어노테이션으로만 작성하려면 어떻게 해야할까? </p><p>xml 대신 @ComponentScan을 사용하는 클래스를 만들어주고 해당 클래스에서 스프링 빈들을 생성하고 의존성을 주입할 수 있다.</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>DIConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"spring.di.ui"</span>)<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DIConfig</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Exam <span class="hljs-title">exam</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudyExam();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(DIConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>    <br>    ExamConsole console = context.getBean(ExamConsole<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>    <br>    console.print();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>오랜만에 많은 내용을 입력하다보니, 점점 설명하는 글이 줄어들었다..<br>나에게 보여주는 공부 블로그이긴 하지만 혹시 나중에 이글을 보는 사람들에게 너무 부끄러운 글이다.😨</p><p>다음 글에서는 AOP 에 대한 내용을 다루어보도록 하겠다.</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/25/7.%20spring/spring05/#disqus_thread</comments>
    </item>
    
    <item>
      <title>XML으로 Bean 등록하기</title>
      <link>http://gojaebeom.github.io/2020/06/24/7.%20spring/spring04/</link>
      <guid>http://gojaebeom.github.io/2020/06/24/7.%20spring/spring04/</guid>
      <pubDate>Wed, 24 Jun 2020 14:27:00 GMT</pubDate>
      <description>
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;  &lt;/span&gt;&amp;#123;&lt;br&gt;    Exam exam = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Exam(&lt;span class=&quot;hljs-number&quot;&gt;90&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//국어, 영어, 수학, 컴퓨터 점수를 받는다.&lt;/span&gt;&lt;br&gt;&lt;br&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//Console 인터페이스를 InlineExamConsole 클래스가 구현받음 : 다형성&lt;/span&gt;&lt;br&gt;    ExamConsole console = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; InlineExamConsole(exam);&lt;span class=&quot;hljs-comment&quot;&gt;//exam 객체를 받아 점수의 총점과 평균을 inline으로 출력한다.&lt;/span&gt;&lt;br&gt;  &amp;#125;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위 예제는 시험점수 객체에 값을 넣고 시험점수 출력 객체에 주입하는 코드의 일부분이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">  </span>&#123;<br>    Exam exam = <span class="hljs-keyword">new</span> Exam(<span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>);<span class="hljs-comment">//국어, 영어, 수학, 컴퓨터 점수를 받는다.</span><br><br>    <span class="hljs-comment">//Console 인터페이스를 InlineExamConsole 클래스가 구현받음 : 다형성</span><br>    ExamConsole console = <span class="hljs-keyword">new</span> InlineExamConsole(exam);<span class="hljs-comment">//exam 객체를 받아 점수의 총점과 평균을 inline으로 출력한다.</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 예제는 시험점수 객체에 값을 넣고 시험점수 출력 객체에 주입하는 코드의 일부분이다.</p><a id="more"></a><p>위 Exam 객체와 InlineExamConsole 객체를 스프링 빈에 등록한다고 하면, 먼저 <code>spring bean configuration xml</code> 파일을 만들어주고 그곳에 등록해주면 된다.</p><h2 id="configuration-xml-형식"><a href="#configuration-xml-형식" class="headerlink" title="configuration xml 형식"></a>configuration xml 형식</h2><p>이클립스에서 관련 모듈들을 설치했다면 <code>spring bean configuration</code> 파일을 통해서 다음과 같은 파일을 만들 수 있지만, 아니라면 일반 xml 파일에 위 내용을 붙여 넣어도 된다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>기본 형식인 bean은 이와 같은 모습이다. 여기에 Exam과 InlineExamConsole 객체를 등록하겠다.</p><h2 id="spring-binz-등록하기"><a href="#spring-binz-등록하기" class="headerlink" title="spring binz 등록하기"></a>spring binz 등록하기</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Exam exam = new Exam();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.entity.Exam"</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- ExamConsole console = new InlineExamConsole();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.ui.InlineExamConsole"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>위와 같이 bean 태그로 id 값과 class 값을 적어준다. </p><ul><li>id는 xml파일 내부에서 참조변수명과 같이 사용된다.</li><li>class는 생성할 객체의 클래스명을 적으면 되는데, 정확하게 구분하기 위해 패키지명까지 적어주어야 한다.</li></ul><h2 id="의존성-주입하기"><a href="#의존성-주입하기" class="headerlink" title="의존성 주입하기"></a>의존성 주입하기</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Exam exam = <span class="hljs-keyword">new</span> Exam(<span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>);<br>Console console = <span class="hljs-keyword">new</span> InlineExamConsole(exam);<br></code></pre></td></tr></table></figure><p>main 메서드에서 Exam 객체를 생성하고 오버로드 생성자를 통해 값들을 입력 받는다. 그후 InlineExamConsole 객체에게 오버로드 생성자를 통해 Exam 객체를 주입해주고 있는 부분이다. 다음과 같은 코드를 xml로 구현해보자.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Exam exam = new Exam();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spring.di.entity.Exam"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 오버로드 생성자를 통해 주입 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"30"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"40"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><br>  <span class="hljs-comment">&lt;!-- ExamConsole console = new InlinExamConsole();  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xml.spring.di.ui.InlineExamConsole"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 오버로드 생성자를 통해 주입 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"exam"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="생성자로-주입하기"><a href="#생성자로-주입하기" class="headerlink" title="생성자로 주입하기"></a>생성자로 주입하기</h3><ul><li>bean 파일의 닫는 태그를 분리하여 내부에 <code>constructor-arg</code> 태그를 생성했다. </li><li>constructor-arg는 오버로드 생성자의 매개변수를 지정한다.</li><li>constructor-arg 1개당 매개변수 1개를 의미한다.</li><li>constructor-arg 의 속성으로 <code>name</code>, <code>index</code>, <code>value</code>, <code>ref</code> 등이 있다.<ul><li>name : 매개변수명으로 연결(기존의 변수명과 동일해야함)</li><li>index : 매개변수의 순서, 앞에서 부터 0, 1, 2 .. </li><li>value : 일반 자료형이 들어갈 경우 value 속성으로 값을 입력 받는다.</li><li>ref : 참조 자료형을 받을 경우 ref 속성으로 값을 입력 받는다.</li></ul></li></ul><p>위 코드는 생성자로 의존성을 주입받고 있지만, setter 메서드로도 의존성 주입이 가능하다. </p><h3 id="setter로-주입하기"><a href="#setter로-주입하기" class="headerlink" title="setter로 주입하기"></a>setter로 주입하기</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"console"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xml.spring.di.ui.ExamConsole"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exam"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"exam"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>property</code> 태그는 setter 메서드와 동일 하다.</li><li>당연하지만 실제 객체에 해당하는 값을 받는 setter가 정의 되어 있어야 한다.</li><li>일종의 규칙이 있는데 setter 메서드명이 <code>setExam</code> 과 같은 형식이라면 앞에 set을 제외하고 앞의 문자를 소문자로 바꾼다. </li><li>받는 타입은 생성자와 똑같이 기본 자료형일 경우 value, 참조형일 경우 ref로 받으면 된다.</li></ul><h2 id="xml-불러오기"><a href="#xml-불러오기" class="headerlink" title="xml 불러오기"></a>xml 불러오기</h2><p>빈의 설정이 끝났으니 main 메서드에서 이제 코드가 어떻게 바뀔지 예상해보자. </p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"spring/di/setting1.xml"</span>);<br><br>    <span class="hljs-comment">// bean의 id 값으로 참조 (타입캐스팅 해주어야함)</span><br>    ExamConsole console = (ExamConsole) context.getBean(<span class="hljs-string">"console"</span>);<br><br>    <span class="hljs-comment">// 위의 방법 또는 클래스타입으로 받을 수 있다.</span><br>    ExamConsole console = context.getBean(ExamConsole<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>    console.print();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>놀라운 점은 두번째 방법으로 생성된 빈을 받을 경우 실제 받는 객체는 <code>InlineExamConsole</code> 이지만 보다시피 참조변수와 클래스타입은 ExamConsole.class 라고 되어 있다. 즉 xml에서 <code>ExamConsole</code> 인터페이스를 구현하는 클래스를 바꿔 주기만 하면 main 메서드에서는 수정할 필요 없이 구현 클래스를 분리, 조립이 가능한 것 이다.</p><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>이 밖에도 configuration xml을 다루는 설정들이 더 많지만, 이정도만 알아도(?) 기본적인 설정은 할 수 있을 것 같다.(몇개 더 알고 있지만 작성하지 않는 것도 있다😅)</p><p>다음 글에서는 어노테이션 방식으로 스프링 빈을 관리하는 방법을 알아보겠다.</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/24/7.%20spring/spring04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>스프링 빈(Bean)</title>
      <link>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring03/</link>
      <guid>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring03/</guid>
      <pubDate>Tue, 23 Jun 2020 14:27:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 글에서 IOC와 DI의 개념을 이해하기 위해 main 메서드에서 테스트를 진행하였다. 이번 글에서 다루어 볼 내용은 제어의 역전을 스프링에게 직접 맡기는 것이다. 스프링의 IOC 컨테이너는 스프링 빈으로 등록된 객체들의 생명주기를 관리한다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이전 글에서 IOC와 DI의 개념을 이해하기 위해 main 메서드에서 테스트를 진행하였다. 이번 글에서 다루어 볼 내용은 제어의 역전을 스프링에게 직접 맡기는 것이다. 스프링의 IOC 컨테이너는 스프링 빈으로 등록된 객체들의 생명주기를 관리한다. </p><a id="more"></a><h2 id="스프링-빈이란"><a href="#스프링-빈이란" class="headerlink" title="스프링 빈이란?"></a>스프링 빈이란?</h2><p>Spring IOC 컨테이너가 관리하는 자바 객체를 빈(Bean) 이라는 용어로 부른다.</p><h2 id="IOC-Container"><a href="#IOC-Container" class="headerlink" title="IOC Container"></a>IOC Container</h2><p>실제로 스프링 컨테이너는 IOC 컨테이너를 가지고 있고, 이곳에서 등록된 Bean들의 의존성을 주입하는등 생명주기를 관리한다. 그렇다면 어떻게 제어역전 컨테이너에게 빈을 등록할까? </p><p>방법은 크게 두가지가 있다.</p><ul><li>spring bean configuration xml 파일에 직접 등록</li><li>Compnent Scanning 어노테이션을 활용한 annotation 등록</li></ul><p>그리고 xml형식으로 빈을 등록할 경우 annotation을 섞어서 활용할 수도 있다.</p><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>등록하는 예제도 다루어 보려고 했지만 너무 피곤하여 내일 다른 포스트로 이어서 쓰도록 하겠다..😓</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>제어역전과 의존성 주입</title>
      <link>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring02/</link>
      <guid>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring02/</guid>
      <pubDate>Tue, 23 Jun 2020 12:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;먼저 제어의 역전과 의존성 주입을 설명하기 전에 객체간의 결합도에 대해 다루어보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>먼저 제어의 역전과 의존성 주입을 설명하기 전에 객체간의 결합도에 대해 다루어보겠다.</p><a id="more"></a><h2 id="인터페이스와-느슨한-결합"><a href="#인터페이스와-느슨한-결합" class="headerlink" title="인터페이스와 느슨한 결합"></a>인터페이스와 느슨한 결합</h2><p>프로그램을 만들다보니 A 클래스와 B 클래스가 생성이 되었다. 프로그램을 만든다는건 수정이 동반되는 작업이 될 수도 있다. A 클래스에서 B클래스를 사용한다고 했을때, B 클래스의 수정이 필요한 시점이 오면 어떻게 해야할까?</p><p>B 클래스를 직접 수정하거나 B 클래스를 대신할 B2 클래스를 만들어 B 대신 사용하게 할 수 있을 것 이다. 직접 수정하는 방법은 제외 하고 B2 클래스를 새로 만들어 대신 조립하는 것을 예제로 보자.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-comment">//B b = new B();</span><br><span class="hljs-comment">//위 코드를 다음과 같이 바꾼다.</span><br><br>B2 b2 = <span class="hljs-keyword">new</span> B2();<br>&#125;<br></code></pre></td></tr></table></figure><p>위의 코드는 수정된 클래스를 대신 사용하기위해 코드를 바꾼 예제이다. 하지만 다음과 같은 상황에서 객체지향의 특징인 다형성을 사용하면 조금 더 깔끔한 구현이 가능할 것 이다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span></span>&#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>B b = <span class="hljs-keyword">new</span> B1();<br><span class="hljs-comment">//or</span><br>B b = <span class="hljs-keyword">new</span> B2();<br><span class="hljs-comment">//or</span><br>B b = <span class="hljs-keyword">new</span> B3();<br>&#125;<br></code></pre></td></tr></table></figure><p>비슷한 특성을 가진 클래스들을 인터페이스를 미리 만들어 구현받도록 하는 것이다. 이 후 사용할 때 인터페이스를 참조변수로 받아 필요한 구현받은 필요한 클래스를 갈아 끼워주면 된다. </p><p>위의 코드는 느슨한 결합의 결과라 할 수는 없다. A 클래스에서 수정을 해야한다는 것은 아직도 불가피하기 때문이다.</p><h2 id="제어의-역전-IOC-Inversion-of-control"><a href="#제어의-역전-IOC-Inversion-of-control" class="headerlink" title="제어의 역전(IOC : Inversion of control)"></a>제어의 역전(IOC : Inversion of control)</h2><p>IOC는 제어 흐름의 개념을 거꾸로 뒤집는 개념이다. </p><ul><li>오브젝트는 자신이 사용할 오브젝트를 스스로 생성하거나 선택하지 않는다.</li><li>모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">private</span> B b;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(B b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>클래스 A는 자신이 직접 B 객체를 생성하지 않는다. 생성자를 통해 외부에서 객체 b를 전달 받아 사용하게 된다. 이처럼 제어의 권한이 다른 곳에 있을때 이를 제어의 역전이라고 말 할 수 있다.</p><h2 id="의존성-주입-DI-Dependency-Injection"><a href="#의존성-주입-DI-Dependency-Injection" class="headerlink" title="의존성 주입(DI: Dependency Injection)"></a>의존성 주입(DI: Dependency Injection)</h2><p>IOC를 만족하기 위해 외부의에서 필요한 부품을 제공을 받아야 한다. 이러한 경우 외부에서 객체를 대신 전달 받을 수 있는데, 이 때 A는 B에 의존적임으로 의존성을 주입한다고 할 수 있다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>B b = <span class="hljs-keyword">new</span> B1(); <span class="hljs-function">or <span class="hljs-title">B2</span><span class="hljs-params">()</span></span>; <span class="hljs-function">or <span class="hljs-title">B3</span><span class="hljs-params">()</span></span>;<br>A a = <span class="hljs-keyword">new</span> A(b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>의존성을 주입하는 것은 꼭 생성자를 통해 주입하는 것만은 아니다. 방법에 따라 의존성을 주입하는 방법은 다를 수 있다.</p><h3 id="생성자를-통한-의존성-주입"><a href="#생성자를-통한-의존성-주입" class="headerlink" title="생성자를 통한 의존성 주입"></a>생성자를 통한 의존성 주입</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">B b = <span class="hljs-keyword">new</span> B1();<br>A a = <span class="hljs-keyword">new</span> A(b);<br></code></pre></td></tr></table></figure><h3 id="setter-메서드를-통한-의존성-주입"><a href="#setter-메서드를-통한-의존성-주입" class="headerlink" title="setter 메서드를 통한 의존성 주입"></a>setter 메서드를 통한 의존성 주입</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">B b = <span class="hljs-keyword">new</span> B2();<br>A a = <span class="hljs-keyword">new</span> A();<br>a.setB(b);<br></code></pre></td></tr></table></figure><p>두 방법 모두 가능하며 상황에 맞게 사용하면 될 것 같다.</p><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>예제를 다루기 위해 main 메서드에서 테스트 하였는데, 실제로 스프링 프레임워크를 사용하게 되면 사용하고자 하는 의존성의 제어를 main 메서드가 아닌 IOC 컨테이너에서 처리하며, 또한 그곳에서 의존성을 주입받아 실제 작성하는 소스코드는 클래스간에 수정이 필요할 때 줄줄이 수정하는 지옥에서 해방될 수 있다고 한다.✨</p><p>다음 글에서 스프링 프레임워크를 활용하여 IOC와 DI를 활용하도록 하겠다.</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/23/7.%20spring/spring02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring 소개</title>
      <link>http://gojaebeom.github.io/2020/06/22/7.%20spring/spring01/</link>
      <guid>http://gojaebeom.github.io/2020/06/22/7.%20spring/spring01/</guid>
      <pubDate>Mon, 22 Jun 2020 14:27:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;스프링은 로드 존슨(Rod Johnson)이 만든 오픈소스 프로그램이다. 로드 존슨은 자신의 Java 개발 경험과 노하우를 기반으로 출판한 책(Expert One one One J2EE Edsign and Development)에 샘플 프레임워크를 만들어 실었다. 이 코드가 차후 스프링이라는 자바 표준 프레임워크로 발전하였다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>스프링은 로드 존슨(Rod Johnson)이 만든 오픈소스 프로그램이다. 로드 존슨은 자신의 Java 개발 경험과 노하우를 기반으로 출판한 책(Expert One one One J2EE Edsign and Development)에 샘플 프레임워크를 만들어 실었다. 이 코드가 차후 스프링이라는 자바 표준 프레임워크로 발전하였다.</p><a id="more"></a><h2 id="스프링-Spring-이란"><a href="#스프링-Spring-이란" class="headerlink" title="스프링(Spring)이란?"></a>스프링(Spring)이란?</h2><p><u>스프링은 제어역전을 지원하는 경량의 관점지향 컨테이너 프레임워크다.💥</u></p><p>스프링의 주 목적은 쉽게 자바 엔터프라이즈 에디션(Java EE : Java Enterprise Edition)을 개발하는 것이며, <code>POJO</code> 기반의 프로그래밍 모델이 그것을 가능하게 한다.</p><p><code>POJO (Plain Old Java Object)</code> 란 평범한 자바 객체라는 의미이다. 이 객체를 사용하기 위해서 상속,  인터페이스, 어노테이션등을 적용해야  하는 제약조건이 없는 객체라는 뜻이다.</p><h2 id="스프링의-주요-특징"><a href="#스프링의-주요-특징" class="headerlink" title="스프링의 주요 특징"></a>스프링의 주요 특징</h2><ul><li>경량화 : 스프링 프레임워크는 사이즈와 투명성(자유롭게 가져다 쓸 수 있는) 측면에서 경량 프레임워크다.</li><li>비침투성: 비침투성이란 도메인 로직 코드가 프레임워크에 의존적이지 않음을 의미한다.</li><li>제어역전: 스프링 컨테이너는 스프링 빈즈와 그들의 생명주기를 관리한다. 제어역전 컨테이너는 주입을 지원하는 스프링 프레임워크의 핵심 컨테이너이다.<ul><li>의존성 주입: 인스턴스화 작업을 위임해 수행하는 과정이다.</li></ul></li><li>관점지향 프로그래밍(AOP : Aspect-oriented Programming) : 메인 프로그램의 비즈니스 로직 기능과 지원 기능을 분리하는 프로그래밍 패러다임이다. 개발자는 추가적인 요구사항을 의식하지 않고 시스템의 핵심 기능 개발에 집중한다.</li><li>JDBC 예외 처리 : 스프링 프레임워크의 JDBC 추상 계층은 계층구조의 예외를 제공해 에러 처리를 단축시킨다. 이것은 스프링이 예외 처리를 위해 필요한 판에 박힌 많은 양의 코드를 줄여주는 데 도움을 주는 방법 중 하나다.</li><li>스프링 MVC 프레임워크 : 강력하고 유지보수가 용이한 웹 애플리케이션을 개발하도록 도와준다. 스프링 MVC 프레임워크는 제어역전을 사용해 로직 컨트롤러를 분리시킨다.</li><li>스프링 보안 : 스프링 보안은 스프링 기반 애플리케이션 대다수에서 중요한 부분인 선언적 보안 메커니즘을 제공한다.</li></ul><h2 id="마무리-글"><a href="#마무리-글" class="headerlink" title="마무리 글"></a>마무리 글</h2><p>어려운 내용들이 많이 보이는데, 앞으로 예제를 다루어보면서 차근차근 풀어가도록 하겠다.</p><br><hr style="border:0px; border-bottom:2px dotted #D8D8D8"><p><em>개인적인 공부 내용을 정리하는 것을 목적으로 하고 있습니다.</em><br><em>설명이 부족하거나 틀린 부분은 지적해 주시기 바랍니다.</em> 🐥</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/22/7.%20spring/spring01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>생성부터 배포까지</title>
      <link>http://gojaebeom.github.io/2020/06/18/6.%20maven/maven04/</link>
      <guid>http://gojaebeom.github.io/2020/06/18/6.%20maven/maven04/</guid>
      <pubDate>Thu, 18 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 글에선 maven-quickstart 프로젝트를 생성하여 톰캣에 배포하여 웹을 띄우기까지의 과정을 처음부터 작성하려고 한다. 물론 메이븐을 이해하기 위해 이클립스나 인텔리J는 사용하지 않고 vscode와 터미널 기능만 이용하려고 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 글에선 maven-quickstart 프로젝트를 생성하여 톰캣에 배포하여 웹을 띄우기까지의 과정을 처음부터 작성하려고 한다. 물론 메이븐을 이해하기 위해 이클립스나 인텔리J는 사용하지 않고 vscode와 터미널 기능만 이용하려고 한다.<a id="more"></a></p><p>이번 글의 내용은 기본적으로 maven tool과 톰캣이 설치되어 있다는 가정 하에 진행하도록 하겠다. </p><h2 id="maven-프로젝트-생성"><a href="#maven-프로젝트-생성" class="headerlink" title="maven 프로젝트 생성"></a>maven 프로젝트 생성</h2><p>먼저 파일이 생성되어질 경로를 잡고 터미널에서 기본 프로젝트 생성 코드를 입력한다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ mvn archetype:generate<br></code></pre></td></tr></table></figure><p>수 많은 프로젝트들이 뜨고 난 이후 어떤 프로젝트 기반으로 만들지 입력하라고 한다. 그냥 enter를 누르면 quickstart 프로젝트로 진행</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 1610:<br></code></pre></td></tr></table></figure><p>이후 quickstart 프로젝트의 버전을 입력하라고 한다. default 값은 최신 버전인 1.4 이다. 그대로 enter 눌러주자.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Choose org.apache.maven.archetypes:maven-archetype-quickstart version: <br>1: 1.0-alpha-1<br>2: 1.0-alpha-2<br>3: 1.0-alpha-3<br>4: 1.0-alpha-4<br>5: 1.0<br>6: 1.1<br>7: 1.3<br>8: 1.4<br>Choose a number: 8:<br></code></pre></td></tr></table></figure><p>이후 차례대로 groupId, artifactId, version, package 등을 물어본다. groupId는 com.example로 artifactId는 demo로 적어주자. 이후 버전부터 enter를 눌러주면 된다. (혹시 같은 폴더 내에 동일한 이름의 demo 프로젝트 폴더가 있다면 에러가 나니 주의)</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Define value for property &#39;groupId&#39;: com.example<br>Define value for property &#39;artifactId&#39;: demo<br>Define value for property &#39;version&#39; 1.0-SNAPSHOT: : <br>Define value for property &#39;package&#39; com.example: : <br>Confirm properties configuration:<br>groupId: com.example<br>artifactId: demo<br>version: 1.0-SNAPSHOT<br>package: com.example<br> Y: :<br></code></pre></td></tr></table></figure><p>다음과 같이 뜨면 정상적으로 프로젝트가 만들어졌다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[INFO] ----------------------------------------------------------------------------<br>[INFO] Using following parameters for creating project from Archetype: maven-archetype-quickstart:1.4<br>[INFO] ----------------------------------------------------------------------------<br>[INFO] Parameter: groupId, Value: com.example<br>[INFO] Parameter: artifactId, Value: demo<br>[INFO] Parameter: version, Value: 1.0-SNAPSHOT<br>[INFO] Parameter: package, Value: com.example<br>[INFO] Parameter: packageInPathFormat, Value: com&#x2F;example<br>[INFO] Parameter: package, Value: com.example<br>[INFO] Parameter: version, Value: 1.0-SNAPSHOT<br>[INFO] Parameter: groupId, Value: com.example<br>[INFO] Parameter: artifactId, Value: demo<br>[INFO] Project created from Archetype in dir: C:\_achive\java\maven\demo<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Total time:  16.241 s<br>[INFO] Finished at: 2020-06-05T15:03:24+09:00<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><h2 id="webapp-폴더-생성"><a href="#webapp-폴더-생성" class="headerlink" title="webapp 폴더 생성"></a>webapp 폴더 생성</h2><p>기본적인 폴더 구조는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">demo<br>|-- pom.xml<br>&#96;-- src<br>    |-- main<br>    |   &#96;-- java<br>    |       &#96;-- com<br>    |           &#96;-- example<br>    |                   &#96;-- App.java<br>    &#96;-- test<br>        &#96;-- java<br>            &#96;-- com<br>                &#96;-- example<br>                        &#96;-- AppTest.java<br></code></pre></td></tr></table></figure><p>위의 main 폴더에 다음 같이 폴더를 만들어주자. 우리가 직접 만들어 주었지만 webapp과 WEB-INF는 maven 웹프로젝트를 만들때 사용되는 폴더 구조이다. 이름을 반드시 동일하게 입력하자.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">demo<br>|-- pom.xml<br>&#96;-- src<br>    |-- main<br>    |   |-- java<br>    |   |    &#96;-- com<br>    |   |         &#96;-- example<br>    |   |                &#96;-- App.java<br>    |   &#96;-- webapp<br>    |       |&#96;-- index.html<br>    |       |&#96;-- WEB-INF<br>    |              &#96;-- web.xml<br>    &#96;-- test<br>        &#96;-- java<br>            &#96;-- com<br>                &#96;-- example<br>                        &#96;-- AppTest.java<br></code></pre></td></tr></table></figure><p>webapp 내부에 WEB-INF 폴더와 index.html, 그리고 WEB-INF 폴더에 web.xml이 있다. 먼저 index.html 파일은 단순하게 다음과 같이 만들어 주자.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello maven!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>그리고 web.xml 기본 양식은 톰캣 폴더의 webapps -&gt; ROOT -&gt; WEB-INF -&gt; web.xml를 복사해 가져오면 된다. 내용은 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-tag"><span class="hljs-string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">"true"</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Welcome to Tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>     Welcome to Tomcat<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="war-file-배포하기"><a href="#war-file-배포하기" class="headerlink" title="war file 배포하기"></a>war file 배포하기</h2><p>maven의 기본 패키징타입은 jar이다. 우리는 web 프로젝트가 목적이기 때문에 war로 패키징 타입을 바꾸어 주어야 한다. </p><p>pom.xml에 따로 명시 되지 않았는데 상단의 기본정보들을 입력하는 태그 밑에 다음 내용을 넣어주자.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이제 메이븐은 페키징을 할때 pom.xml에 기술된 위의 내용대로 war파일을 만들어줄 것이다. demo 프로젝트의 pom.xml이 있는 경로에서 다음과 같이 입력해주자.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ mvn package<br></code></pre></td></tr></table></figure><p>에러가 없이 잘 완료 되었다면 target 폴더 하위에 <code>demo-1.0-SNAPSHOT.war</code> 라는 war 확장자 파일이 생겼을 것 이다. 우리는 이제 이 파일을 톰캣에 배포해주면 된다.</p><h2 id="톰캣에-war파일-배포하기"><a href="#톰캣에-war파일-배포하기" class="headerlink" title="톰캣에 war파일 배포하기"></a>톰캣에 war파일 배포하기</h2><ul><li>톰캣 최상위 디렉토리에서 webapps 폴더 하위에 <code>demo-1.0-SNAPSHOT.war</code> 파일을 옮겨준다. 이 파일은 톰캣이 구동시에 저절로 압축이 풀린다.</li><li>톰캣 최상위 디렉토리에서 bin 폴더 하위에 startup.bat 파일을 실행시켜준다. </li><li>브라우저에서 localhost:8080에 접속해보자. 톰캣 서비스가 뜨면 서버는 정상적으로 실행되고 있다는 것</li><li>브라우저에서 localhost:8080/demo-1.0-SNAPSHOT/index.html 와 같이 입력해보자. hello maven! 이 뜬다면 성공이다.<ul><li>실제 위의 주소명은 톰캣의 webapps 를 기본 경로로 하여 압축이 풀린 demo-1.0-SNAPSHOT 내부의 index.html이 보이는 것을 알 수 있다. </li></ul></li></ul><h2 id="maven-webapp-프로젝트-쉽게-만들기"><a href="#maven-webapp-프로젝트-쉽게-만들기" class="headerlink" title="maven webapp 프로젝트 쉽게 만들기"></a>maven webapp 프로젝트 쉽게 만들기</h2><p>사실 위의 maven 프로젝트 생성하기 단계는 처음 생성시에 옵션을 주는것으로 빠르게 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ mvn archetype:generate -DinteractiveMode&#x3D;false  -DgroupId&#x3D;&lt;패키지명&gt; -DartifactId&#x3D;&lt;프로젝트명&gt; -DarchetypeArtifactId&#x3D;maven-archetype-webapp<br></code></pre></td></tr></table></figure><p><sup>*줄을 임의로 내리면 안된다. 옆으로 계속 이어서 써야한다.</sup></p><p>위와 같이 프로젝트를 만들게 되면 다음과 같이 기본적인 webapp 구조가 잡히게 된다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">demo<br>|-- pom.xml<br>|<br> &#96;-- src<br>      &#96;-- main<br>            |&#96;-- resources<br>            |<br>             &#96;-- webapp<br>                  |&#96;-- WEB-INF<br>                  |       &#96;-- web.xml<br>                   &#96;-- index.jsp<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/18/6.%20maven/maven04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>POM.xml</title>
      <link>http://gojaebeom.github.io/2020/06/17/6.%20maven/maven03/</link>
      <guid>http://gojaebeom.github.io/2020/06/17/6.%20maven/maven03/</guid>
      <pubDate>Wed, 17 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;pom은 project object model의 약자로써 메이븐은 pom에 기술된 내용을 바탕으로 빌드를 진행한다. 즉 pom은 maven에서 사용하는 빌드 파일이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>pom은 project object model의 약자로써 메이븐은 pom에 기술된 내용을 바탕으로 빌드를 진행한다. 즉 pom은 maven에서 사용하는 빌드 파일이다.</p><a id="more"></a><p>아래의 코드는 이전 글의 메이븐 생성하기에서 만든 프로젝트의 pom.xml을 열었을 때 볼 수 있는 내용이다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project's website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>뭔가 내용들이 많은데 간단하게 요약하자면 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 필수 : 프로젝트 정보 기재 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 선택 : 프로젝트에 대한 설명란 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>demo project!<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 선택 : pom.xml에서 공통적으로 사용할 버전, 설정 정보 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 각 dependency에 지정할 값들을 properties에 써두고</span><br><span class="hljs-comment">             변수처럼 활용할 수 있음. </span><br><span class="hljs-comment">             밑의 servelt.version 태그는 사용자가 임의로 지정한것</span><br><span class="hljs-comment">             이후의 dependency에서 사용하는 것을 보자</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet.version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 선택: 의존성 설정은 선택이지만 </span><br><span class="hljs-comment">       메이븐의 주 사용이유인 만큼 필수적으로 사용된다.</span><br><span class="hljs-comment">   --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- dependencies안에 dependency로 구분지어 라이브러리를 추가할 수 있다 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- properties에 작성해 놓은 servlet.version 태그의 값을 사용함 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;servlet.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 필수내용 : 프로젝트 build 정보 기재 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 선택사항 : resource 파일의 경로를 지정할 수 있음 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/webapp<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 선택사항 : maven의 라이프사이클을 개별의 플러그인으로 관리함으로써 </span><br><span class="hljs-comment">    필요한 부분만 넣어 사용할 수 있다.</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이 밖에 다른 기술들도 많이 있겠지만 기본 틀만 잡아놓고 이 후에 필요시 찾아볼 생각이다. </p><h2 id="project-기본정보"><a href="#project-기본정보" class="headerlink" title="project 기본정보"></a>project 기본정보</h2><p>보통 상단에<br>modelVersion, groupId, artifactId, version, name, url를 기재하는데 필수적이다. 추가로 프로젝트에 관한 설명을 적기위해 description 속성을 추가할 수 있다.</p><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><ul><li>프로젝트의 주요 설정들을 쉽게 모아보기 위해 정리한다. </li><li>pom.xml 내에서 자주 사용되는 정보들을 변수처럼 만들어서 사용할 수 있다.</li></ul><h2 id="dependency-관리"><a href="#dependency-관리" class="headerlink" title="dependency 관리"></a>dependency 관리</h2><p>pom.xml을 자주 들락날락 거리게 만들 이유이다. maven을 통해 불러온 라이브러리들은 java built path에서 maven dependencies 하위 목록으로 들어가게 된다. 그리고 그것들은 pom.xml을 통해서만 추가, 삭제, 버전 변경 등을 할 수 있다. </p><p>해당 경로에 추가된 라이브러리가 필요한 다른 라이브러리들이 있다면 해당하는 라이브러리까지 참조해서 불러들이는 기능이 있다. 이것을 의존성 전의라 한다.</p><h3 id="dependency태그-속성"><a href="#dependency태그-속성" class="headerlink" title="dependency태그 속성"></a>dependency태그 속성</h3><ul><li>groupId : 필수, 라이브러리의 그룹명을 적는다.</li><li>artifactId : 필수, 라이브러리의 이름을 적는다.</li><li>version: 필수? 라이브러리의 버전을 적는다.</li><li>type : 선택, 라이브러리의 유형을 적는다. defulat값은 jar이다.</li><li>scope : 라이브러리가 적용될 범위를 지정할 수 있다.<ul><li>compile(default): 모든 클래스 경로에서 사용할 수 있음. 컴파일 및 배포시 같이 재공</li><li>provided : jdk 또는 컨테이너가 런타임 시에만 해당 라이브러리를 제공. 컴파일 혹은 테스트 경로에서만 사용할 수 있다.</li><li>test : 태스트 시에만 해당 라이브러리를 사용한다.</li><li>system : 저장소에서 관리되지 않고 직접 관리하는 jar를 추가함</li></ul></li><li>optional : 선택, 의존성 정보를 다른 프로젝트에 전달하고 싶지 않을 때 true로 설정하자. </li></ul><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>빌드할 때 사용할 플러그인 목록을 기록할 수 있다. 그밖에 build 속성 내부에 resources 속성을 추가해 정적파일 경로를 설정할 수 있다.</p><p>정리랍시고 했지만 귀찮아서 생략한 부분도 많다.. <a href="https://maven.apache.org/guides/getting-started/index.html#How_do_I_setup_Maven" rel="external nofollow noopener noreferrer" target="_blank">https://maven.apache.org/guides/getting-started/index.html#How_do_I_setup_Maven</a> &lt;– 공식 홈페이지 문서이다. 글쓴이는 영어를 잘 못해 번역으로 돌려놓고 이해하려고 애쓰는데 영어 잘하시는 분들은 가서 보길 바란다. 설명 정말 잘 되어있다..</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/17/6.%20maven/maven03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Maven 프로젝트 만들기</title>
      <link>http://gojaebeom.github.io/2020/06/16/6.%20maven/maven02/</link>
      <guid>http://gojaebeom.github.io/2020/06/16/6.%20maven/maven02/</guid>
      <pubDate>Tue, 16 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 글에서 메이븐이 왜 필요한지 간단히 알아보았다. 이번엔 메이븐을 사용하는 방법에 대해서 다루고자 한다. 학습의 이해를 위해 IDE에서 지원하는 기능은 사용하지 않고 프로젝트를 만들어 보겠다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이전 글에서 메이븐이 왜 필요한지 간단히 알아보았다. 이번엔 메이븐을 사용하는 방법에 대해서 다루고자 한다. 학습의 이해를 위해 IDE에서 지원하는 기능은 사용하지 않고 프로젝트를 만들어 보겠다. <a id="more"></a></p><p>먼저 maven을 사용하기 위해 다운로드를 받아주어야 하는데 두가지 방법을 예로 들겠다. </p><h3 id="메이븐-공식-홈페이지"><a href="#메이븐-공식-홈페이지" class="headerlink" title="메이븐 공식 홈페이지"></a>메이븐 공식 홈페이지</h3><p><a href="https://maven.apache.org/download.cgi" rel="external nofollow noopener noreferrer" target="_blank">https://maven.apache.org/download.cgi</a> &lt;– 메이븐 공식 홈페이지의 다운로드 페이지에 접속하여 본인의 컴퓨터에 맞는 압축파일을 다운로드 받으면 된다. 현재 메이븐은 3.6.3 버전을 공식적으로 지원하고 있다.(참고로, 메이븐 3.3 이후부터는 자바 1.7 이상을 요구한다)</p><h3 id="chocolatey-패키지-매니저"><a href="#chocolatey-패키지-매니저" class="headerlink" title="chocolatey 패키지 매니저"></a>chocolatey 패키지 매니저</h3><p>보통 리눅스에서 파일을 쉽게 다운로드하고 관리하기위해 패키지 매니저인 apt를 사용한다. 윈도우도 이러한 이점을 반영하기 위해 생긴 것이 choco라는 패키지 매니저 이다. 이 프로그램을 사용하고 있다면 위의 방법보다 간편하게 cmd(관리자 모드)에서  <code>choco install maven</code> 을 입력하는것으로 다운 받을 수 있다. 공식 홈페이지와 동일하게 3.6.3 버전을 다운받는다.</p><p>파일을 받았다면 공식홈페이지에서 받은 파일은 압축파일로, choco 패키지 매니저로 받은 파일은 폴더로 풀려져 있을 것 이다. 압축파일은 풀어서 원하는 경로에 위치하면 된다. </p><h2 id="Maven-path-setting"><a href="#Maven-path-setting" class="headerlink" title="Maven path setting"></a>Maven path setting</h2><p>메이븐을 실행하기 위해선 사용자 경로\다운받은 메이븐 폴더\bin 의 mvn을 실행 시켜주어야 한다. 하지만 메이븐을 사용하기 위해 매번 긴 경로를 매번 입력하는것은 힘든 일이다.</p><p>윈도우 기준으로 환경변수를 등록하는 것으로 이를 해결할 수 있다.</p><ul><li>폴더의 왼쪽 디렉토리 아이콘사이의 내 PC의 우클릭을 하여 속성 클릭</li><li>고급 시스템 설정 클릭</li><li>환경 변수 클릭</li><li>시스템 변수 부분의 path를 찾아 path부분을 편집해준다.</li><li>maven의 bin 디렉토리 경로를 복사하여 입력해준다. 예) C:\apache-maven-3.6.3\bin</li><li>저장해주고 cmd에서 mvn -v 을 입력</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ mvn -v<br>Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)<br>Maven home: C:\_tools\apache-maven-3.6.3\bin\..<br>Java version: 1.8.0_251, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_251\jre<br>Default locale: ko_KR, platform encoding: MS949<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;<br>PS C:\Users\gojaebeom&gt;<br></code></pre></td></tr></table></figure><ul><li>위와 같은 문장들이 출력되면 성공이다.</li></ul><h2 id="maven-프로젝트-생성하기"><a href="#maven-프로젝트-생성하기" class="headerlink" title="maven 프로젝트 생성하기"></a>maven 프로젝트 생성하기</h2><p>mvn 명령어를 사용하여 프로젝트를 생성할 수 있다. 물론 생성시 여러 옵션을 줄 수 있지만, 우리는 기본 생성 명령어인 <code>archetype:generate</code> 만 입력하도록 한다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ mvn archetype:generate<br></code></pre></td></tr></table></figure><p>위의 명령어 입력시 엄청나게 많은 로그들이 나타난다. 먼저 mvn은 다른 사람이 만들어 놓은 프로젝트를 이어서 개발하는 것이 가능하다. 나열되는 프로젝트들은 해당 번호를 입력시 사용할 수 있지만, 우리는 현재 아무것도 모르기 때문에 그냥 엔터를 눌러주자. </p><p>번호를 따로 입력해주지 않으면 defulat값인 quick-start 프로젝트로 진행된다(기본 설정만 있는 프로젝트이다). 그 이후에는 quick-start 프로젝트의 버전을 정하라고 하는데 defulat 값은 항상 가장 최신 버전으로 되어 있다. 현재 2020-06-05일 기준으로 1.4 버전이 최신버전이다. 그대로 진행해 주자. </p><p>그다음 그룹아이디, 아티팩트 아이디는 다음과 같이 적었다.</p><ul><li>groupId: com.example</li><li>artifactId: demo</li></ul><p>그다음 부터는 무시하고 계속 엔터를 눌러주자.</p><ul><li>version: 1.0-SNAPSHOT (snapshot은 개발중인 프로젝트를 말한다. 그대로 넘어가자)</li><li>package: com.example</li></ul><h2 id="maven-프로젝트-기본-구조"><a href="#maven-프로젝트-기본-구조" class="headerlink" title="maven 프로젝트 기본 구조"></a>maven 프로젝트 기본 구조</h2><p>프로젝트 생성시 기본 구조는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">demo<br>├─src<br>│   ├─main<br>│   │  └─java<br>│   │      └─com<br>│   │          └─example<br>│   │              └─App.java<br>│   ├─test<br>│       └─java<br>│           └─com<br>│               └─example<br>│                   └─AppTest.java<br>└─pom.xml<br></code></pre></td></tr></table></figure><p>기본적으로 생성되는 폴더를 포함한 Maven 프로젝트의 주요 폴더는 다음과 같다.</p><ul><li>src/main/java - 자바 소스 파일이 위치한다.</li><li>src/main/resources - 프로퍼티나 XML 등 리소스 파일이 위치한다. 클래스패스에 포함된다.</li><li>src/main/webapp - 웹 어플리케이션 관련 파일이 위치한다. (WEB-INF 폴더, JSP 파일 등)</li><li>src/test/java - 테스트 자바 소스 파일이 위치한다.</li><li>src/test/resources - 테스트 과정에서 사용되는 리소스 파일이 위치한다. 테스트 시에 사용되는 클래스패스에 포함된다.</li></ul><p>기본적으로 생성되지 않은 폴더라 하더라도 직접 생성해주면 된다. 예를 들어 src/main 폴더에 resources 폴더를 생성해주면 Maven은 리소스 폴더로 인식한다.</p><h2 id="Maven의-lifecycle"><a href="#Maven의-lifecycle" class="headerlink" title="Maven의 lifecycle"></a>Maven의 lifecycle</h2><ul><li>generate-sources <ul><li>컴파일 과정에 포함될 소스를 생성</li></ul></li><li>process-sources    <ul><li>필터와 같은 작업을 소스 코드에 처리 </li></ul></li><li>generate-resources    <ul><li>패키지에 포함될 자원을 생성      </li></ul></li><li>process-resources    <ul><li>필터와 같은 작업을 자원 파일에 처리하고, 자원 파일을 클래스 출력 디렉토리에 복사</li></ul></li><li><strong>compile</strong><ul><li>소스 코드를 컴파일해서 클래스 출력 폴더에 클래스를 생성</li></ul></li><li>generate-test-sources    <ul><li>테스트 소스 코드를 생성</li></ul></li><li>process-test-sources    <ul><li>필터와 같은 작업을 테스트 소스 코드에 처리</li></ul></li><li>generate-test-resources    <ul><li>테스트를 위한 자원 파일을 생성     </li></ul></li><li>process-test-resources    <ul><li>필터와 같은 작업을 테스트 자원 파일에 처리, 테스트 자원 파일을 테스트 클래스 출력 폴더에 복사 </li></ul></li><li>test-compile    <ul><li>테스트 소스 코드를 컴파일해서 테스트 클래스 추력 폴더에 클래스를 생성</li></ul></li><li><strong>test</strong>    <ul><li>테스트를 실행</li></ul></li><li><strong>package</strong><ul><li>컴파일 된 코드와 자원 파일들을 jar, war와 같은 배포 형식으로 패키징</li></ul></li><li><strong>install</strong>    <ul><li>로컬 리포지토리에 패키지를 복사</li></ul></li><li><strong>deploy</strong>    <ul><li>생성된 패키지 파일을 원격 리포지토리에 등록하여, 다른 프로젝트에서 사용할 수 있도록 함</li></ul></li></ul><p>위의 라이프사이클중 굵게 표시된 단계는 명령어로 사용할 수 있다. 만약 <code>mvn compile</code> 입력시 처음부터 compile까지 순차적으로 실행된다. <code>mvn install</code> 입력시 처음부터 install까지 순차적으로 실행하게 되는 것 이다. 만약 그렇다면 위와 같은 라이프사이클은 항상 순차적으로 진행해야 하는것 인가? 라고 한다면 그것은 아니다. </p><p>maven은 위의 과정들을 각각 개별적인 플러그인으로 만들어 부품과 같이 사용하지 않을 플러그인은 무시하고 넘어갈 수 있도록 만들어져있다. </p><p>그리고 clean 명령어는 다음과 같은 상황에서 사용할 수 있다.</p><ul><li>clean<ul><li>메이븐 빌드를 통하여 생성된 모든 산출물을 삭제한다.</li></ul></li></ul><p>라이프사이클에 관한 내용을 잘 정리해주셔서 자바캔님의 블로그 내용을 인용하였습니다.<br>출처: <a href="https://javacan.tistory.com/entry/MavenBasic" rel="external nofollow noopener noreferrer" target="_blank">https://javacan.tistory.com/entry/MavenBasic</a> [자바캔]</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/16/6.%20maven/maven02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Maven을 알아보자</title>
      <link>http://gojaebeom.github.io/2020/06/15/6.%20maven/maven01/</link>
      <guid>http://gojaebeom.github.io/2020/06/15/6.%20maven/maven01/</guid>
      <pubDate>Mon, 15 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;메이븐은 자바 프로젝트의 빌드(build)를 자동화 해주는 관리 도구(build tool)이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>메이븐은 자바 프로젝트의 빌드(build)를 자동화 해주는 관리 도구(build tool)이다.<a id="more"></a>  아파치 소프트웨어 제단에서 만들어졌으며,      이전의 Apache Ant 의 대안으로 만들어졌다. </p><p><code>Too Much Information</code></p><ul><li><sup>발표일은 2004년 7월 13일 이다.</sup></li><li><sup>안정화 버전은 3.5.3 버전으로 2018년 3월 8일 이다.</sup></li></ul><p>이클립스, 인텔리J 등을 사용하면 메이븐에 관한 설정들을 편하게 할 수 있었기 때문에 메이븐이 뭔지 잘 알지 못하고 넘어갔다. 이번 계기로 Spring 관련 글을 쓰기 이전에 Maven을 조금이나마 공부하고 넘어가고자 글을 쓰게 되었다.</p><h2 id="Maven-없이-Java-빌드하기"><a href="#Maven-없이-Java-빌드하기" class="headerlink" title="Maven 없이 Java 빌드하기"></a>Maven 없이 Java 빌드하기</h2><p>메이븐이 왜 필요한지 직접 예제를 만들어 비교해보도록 하자.</p><h3 id="기본적인-빌드"><a href="#기본적인-빌드" class="headerlink" title="기본적인 빌드"></a>기본적인 빌드</h3><p>먼저 파일을 만들 디렉토리를 하나 생성해주자. 경로는 본인이 편한 경로에 생성한다. 본인은 cmd에서 빨리 탐색할 수 있게 <code>C:\Users\[유저명]&gt;</code> 의 위치에 java_study 폴더를 생성한것으로 설명하겠다.</p><p>cmd를 통해 해당경로에 notepad Main.java 를 입력하여 java 파일을 만들어준다.(직접 메모장을 생성해도 상관없다) 그리고 다음 내용을 입력해주자.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd에 해당 경로에서 javac Main.java 입력, 이후 Main.class 파일이 잘 나오면 java Main 을 입력하면 Hello World!가 잘 출력될 것이다. </p><p>이것은 아주 단순한 예제다. 이제 위의 파일을 패키지에 담아서 빌드해보자. package는 도메인의 역순으로 만드는 것이 일반적인 관례이다.</p><h3 id="패키지화하여-빌드하기"><a href="#패키지화하여-빌드하기" class="headerlink" title="패키지화하여 빌드하기"></a>패키지화하여 빌드하기</h3><p>study_java 디렉토리(자신이 만든 폴더) 위치에서 다음과 같이 폴더를 만들어 준다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">study_java<br>└── com<br>    └── example<br>        └── demo<br>            └── Main.java<br></code></pre></td></tr></table></figure><p>그리고 자바 파일도 다음과 같이 패키지를 선언해준다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위와 같은 조건들을 만족한다면 <code>javac com\example\demo\Main.java</code> 명령어로 패키지 내부의 Main.java를 Main.class 파일로 컴파일 할 수 있다. 이후 실행시에는 <code>java com.example.demo.Main</code> 로 실행 하면된다.</p><h3 id="jar-파일로-만들기"><a href="#jar-파일로-만들기" class="headerlink" title="jar 파일로 만들기"></a>jar 파일로 만들기</h3><p>이제 만든 자바파일을 배포한다고 생각해보자. 자바는 자바 클래스 파일과, 클래스 들이 이용하는 관련 리소스및 메타 데이터를 하나의 파일로 모아서 자바 플랫폼에 배포할 수 있게 Jar(Java Archive) 파일로 압축할 수 있다.</p><p>다음과 같이 명령어를 입력해보자</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; jar -c -f main.jar com\*<br></code></pre></td></tr></table></figure><p>-c는 create의 약자로 jar파일을 만든다는 뜻이다. 이후 -f Main.jar 는 파일명을 명시하라는 명령어로 Main.jar로 만들겠다는 뜻이다. 이 옵션들을 설정한 이후 공백을 기준으로 담을 파일들을 지정할 수 있는데, <code>com\*</code>는 com 하위 디렉토리를 모두 포함한다는 의미이다. 별다른 에러가 뜨지 않았다면 해당 디렉토리에 main.jar파일이 잘 생성되어있는 것을 볼 수 있을 것 이다.</p><p>이제 실행해보자.</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; java -cp . main.jar com.example.demo.Main<br><span class="hljs-comment">// -cp는 classpath의 약자이다</span><br></code></pre></td></tr></table></figure><p>위의 방법은 현재 디렉토리를 classpath로 잡고 Main.jar의 압축을 푼 뒤 com.example.demo의 Main클래스를 실행한다고 보면 된다. 하지만 jar파일 자체를 실행할 수 도 있다.</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; java -jar main.jar<br></code></pre></td></tr></table></figure><p>위의 방법으로 실행시 <code>no main manifest attribute, in test.jar</code>라는 오류 문구가 뜨는 것을 볼 수 있을 것 이다. 이는 매니페스트 파일을 만들어 Main 클래스의 위치를 명시해주면 해결 할 수 있다.</p><blockquote><p>메니페스트<br>JAR 파일 안에 포함되어 있는 매니페스트 파일은, 메타데이터 정보를 포함하고 있다. 이 메타데이터 정보에는 확장 정보 및 패키지 관련 데이터가 기술되어 있으며, 섹션 형식으로 구성된 키-값 쌍 형태의 문자열이다. JAR이 실행 가능하도록 하기 위해서는, 메니페스트 파일에, 애플리케이션의 메인 클래스의 이름이 기술되어 있어야 한다. 메니페스트 파일의 명칭은 MANIFEST.MF이며, 이 파일이 포함되어 있는 디렉토리는, 압축된 파일의 내용물 가운데 가장 첫번째 위치에 배치되어야 한다.</p></blockquote><ol><li>먼저 java_study 디렉토리에 manifest.txt 파일을 만들어주자.</li><li>Main-Class: com.example.demo.Main 적어주자.</li><li>cmd 에서 <code>jar -c -m manifest.txt  -f main.jar com\*</code> 를 다시 입력 하여 manifest파일을 포함하여 다시 jar파일로 압축해준다.</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; java -jar main.jar<br></code></pre></td></tr></table></figure><p>다시 명령어를 입력하면 hello world! 가 잘 출력되는 것을 볼 수 있다.</p><p>이정도만 했는데도 벌써 찐이 빠진다. 여기에 의존성을 추가해야한다면 어떻게 할 수 있을까?</p><h3 id="logback-라이브러리-추가해보기"><a href="#logback-라이브러리-추가해보기" class="headerlink" title="logback 라이브러리 추가해보기"></a>logback 라이브러리 추가해보기</h3><p>logback은 기본적으로 다음 세개의 라이브러리가 필요하다. 각 링크에서 file에 jar파일로 다운받아 보자.</p><ul><li><a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-classic/1.2.3" rel="external nofollow noopener noreferrer" target="_blank">logback-classic-1.2.3</a></li><li><a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-core/1.2.3" rel="external nofollow noopener noreferrer" target="_blank">logback-core-1.2.3</a></li><li><a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-api/1.7.30" rel="external nofollow noopener noreferrer" target="_blank">sl4j-api-1.7.30</a></li></ul><p>java_study 의 최상위 경로에 lib 폴더를 생성하고 위의 jar파일들을 위치해준다. 이후 Main.java 파일을 다음과 같이 수정한다.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(Main<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>logger.info(<span class="hljs-string">"Hello World!!"</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>이제 위의 java파일을 컴파일 하면 되는데, 이전의 System.out.println은 자바 유틸에서 기본적으로 제공하기때문에 상관 없었지만 우리는 logback 라이브러리를 사용하였기때문에 해당 의존성들을 classpath로 추가해주어야한다. 다음과 같이 입력해보자</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; javac -cp lib\logback-classic<span class="hljs-number">-1.2</span><span class="hljs-number">.3</span>.jar;lib\logback-core<span class="hljs-number">-1.2</span><span class="hljs-number">.3</span>.jar;lib\slf4j-api<span class="hljs-number">-1.7</span><span class="hljs-number">.30</span>.jar com\example\demo\Main.java<br></code></pre></td></tr></table></figure><p>해당 라이브러리들을 클래스패스로 등록하고 컴파일한다. 이후</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">java -cp lib\logback-classic<span class="hljs-number">-1.2</span><span class="hljs-number">.3</span>.jar;lib\logback-core<span class="hljs-number">-1.2</span><span class="hljs-number">.3</span>.jar;lib\slf4j-api<span class="hljs-number">-1.7</span><span class="hljs-number">.30</span>.jar;. com.example.demo.Main<br></code></pre></td></tr></table></figure><p>다음과 같이 실행 시 <code>03:42:58.346 [main] INFO com.example.demo.Main - Hello World!!</code> 와 같이 현재 시간을 포함한 문구가 뜨면 성공이다. 마지막 관문이 남았다. 이쯤되면 maven이 왜 필요할지 알것 같기도 하지만 의존성을 포함하여 jar로 압축하는 것까지는 끝내보자.</p><p>먼저 manifest.txt 파일의 Main-Class 밑에 다음 문장을 추가하자.<br><code>Class-Path: lib\logback-classic-1.2.3.jar lib\logback-core-1.2.3.jar lib\slf4j-api-1.7.30.jar</code></p><p>cmd에 다음과 같이 작성하자.</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">&gt; jar -c -m manifest.txt -f test.jar com\*<br><span class="hljs-comment">//에러 없이 잘 압축되면 다음 명령어 실행</span><br>&gt; java -jar test.jar<br></code></pre></td></tr></table></figure><p>오랜만에 IDE를 사용하지 않고 자바를 컴파일하니 기억나지 않는 부분이 많아 이곳 저곳 찾아본것 같다. 다음 글에서는 maven을 사용하여 위의 과정을 메이븐으로 빌드하여 얼마나 간편한지 느껴보도록 하자. 본인도 글을 쓰면서 점점 귀차니즘이 발동되어 갈 수록 내용이 산으로 갔다. 다루고 싶은 내용은 더 있지만 글로써 전달하는게 이렇게 어려운 일인가 싶다..ㅎ</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/15/6.%20maven/maven01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>servlet 복습, 생명주기</title>
      <link>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet11/</link>
      <guid>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet11/</guid>
      <pubDate>Wed, 10 Jun 2020 13:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;서블릿 프로그램을 공부하면서 배운 내용들을 정리하려고 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>서블릿 프로그램을 공부하면서 배운 내용들을 정리하려고 한다.<a id="more"></a></p><h2 id="서블릿-Servlet-의-등장-배경"><a href="#서블릿-Servlet-의-등장-배경" class="headerlink" title="서블릿(Servlet) 의 등장 배경"></a>서블릿(Servlet) 의 등장 배경</h2><ol><li>자바 프로그램은 OS 또는 콘솔을 통해 사용자와 상호작용을 함</li><li>웹의 엄청난 발전으로 인해 점차 자바 프로그램은 -&gt; 자바 웹 프로그램으로 바뀌기 시작</li><li>사용자는 브라우저를 통해 조작을 하여 원하는 기능들을 사용</li><li>사용자가 조작한 것, 예를 들어 <a href="http://www.example.com" rel="external nofollow noopener noreferrer" target="_blank">www.example.com</a> 이라는 도메인 주소를 요청하면 브라우저(클라이언트)는 도메인주소에 해당하는 ip주소의 서버에게 요청을 보냄 </li><li>웹 서버는 요청에 대한 html 문서를 응답해줌</li><li>하지만 html문서는 정적인 문서이기때문에 서버에 존재하는 html문서만으로는 데이터의 변화를 줄 수 없음</li><li>그래서 웹 서버는 동적인 데이터가 필요하다면 웹 어플리케이션 서버(줄여서 WAS)에게 요청을 위임하여 웹 어플리케이션을 실행시켜 필요한 기능을 수행하게하고 그 결과를 웹 서버가 다시 받아 응답해주는 방법을 사용한다.</li><li>WAS에서 사용된 웹 어플리케이션이 바로 <code>서블릿(Servlet)</code> 이다.</li></ol><p><img src="https://gojaebeom.github.io//images/servlet/example02.png" alt="image"></p><h2 id="서블릿-Servlet"><a href="#서블릿-Servlet" class="headerlink" title="서블릿(Servlet)"></a>서블릿(Servlet)</h2><p>서블릿은 다음과 같이 말할 수 있다.</p><ul><li>자바 웹 서버 프로그램</li></ul><p>좀 더 풀어서 말하면 다음과 같이 말할 수 있다. </p><ul><li>서버쪽에서 실행되고 클라이언트의 요청에 따라 동적으로 서비스를 제공하는 자바 클래스</li></ul><h2 id="서블릿-컨테이너-Servlet-Container"><a href="#서블릿-컨테이너-Servlet-Container" class="headerlink" title="서블릿 컨테이너(Servlet Container)"></a>서블릿 컨테이너(Servlet Container)</h2><p>사실 위의 일련의 과정중 생량된 것이 바로 서블릿의 컨테이너이다. WAS를 위에서 언급하였는데 브라우저에서 요청이오면 웹서버는 WAS의 내부에 서블릿 컨테이너에게 요청을 위임하는 것이다. <u>서블릿 컨테이너는 서블릿들의 생성, 실행, 파괴를 담당한다.</u> </p><h3 id="서블릿-생명-주기-Servlet-Life-Cycle"><a href="#서블릿-생명-주기-Servlet-Life-Cycle" class="headerlink" title="서블릿 생명 주기(Servlet Life Cycle)"></a>서블릿 생명 주기(Servlet Life Cycle)</h3><ul><li>init() : servlet이 생성되는 단계 (최초 한번만 실행)</li><li>service() : servlet이 실행되는 단계<ul><li>상황에 따라 doGet(), doPost() 메소드를 호출</li></ul></li><li>destroy() : servlet이 소멸되는 단계</li></ul><p><img src="https://t1.daumcdn.net/cfile/tistory/995D5E435C56BC4914" alt="image"></p><p>위의 서블릿 컨테이너에 의한 서블릿의 생명주기 상세보기이다.</p><ol><li>HTTP 요청을 서블릿 컨테이너가 받음</li><li>서블릿 컨테이너는 <code>HttpServletRequest</code>, <code>HttpServletResponse</code> 두 객체를 생성</li><li>배포 서술자(Web.xml)을 참고하여 요청한 URL이 어느 서블릿에 대한 요청인지 찾음</li><li>해당 서블릿 클래스가 컨테이너에서 실행된 적이 없거나 현재 메모리에 생성된 인스턴스가 없다면 새로 인스턴스를 생성하고 <code>init()</code> 메소드를 실행하여 최기화하고 스레드를 하나 생성</li><li>이미 인스턴스가 존재한다면 새로 생성하지 않고 기존의 인스턴스에 스레드만 하나 생성  </li><li>컨테이너는 <code>service()</code> 메소드를 호출하여 POST, GET 여부에 따라 <code>doGet()</code> 또는 <code>doPost()</code> 메서드가 호출됨</li><li><code>doGet()</code>, <code>doPost()</code>등의 메서드는 동적인 페이지를 생성 후 <code>HttpServletResponse</code>을 호출</li><li>응답을 주고 <code>HttpServletRequest</code>, <code>HttpServletResponse</code> 객체 소멸</li></ol><p><sup># 해당 글은 개인적인 공부 내용을 정리하는 것을 목적으로 하고있습니다.</sup><br><sup># 설명이 다소 부족하거나 중간 내용이 생략될 수 있습니다.</sup></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jsp 프로젝트 만들기 - mvc1, mvc2</title>
      <link>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet10/</link>
      <guid>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet10/</guid>
      <pubDate>Wed, 10 Jun 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전에 만든 &lt;code&gt;board-detail.jsp&lt;/code&gt;은 DB와 잘 연결되어 화면에 데이터를 잘 출력하는 것을 볼 수 있다. 하지만 jsp 파일 내의 코드를 보면 자바코드와 html코드가 뒤엉켜 있는 것을 볼 수 있다. 이것을 스파게티 코드라 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이전에 만든 <code>board-detail.jsp</code>은 DB와 잘 연결되어 화면에 데이터를 잘 출력하는 것을 볼 수 있다. 하지만 jsp 파일 내의 코드를 보면 자바코드와 html코드가 뒤엉켜 있는 것을 볼 수 있다. 이것을 스파게티 코드라 한다.</p><a id="more"></a><h2 id="MVC1"><a href="#MVC1" class="headerlink" title="MVC1"></a>MVC1</h2><p>스파게티 코드는 코드량이 많아질 수록 점점 복잡해 지는 단점이 있다. 이와 같은 문제점을 해결하기 위해 MVC1 모델이 나오게 된다. 다음 그림을 보자.<br><img src="https://gojaebeom.github.io//images/servlet/example09.png" alt="board-detail.jsp"></p><p>위 처럼 제어에 의한 코드들은 상단에 모아놓고 밑에는 html 코드만 두는 것이다. 물론 데이터의 전달을 위한 model을 사용하는 java코드는 아직까진 해결하지 못한것 같다. (이후의 el과 jstl에 의해 어느정도 해결이 된다.)</p><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span><br>    pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;<br>&lt;%<br><br>String url = <span class="hljs-string">"jdbc:mysql://localhost:3306?characterEncoding=UTF-8&amp;serverTimezone=UTC"</span>;<br>String id = <span class="hljs-string">"root"</span>;<br>String pw = <span class="hljs-string">"woqja5164!"</span>;<br><br>String sql = <span class="hljs-string">"SELECT * FROM example01.board where id = 1"</span>;<br><br>Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);<br>Connection con = DriverManager.getConnection(url,id,pw);<br>Statement state = con.createStatement();<br>ResultSet result = state.executeQuery(sql);<br><br>result.next();<br><br>String title = result.getString(<span class="hljs-string">"title"</span>);<br>String writerId = result.getString(<span class="hljs-string">"writer_id"</span>);<br>String content = result.getString(<span class="hljs-string">"content"</span>);<br>String files = result.getString(<span class="hljs-string">"files"</span>);<br><span class="hljs-keyword">int</span> hit = result.getInt(<span class="hljs-string">"hit"</span>);<br>Date createdAt = result.getDate(<span class="hljs-string">"created_at"</span>);<br><br>con.close();<br>state.close();<br>result.close();<br>%&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;<br>&lt;title&gt;Insert title here&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;nav&gt;<br>&lt;a href="/"&gt;홈&lt;/a&gt;<br>&lt;a href="/lists/board-list.jsp"&gt;게시글 목록&lt;/a&gt;<br>&lt;/nav&gt;<br>&lt;hr/&gt;<br>&lt;h1&gt;제목 : &lt;%= title %&gt;&lt;/h1&gt;<br>&lt;p&gt;작성자:&lt;%= writerId %&gt; / 작성일: &lt;%= createdAt %&gt; / 조회수: &lt;%= hit %&gt;  &lt;/p&gt;<br>&lt;p&gt;첨부 파일:&lt;%= files %&gt; &lt;/p&gt;<br>&lt;div style=<span class="hljs-string">"width:500px; height:300px; border:2px dotted gray; padding:10px;"</span>&gt;<br>&lt;%= content %&gt;<br>&lt;/div&gt;<br>&lt;hr/&gt;<br>&lt;a href=""&gt;다음 글&lt;/a&gt;<br>&lt;span style="font-weight:bold"&gt;/&lt;/span&gt;<br>&lt;a href=""&gt;이전 글&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>별 차이 없어 보일 수 있는데, 이전의 코드는 html 최하단에 DB의 연결을 끊기 위한 코드를 작성했었다. 그 코드들을 모두 상단으로 가져갔는데, 여기서 포인트는 </p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">con.close();<br>state.close();<br>result.close();<br></code></pre></td></tr></table></figure><p>가 먼저 실행되어 db의 연결이 끊겼지만 result에서 빼온 값을 변수에 저장하여 별개로 데이터를 넘겨 줄 수 있는 점이다. (물론 다수의 데이터를 가져온다고 하면 조금 더 복잡해 지지만) 위와 같은 방법으로 java 코드를 한군데 모아 놓으니 더 깔끔해 진거 같다.</p><h2 id="MVC2"><a href="#MVC2" class="headerlink" title="MVC2"></a>MVC2</h2><p>하지만 MVC1 모델도 개발자들이 불편함을 느꼈는지 이후의 MVC2 방식이 나오게 된다. MVC2 방식은 기존의 자바 소스코드를 아예 별도의 파일로 분리하여 요청을 servlet에서 받아 데이터를 가공하고 jsp에게 요청과 데이터를 위임하는 방식을 사용한다. 다음 예제를 살펴보자.</p><h3 id="com-example-demo-controller-BoardDetail"><a href="#com-example-demo-controller-BoardDetail" class="headerlink" title="com.example.demo.controller.BoardDetail"></a>com.example.demo.controller.BoardDetail</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/board-detail"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoardDetail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>String bId_ = req.getParameter(<span class="hljs-string">"id"</span>);<br><br><span class="hljs-keyword">int</span> bId = (bId_ != <span class="hljs-keyword">null</span> &amp;&amp; !bId_.equals(<span class="hljs-string">""</span>)) ? Integer.valueOf(bId_) : <span class="hljs-number">1</span> ;<br><br><br>String url = <span class="hljs-string">"jdbc:mysql://localhost:3306?characterEncoding=UTF-8&amp;serverTimezone=UTC"</span>;<br>String id = <span class="hljs-string">"root"</span>;<br>String pw = <span class="hljs-string">"woqja5164!"</span>;<br><br>String sql = <span class="hljs-string">"SELECT * FROM example01.board where id = "</span>+ bId;<br><br>Connection con = <span class="hljs-keyword">null</span>;<br>Statement state = <span class="hljs-keyword">null</span>;<br>ResultSet result = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);<br>con = DriverManager.getConnection(url,id,pw);<br>state = con.createStatement();<br>result = state.executeQuery(sql);<br><br>result.next();<br><br>Board board = <span class="hljs-keyword">new</span> Board();<br>board.setTitle(result.getString(<span class="hljs-string">"title"</span>));<br>board.setWriterId(result.getString(<span class="hljs-string">"writer_id"</span>));<br>board.setContent(result.getString(<span class="hljs-string">"content"</span>));<br>board.setFiles(result.getString(<span class="hljs-string">"files"</span>));<br>board.setHit(result.getInt(<span class="hljs-string">"hit"</span>));<br>board.setCreatedAt(result.getDate(<span class="hljs-string">"created_at"</span>));<br><br>req.setAttribute(<span class="hljs-string">"board"</span>, board);<br><br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>con.close();<br>state.close();<br>result.close();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>req.getRequestDispatcher(<span class="hljs-string">"/details/board-detail.jsp"</span>).forward(req, res);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>요청이 <a href="http://localhost:8080/board-detail" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/board-detail</a> 로 들어올 경우 해당 서블릿 실행</li><li>쿼리스트링으로 id 값을 받아오면 쿼리의 인자로 들어감 </li><li>만약 id 값을 받아오지 않으면 기본 값 1로써 쿼리를 실행 -&gt; 즉 board 테이블의 1번째 행을 조회</li><li>변수로 담았던 title, writer_id 등의 값을 Board.java 파일로 따로 만들어 DB에서 추출한 값을 담음</li><li>request의 setAttribute 를 통해 값을 request 저장소에 담아둔다. </li><li>이후의 req.getRequestDispatcher(“/details/board-detail.jsp”).forward(req, res) 를 통해 board-detail.jsp에게 요청을 양도하고 불러옴’</li></ul><h3 id="com-example-demo-entity-Board"><a href="#com-example-demo-entity-Board" class="headerlink" title="com.example.demo.entity.Board"></a>com.example.demo.entity.Board</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Board</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String title;<br><span class="hljs-keyword">private</span> String writerId;<br><span class="hljs-keyword">private</span> String content;<br><span class="hljs-keyword">private</span> Date createdAt;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hit;<br><span class="hljs-keyword">private</span> String files;<br><br><span class="hljs-comment">//생성자 정의 생략</span><br><br><span class="hljs-comment">//getter&amp;&amp;setter 정의 생략</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>board 테이블에 대한 데이터를 담기 위한 클래스 정의</li></ul><h3 id="board-detail-jsp"><a href="#board-detail-jsp" class="headerlink" title="board-detail.jsp"></a>board-detail.jsp</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">pageEncoding</span>=<span class="hljs-string">"UTF-8"</span>%&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>홈<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/lists/board-list.jsp"</span>&gt;</span>게시글 목록<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>제목 : $&#123;board.title &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>작성자:$&#123;board.writerId &#125; / 작성일: $&#123;board.createdAt &#125; / 조회수:$&#123;board.hit &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>첨부 파일:$&#123;board.files &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:500px; height:300px; border:2px dotted gray; padding:10px;"</span>&gt;</span><br>$&#123;board.content &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>다음 글<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-weight:bold"</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>이전 글<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>forword를 통해 BoardDetail.java에게 req, res를 위임 받아 setAttribute에 저장한 board 값을 사용할 수 있음</li><li>el태그를 이용하여 보다 깔끔하게 model을 입력할 수 있음</li></ul><h2 id="view-은닉"><a href="#view-은닉" class="headerlink" title="view 은닉"></a>view 은닉</h2><ul><li><a href="http://localhost:8080/board-detail" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/board-detail</a> 주소를 입력하게 되면 board 테이블의 id가 1인 데이터들이 출력되는 것을 볼 수 있다.</li><li>이것은 사실 id 값을 받지 않으면 기본값을 1로 받기 때문에 출력이 되는 것이다. 실제로 저 주소 대신 <a href="http://localhost:8080/board-detail?id=1" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/board-detail?id=1</a> 과같은 주소를 사용하여 사용자들은 목록에서 해당하는 게시물을 찾아 들어갈 수 있게 될 것이다.</li></ul><p>그렇다면 다음과 같은 주소를 입력해보자.<br><a href="http://localhost:8080/details/board-detail.jsp?id=1" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/details/board-detail.jsp?id=1</a></p><p>화면에 데이터가 출력되지 않거나 NullPointException 오류창이 뜰 것이다. MVC2 패턴을 사용하면서 사용자는 <code>details/board-detail.jsp</code>를 직접 요청하는게 아닌 <code>/board-list</code>를 입력하여 서블릿을 먼저 실행시켜 데이터를 가공하고 가공된 데이터를 board-detail.jsp 파일에서 위임하여 실행 시키는 구조이다. 즉 위와 같이 jsp 문서를 사용자가 직접 요청하게 되면 데이터가 없는 문서를 보여주게되고, 로직에 따라 오류가 날 수 있는 가능성이 크다는 것이다. 이것은 잘못된 접근이며 그렇기에 사용자가 jsp파일을 직접 접근할 수 없게 만들어 주어야 한다.</p><h2 id="WEB-INF"><a href="#WEB-INF" class="headerlink" title="WEB-INF"></a>WEB-INF</h2><p>WebContent 폴더 하위에 WEB-INF라는 폴더가 보일 것이다. 이름 그대로 <code>WEB INFORMACTION</code>의 약자이며 보안에 관련된 파일들은 이 폴더의 내부에 둔다. 그렇다면 우리가 만든 index, detail, list 파일들을 이 폴더 내부로 옮겨주자. </p><ul><li>WEB-INF 폴더에 views 라는 폴더를 하나 만든다.</li><li>그 안에 index.jsp, (board-list.jsp를 포함한)lists폴더 , (board-detail.jsp를 포함한) details 폴더를 옮겨주자.</li><li>BoardDetail.java의 하단의 getRequestDispacher()의 경로를 <code>/WEB-INF/views/details/board-detail.jsp</code>로 바꿔주자.</li></ul><p>이제 파일 경로로 jsp를 호출하려고 해도 페이지를 찾을 수 없다는 404오류가 뜰 것이다. 이로써 사용자는 상세페이지를 조회하기 위해 무조건 servlet을 요청하게 되고 servlet은 해당하는 id 값을 받아 jsp 파일을 호출해 client에 응답을 해주게 된다.</p><p><img src="https://gojaebeom.github.io//images/servlet/example10.png" alt="board-detail.jsp"></p><p><sup># 해당 글은 개인적인 공부 내용을 정리하는 것을 목적으로 하고있습니다.</sup><br><sup># 설명이 다소 부족하거나 중간 내용이 생략될 수 있습니다.</sup></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/10/5.%20servlet/servlet10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jsp 프로젝트 만들기 - DB 연결</title>
      <link>http://gojaebeom.github.io/2020/06/09/5.%20servlet/servlet09/</link>
      <guid>http://gojaebeom.github.io/2020/06/09/5.%20servlet/servlet09/</guid>
      <pubDate>Tue, 09 Jun 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;JDBC&lt;/code&gt;를 이용하여 자바 웹 프로젝트에 &lt;code&gt;mysql&lt;/code&gt;을 연동하여 프로그램을 이어 나가겠다. JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><code>JDBC</code>를 이용하여 자바 웹 프로젝트에 <code>mysql</code>을 연동하여 프로그램을 이어 나가겠다. JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.</p><a id="more"></a><h2 id="mysql-table-생성"><a href="#mysql-table-생성" class="headerlink" title="mysql table 생성"></a>mysql table 생성</h2><p>이번 프로젝트는 mysql을 이용할 예정이다. 먼저 mysql table을 다음과 같이 생성해 주자.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> board (<br>  <span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-string">`title`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`writer_id`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`content`</span> <span class="hljs-built_in">TEXT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`hit`</span> <span class="hljs-built_in">INT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`created_at`</span> DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`files`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-literal">NULL</span>,<br>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>));<br></code></pre></td></tr></table></figure><h2 id="JDBC-사용하기"><a href="#JDBC-사용하기" class="headerlink" title="JDBC 사용하기"></a>JDBC 사용하기</h2><p>만들어 놓은 자바 웹 프로젝트에 JDBC 를 사용하여 Mysql 데이터베이스를 연동할 것다. jdbc는 jdk를 설치하면 기본적으로 java.sql 하위에 내장되어 있지만, 사용자에 따라 오라클 또는 mysql 과 같은 다른 DB를 사용할 수 있기 때문에 연결할 틀만 제공해준다. 따라서 사용자는 사용할 DB의 드라이버를 다운 받아 사용해야 한다.</p><h2 id="mysql-connector-설치"><a href="#mysql-connector-설치" class="headerlink" title="mysql connector 설치"></a>mysql connector 설치</h2><p>라이브러리를 사용하기 위해선 해당 jar파일을 프로젝트에 추가해주어야 한다. 이전 자바 프로젝트와는 달리 servlet 프로젝트는 <code>WEB-INF/lib</code> 하위 경로에 파일을 추가해 주어야한다. </p><p>우리가 웹 프로젝트를 완성하면 실제 사용할 서버에 배포를 해주어야 하는데 해당 라이브러리를 같이 가져가서 사용하게 할 목적이다.</p><ul><li><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.18" rel="external nofollow noopener noreferrer" target="_blank">https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.18</a> 해당 주소에 접속한다.</li><li>file에 jar파일을 다운받는다.</li><li>프로젝트의 <code>/WEB-INF/lib</code> 하위에 해당 jar 파일을 넣어준다. (만약 .zip파일로 압축 되어 있다면 내부의 mysql-connector-java-8.0.20.jar 과 같은 파일만 빼서 넣어주어야 함)</li></ul><h2 id="프로젝트에-DB-연동"><a href="#프로젝트에-DB-연동" class="headerlink" title="프로젝트에 DB 연동"></a>프로젝트에 DB 연동</h2><p>이전에 만들어논 3개의 페이지 index, board-list, board-detail 문서중 board-detail.jsp 를 예제로 db를 연동하여 데이터를 웹에 출력해보자.</p><p>board-detail.jsp 문서의 제일 상단에 스크랩트립 <code>&lt;% %&gt;</code>을 사용하여 다음 내용을 넣어보자.</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//getConnection에 필요한 파라미터 각 mysql의 url, 사용자 아이디, 비밀번호를 받는다.</span><br>String url = <span class="hljs-string">"jdbc:mysql://localhost:3306?characterEncoding=UTF-8&amp;serverTimezone=UTC"</span>;<br>String id = <span class="hljs-string">"root"</span>;<br>String pw = <span class="hljs-string">"woqja5164!"</span>;<br><br><span class="hljs-comment">//라이브러리로 받은 mysql connector의 Driver 클래스를 JVM에게 알려준다. 메모리에 올라감</span><br>Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);<br><br><span class="hljs-comment">//java.sql.DriverManager 를 사용하여 mysql에 대한 정보를 주고 Connection 이 참조</span><br>Connection con = DriverManager.getConnection(url,id,pw);<br></code></pre></td></tr></table></figure><p>자바 파일에 작성했다면 <code>Class.forName</code>은 <code>ClassNotFoundException</code>예외를,  <code>DriverManager.getConnection</code>는 <code>SQLException</code> 예외를 처리 해주어야 하지만 스크랩트릿 내부에서의 코드는 예외 처리가 필요 없다. 위 코드를 입력 후 <a href="http://localhost:8080/details/board-detail.jsp" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/details/board-detail.jsp</a> 에 접속시 화면이 잘 뜬다면 성공적으로 연결한 것이다.</p><h2 id="DB의-데이터를-웹에-보여주기"><a href="#DB의-데이터를-웹에-보여주기" class="headerlink" title="DB의 데이터를 웹에 보여주기"></a>DB의 데이터를 웹에 보여주기</h2><p>board-detail.jsp를 다음과 같이 수정한다.</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">"java.util.Date"</span>%&gt;<br>그 밖의 <span class="hljs-keyword">import</span>... <br>&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span><br>    pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;<br>&lt;%<br>String url = <span class="hljs-string">"jdbc:mysql://localhost:3306?characterEncoding=UTF-8&amp;serverTimezone=UTC"</span>;<br>String id = <span class="hljs-string">"root"</span>;<br>String pw = <span class="hljs-string">"woqja5164!"</span>;<br><br>String sql = <span class="hljs-string">"SELECT * FROM example01.board where id = 1"</span>;<br><br>Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);<br>Connection con = DriverManager.getConnection(url,id,pw);<br>Statement state = con.createStatement();<br>ResultSet result = state.executeQuery(sql);<br><br>result.next();<br>%&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;<br>&lt;title&gt;Insert title here&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;nav&gt;<br>&lt;a href="/"&gt;홈&lt;/a&gt;<br>&lt;a href="/lists/board-list.jsp"&gt;게시글 목록&lt;/a&gt;<br>&lt;/nav&gt;<br>&lt;hr/&gt;<br>&lt;h1&gt;제목 : &lt;%= result.getString("title") %&gt; &lt;/h1&gt;<br>&lt;p&gt;작성자:&lt;%= result.getString("writer_id") %&gt; / 작성일: &lt;%= result.getDate("created_at") %&gt;/ 조회수: &lt;%= result.getInt("hit") %&gt;  &lt;/p&gt;<br>&lt;p&gt;첨부 파일:&lt;%= result.getString("files") %&gt; &lt;/p&gt;<br>&lt;div style=<span class="hljs-string">"width:500px; height:300px; border:2px dotted gray; padding:10px;"</span>&gt;<br>&lt;%= result.getString(<span class="hljs-string">"content"</span>) %&gt;<br>&lt;/div&gt;<br>&lt;hr/&gt;<br>&lt;a href=""&gt;다음 글&lt;/a&gt;<br>&lt;span style="font-weight:bold"&gt;/&lt;/span&gt;<br>&lt;a href=""&gt;이전 글&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>&lt;%<br>con.close();<br>state.close();<br>result.close();<br>%&gt;<br></code></pre></td></tr></table></figure><p><a href="http://localhost:8080/details/board-detail.jsp" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/details/board-detail.jsp</a><br>위 문서를 브라우저에서 실행하면 다음과 같은 화면을 볼 수 있다.<br><img src="https://gojaebeom.github.io//images/servlet/example08.PNG" alt="board-detail.jsp"></p><p>위의 코드를 보면 java 코드를 담기 위한 스크립트릿과 html이 뒤엉켜있는 것을 볼 수 있다. 위와 같은 코드를 스파게티 코드라고 한다. 혼자 프로젝트를 만들때는 괜찮겠지만, 기업에서의 협업, 또는 프로젝트의 규모가 커질 수 록 관리하기 힘든 점이 있다. 그래서 MVC1이라는 패턴이 나왔는데 다음 글에 이어서 다루도록 하겠다.</p><p><sup># 해당 글은 개인적인 공부 내용을 정리하는 것을 목적으로 하고있습니다.</sup><br><sup># 설명이 다소 부족하거나 중간 내용이 생략될 수 있습니다.</sup></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/09/5.%20servlet/servlet09/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
