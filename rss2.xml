<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Universe - 재범의 개발일지</title>
    <link>http://gojaebeom.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/98c3781dafc67dfe731441beeee5e4ec</url>
      <title>Universe - 재범의 개발일지</title>
      <link>http://gojaebeom.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>재범의 기술 블로그 입니다.</description>
    <pubDate>Sun, 26 Apr 2020 07:21:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JAVA - 08. 클래스 메소드</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/</guid>
      <pubDate>Sun, 26 Apr 2020 07:09:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;클래스-메소드-static-메소드&quot;&gt;&lt;a href=&quot;#클래스-메소드-static-메소드&quot; class=&quot;headerlink&quot; title=&quot;클래스 메소드(static 메소드)&quot;&gt;&lt;/a&gt;클래스 메소드(static 메소드)&lt;/h2&gt;&lt;p&gt;클래스 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스-메소드-static-메소드"><a href="#클래스-메소드-static-메소드" class="headerlink" title="클래스 메소드(static 메소드)"></a>클래스 메소드(static 메소드)</h2><p>클래스 내에 정의된 메소드에 static 선언을 하면 ‘클래스 메소드’가 된다. 그리고 클래스 메소드는 그 성격이 클래스 변수와 유사하다.<br>접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 클래스 변수와 동일하다.</p><h3 id="클래스-메소드의-정의와-호출"><a href="#클래스-메소드의-정의와-호출" class="headerlink" title="클래스 메소드의 정의와 호출"></a>클래스 메소드의 정의와 호출</h3><p>이전 글에서 공부한 클래스 변수의 특성 두 가지는 다음과 같다.</p><ul><li>인스턴스 생성 이전부터 접근이 가능하다.</li><li>어느 인스턴스에도 속하지 않는다.</li></ul><p>이 두 가지는 클래스 메소드도 동일하게 갖는 특성이다. 따라서 이 사실을 다음 예제를 통해서 확인해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스메소드<span class="title">_</span>정의 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NumberPrinter.showInt(<span class="number">50</span>);<span class="comment">// 클래스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 사실 위의 문장만 보더라도 클래스 메소드가 어느 인스턴스에도 속하지 않는다는 사실을 알 수 있다.</span></span><br><span class="line"><span class="comment"> * 인스턴스 생성 이전에 호출이 되었기 때문이다. </span></span><br><span class="line"><span class="comment"> * 그리고 예제의 주석에서 설명하고 있듯이 클래스의 내부와 외부에서 클래스 메소드를 호출하는 방법은</span></span><br><span class="line"><span class="comment"> * 클래스 변수에 접근하는 방법과 차이가 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">NumberPrinter np = <span class="keyword">new</span> NumberPrinter();</span><br><span class="line">np.showDouble(<span class="number">3.15</span>); <span class="comment">// 인스턴스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"></span><br><span class="line">np.setMyNumber(<span class="number">30</span>);</span><br><span class="line">np.showMyNumber();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> myNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//클래스 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDouble</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;<span class="comment">//클래스 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">myNum = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyNumber</span><span class="params">()</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">showInt(myNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 질문에 답해보자. </p><ul><li>클래스 메소드에서 같은 클래스에 선언된 인스턴스 변수에 접근이 가능한가?</li></ul><p>이는 다음과 같은 코드의 작성이 가능한지를 묻는 질문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스메소드<span class="title">_</span>심화 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int num =0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void addNum(int n) &#123;</span></span><br><span class="line"><span class="comment">//num = n;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 문장에 주석을 풀면 에러가 난다. 논리적으로 생각을 하면 위와 같은 문장 구성이 불가능하다는 것을 알 수 있다.</p><p>인스턴스 변수는 인스턴스에 속한다. 더불어 인스턴스가 생성이 되어야 메모리 공간에 존재하게 된다. 반면 클래스 메소드는 인스턴스 생성 이전부터 호출이 가능하다. 따라서 위 질문에 대해서 다음과 같이 대답할 수 있다.</p><ul><li>클래스 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수에 접근이 불가능하다.</li><li>같은 이유로 클래스 메소드는 인스턴스 메소드의 호출도 불가능하다.</li></ul><p>그러나 클래스 메소드 같은 클래스에 정의되어 있는 다른 클래스 메소드나 성격이 동일한 클래스 변수에는 접근이 가능하다.(당연한 얘기지만..)</p><h2 id="System-out-println-그리고-main-메소드"><a href="#System-out-println-그리고-main-메소드" class="headerlink" title="System.out.println 그리고 main 메소드"></a>System.out.println 그리고 main 메소드</h2><p>지금까지 main 메소드를 정의할 때 그 앞에 static 선언을 붙여왔다. 그리고 인스턴스의 생성 없이 println 메소드를 호출해 왔다.</p><h3 id="System-out-println-에서-out과-println의-정체는"><a href="#System-out-println-에서-out과-println의-정체는" class="headerlink" title="System.out.println()에서 out과 println의 정체는?"></a>System.out.println()에서 out과 println의 정체는?</h3><p>static 선언의 의미를 알았으니 sysout의 구성을 이해할 수 있다. 일단 System은 자바에서 제공하는 클래스로 java.lang 패키지에 묶여있다.  따라서 원칙적으로는 다음과 같이 호출해야 한다.</p><ul><li>java.lang.System.out.println(…);</li></ul><p>그러나 컴파일러가 다음 문장은 삽입 해주기때문에 패키지의 이름부분은 생략할 수 있다. </p><ul><li>import java.lang.*;</li></ul><p>그리고 out은 System.out으로 접근을 하니, 이는 분명 static으로 선언된 클래스 변수가 분명하다.<br>클래스의 이름을 통해 접근하니 말이다.<br>실제로 out은 System 클래스 내에 다음과 같이 선언된 클래스 변수이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out; <span class="comment">//참조변수</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 println은 PrintStream 클래스의 인스턴스 메소드이다. 따라서 다음 문장을 보면서,</p><ul><li>System.out.println(…);</li></ul><p>다음과 같이 이해 할 수 있어야 한다.</p><ul><li>System에 위치한 클래스 변수 out이 참조하는 인스턴스의 println 메소드를 호출하는 문장</li></ul><h3 id="main-메소드가-public-이고-static인-이유에-대해서-알아보자"><a href="#main-메소드가-public-이고-static인-이유에-대해서-알아보자" class="headerlink" title="main 메소드가 public 이고 static인 이유에 대해서 알아보자."></a>main 메소드가 public 이고 static인 이유에 대해서 알아보자.</h3><p>main 메소드는 반드시 다음의 모양새를 갖춰야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 main 메소드는 public 으로 그리고 static으로 선언해야 한다. 이는 일종의 약속이다. </p><p>main메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당함을 알 수 있다. 그리고 main메소드는 인스턴스가 생성되기 이전에 호출된다. 따라서 static 선언하는 것이 옳음을 알 수 있다.</p><p>다음의 예제를 보자. Car클래스와 Boat 클래스를 정의 하였다. 다음의 main 메소드가 호출이 되어 실제 실행이 되게 하려고 한다면 어떤 클래스에 두어야 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"밴츠"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBoat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보트"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 메소드는 static 메소드이기 때문에, 즉 특정 인스턴스의 맴버로 존재하는 메소드가 아니기 때문에 정답은 어디든 상관은 없다. (물론 실행방식에선 차이가 발생한다. Car클래스에 두었으면 java Car 를 호출, Boat면 java Boat 호출)</p><p>그렇다면 Car클래스에 두었다고 가정해보자. main 메소드를 Car 클래스 내에 위치시켰는데 그 안에서 Car 인스턴스를 생성하고 있다. 혹시 이부분이 조금 난해하게 느껴지는가? 그렇다면 다음과 같이 생각하자.</p><ul><li>Car클래스와 static으로 선언된 main메소드는 사실상 별개다.</li><li>다만 Car 클래스가 main 메소드에게 공간을 제공했을 뿐이다. </li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java08-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%86%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 07. 클래스 변수</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/</guid>
      <pubDate>Sun, 26 Apr 2020 06:43:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;클래스-변수-static-변수&quot;&gt;&lt;a href=&quot;#클래스-변수-static-변수&quot; class=&quot;headerlink&quot; title=&quot;클래스 변수(static 변수)&quot;&gt;&lt;/a&gt;클래스 변수(static 변수)&lt;/h2&gt;&lt;p&gt;인스턴스 변수는 인스턴스가 생성되었을 때, 생성된 인스턴스 안에 존재하는 변수이다. 그러나 클래스 변수는 인스턴스의 생성과 상관없이 존재하는 변수이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스-변수-static-변수"><a href="#클래스-변수-static-변수" class="headerlink" title="클래스 변수(static 변수)"></a>클래스 변수(static 변수)</h2><p>인스턴스 변수는 인스턴스가 생성되었을 때, 생성된 인스턴스 안에 존재하는 변수이다. 그러나 클래스 변수는 인스턴스의 생성과 상관없이 존재하는 변수이다. <a id="more"></a></p><p>클래스 내에 선언된 변수 앞에 static 키워드를 붙이면 이는 인스턴스 변수가 아닌 클래스 변수가 된다. 이러한 클래스 변수의 특성을 파악하기 위해서 다음 예제를 관찰하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> instNum = <span class="number">0</span>;<span class="comment">// 클래스변수 (static 변수)</span></span><br><span class="line"></span><br><span class="line">InstCnt()&#123;<span class="comment">//생성자</span></span><br><span class="line">instNum++; <span class="comment">//static으로 선언된 변수의 값 증가</span></span><br><span class="line">System.out.println(<span class="string">"인스턴스 생성:"</span>+instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Static</span>변수<span class="title">_</span>선언 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InstCnt cnt1 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">InstCnt cnt2 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">InstCnt cnt3 = <span class="keyword">new</span> InstCnt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 InstCount의 생성자에서 static으로 선언된 변수 instNum의 값을 하나 증가시킨  다음에 그 결과를 출력하고 있다. 그런데 출력 결과를 보면 그 값이 인스턴스 생성 시마다 1씩 증가함을 알 수 있다. 그리고 이를 통해 다음 사실을 알 수 있다.</p><ul><li>static으로 선언된 변수는 변수가 선언된 클래스의 모든 인스턴스가 공유하는 변수이다. </li></ul><p>클래스 변수는 인스턴스 내에 존재하는 변수가 아니라 ‘어떠한 인스턴스에도 속하지 않는 상태로 메모리 공간에 딱 하나만 존재하는 변수’ 이다. 다만 이 변수가 선언된 클래스의 인스턴스들은 이 변수에 바로 접근할 수 있는 권한이 있을 뿐 이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote><h2 id="클래스-변수-접근-방법"><a href="#클래스-변수-접근-방법" class="headerlink" title="클래스 변수 접근 방법"></a>클래스 변수 접근 방법</h2><p>클래스 변수도 ‘접근 수준 지시자’ 의 규칙을 그대로 적용받기 때문에 public으로 선언되면 어디서든 접근이 가능하다. 물론 접근 방법에 있어서는 차이를 보이는데 이와 관련된 내용은 이어서 설명하겠다.</p><p>클래스 변수에 접근하는 방법은 접근 영역을 기준으로 다음과 같이 크게 두 가지로 나뉜다.</p><ul><li>클래스 내부 접근 : 변수의 이름을 통해 직접 접근</li><li>클래스 외부 접근 : 클래스 또는 인스턴스의 이름을 통해 접근</li></ul><p>다음예제를 보면서 클래스 변수의 접근 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessWay</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AccessWay()&#123;</span><br><span class="line">incrCnt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++; <span class="comment">//클래스 내부에서 이름을 통한 접근</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example01</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AccessWay way = <span class="keyword">new</span> AccessWay();</span><br><span class="line">way.num++; <span class="comment">//외부에서 인스턴스의 이름을 통한 접근</span></span><br><span class="line">AccessWay.num++; <span class="comment">//외부에서 클래스의 이름을 통한 접근</span></span><br><span class="line">System.out.println(<span class="string">"num = "</span> + AccessWay.num);<span class="comment">// 총 3이 찍힌다.</span></span><br><span class="line"></span><br><span class="line">AccessWay way2 = <span class="keyword">new</span> AccessWay();<span class="comment">//way2라는 새로운 AccessWay의 인스턴스를 생성하였다.</span></span><br><span class="line">System.out.println(way2.num);<span class="comment">//그리고 way2의 클래스변수 num을 조회 하였는데 값은 4가 찍힌다.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인스턴스의 이름을 통한 접근 방법을 보면서, 클래스 변수를 인스턴스 내부에 위치한 것으로 오해하면 안된다. 그리고 클래스 변수 num은 default로 선언되었다. 따라서 클래스 내부는 물론 클래스 외부이더라도 동일 패키지로 묶여 있으면 접근이 가능하다.</p><h2 id="클래스-변수의-초기화"><a href="#클래스-변수의-초기화" class="headerlink" title="클래스 변수의 초기화"></a>클래스 변수의 초기화</h2><p>클래스 변수는 인스턴스의 생성과 상관이 없다고 하였다. 그렇다면 클래스 변수는 언제 메모리 공간에 할당되고 초기화될까? 이와 관련하여 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> instNum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">InstCnt()&#123;</span><br><span class="line">instNum++;</span><br><span class="line">System.out.println(<span class="string">"인스턴스 생성: "</span>+instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스변수<span class="title">_</span>초기화 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InstCnt.instNum -=<span class="number">15</span>; <span class="comment">//인스턴스 생성 없이 instNum에 접근</span></span><br><span class="line">System.out.println(InstCnt02.instNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제를 통해서 언급하고 싶은 내용은 다음과 같다.</p><ul><li>클래스 변수는 인스턴스 생성 이전에 메모리 공간에 존재한다.</li></ul><p>결론을 말하면, 클래스 변수는 해당 클래스 정보가 가상머신에 의해 읽히는 순간 메모리 공간에 할당되고 초기화 된다. 그리고 한 가지 확실한 것은 이러한 할당과 초기화는 위의 예제에서 보이듯이 인스턴스의 생성과 문관하게 이뤄진다는 점이다. 따라서 다음과 같이 생성자를 통한 클래스 변수의 초기화를 진행하지 않도록 주의해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstCnt</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> instNum =<span class="number">100</span>; <span class="comment">//클래스 변수의 정상적인 초기화 방법</span></span><br><span class="line"> </span><br><span class="line"> InstCnt()&#123;</span><br><span class="line"> instNum = <span class="number">0</span>;<span class="comment">// 클래스 변수의 초기화가 아니다!</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 변수 instNum 은 100으로 초기화 된다. 클래스 정보가 가상머신에 의해 읽히는 순간 100으로 초기화된다. 그런데 생성자에서 변수 instNum을 0으로 다시 초기화 한다. 따라서 인스턴스가 생성될 때마다 instNum은 매번 그 값이 0으로 바뀌게 된다.</p><h3 id="클래스로딩"><a href="#클래스로딩" class="headerlink" title="클래스로딩"></a>클래스로딩</h3><p>앞서 설명에서 클래스 정보를 가상머신이 읽는다 는 표현을 썼는데, 이렇듯 가상머신이 특정 클래스 정보를 읽는 행위를 가리켜 클래스 로딩 이라 한다. 그리고 특정 클래스의 인스턴스 생성을 위해서는 해당 클래스가 반드시 가상머신에 의해 로딩되어야 한다. 즉 인스턴스 생성보다 클래스 로딩이 먼저이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java07-%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 06. 정보은닉과 캡슐화</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/</guid>
      <pubDate>Sun, 26 Apr 2020 05:55:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;정보은닉&quot;&gt;&lt;a href=&quot;#정보은닉&quot; class=&quot;headerlink&quot; title=&quot;정보은닉&quot;&gt;&lt;/a&gt;정보은닉&lt;/h2&gt;&lt;p&gt;자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 다음 예제를 다루어보면서 정보은닉이 필요한 이유에 대해서 알아보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="정보은닉"><a href="#정보은닉" class="headerlink" title="정보은닉"></a>정보은닉</h2><p>자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 다음 예제를 다루어보면서 정보은닉이 필요한 이유에 대해서 알아보자.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 정보은닉<span class="title">_</span>예제</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle c = <span class="keyword">new</span> Circle(<span class="number">1.5</span>);</span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">        c.setRad(<span class="number">2.5</span>);</span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">        c.radius = <span class="number">5</span>;<span class="comment">//옳지 않은 접근 방법, 그리고 문제가 되는 부분</span></span><br><span class="line">        System.out.println(c.getArea());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//원의 너비를 구하는 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;<span class="comment">//원의 반지름</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;<span class="comment">//원주율</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        setRad(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRad</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) &#123;<span class="comment">//반지름은 0보다 작을 수 없으므로</span></span><br><span class="line">            radius = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//아무것도 반환하지 않고 메소드에서 빠저나간다.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (radius * radius) * PI;<span class="comment">//원의 너비 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제 18, 19번째 줄에서 보이듯이 인스턴스 변수는 선언과 동시에 초기화를 할 수 있다. 특히 PI의 경우 그 값이 상수이므로 생성자를 통한 초기화보다 위의 방식의 초기화가 더 어울린다. </p><p>그렇다면 25번째 줄의 setRad 메소드를 보자. 위 메소드 정의를 통해서 Circle 클래스를 정의한 이의 다음 의도를 읽을 수 있다.</p><ul><li>반지름의 길이 radius에 0 보다 작은 값이 저장되는 일이 발생하지 않도록 하겠다.</li></ul><p>때문에 이러한 의도를 따르기 위해서라도 반지름의 길이를 변경할 때에는 반드시 위의 메소드 호출을 통해서만 변경을 진행해야 한다. 이렇듯 인스턴스 변수에 저장되는 값의 종류와 범위는 해당 클래스를 정의한 사람이 가장 정확히 안다. 따라서 클래스 사용자가 잘못된 값을 인스턴스 변수에 저장하지 않도록 위와 같은 유형의 메소드를 제공해야한다. 그런데 위의 예제에서는 프로그램 사용자의 실수로 다음과 같은 잘못된 접근이 발생하였다.</p><ul><li>10번째 줄의 c.radius = 5;</li></ul><p>이렇듯 인스턴스 변수의 직접적인 접근을 허용하면, 컴파일 과정에서 드러나지 않는 중대한 실수가 발생할 수 있다. 이러한 오류는 실행 결과에서도 드러나지 않아 더 큰 문제가 된다. 때문에 위와 같은 접근을 허용하지 않도록 클래스를 설계할 필요가 있다. 그리고 이러한 클래스의 설계를 가리켜 ‘정보 은닉’ 이라 한다.</p><h2 id="Getter-와-Setter"><a href="#Getter-와-Setter" class="headerlink" title="Getter 와 Setter"></a>Getter 와 Setter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Getter</span>와<span class="title">Setter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 이전에서 만든 클래스를 '정보 은닉'의 조건을 충족하게 다시 만들어보자. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Circle02 c = <span class="keyword">new</span> Circle02(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"반지름: "</span> + c.getRadius());</span><br><span class="line">System.out.println(<span class="string">"넓 이:"</span> + c.getArea());</span><br><span class="line"></span><br><span class="line">c.setRadius(<span class="number">3.5</span>);</span><br><span class="line">System.out.println(<span class="string">"반지름: "</span> + c.getRadius());</span><br><span class="line">System.out.println(<span class="string">"넓 이:"</span> + c.getArea());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle02</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle02</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">setRadius(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">radius = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">radius = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (radius*radius)*PI;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이전과 다른점들을 살펴보자. 일단 21, 22 번줄의 인스턴스 변수의 선언 앞에 private라는 접근 수준 지시자(접근제한자가 붙어있다.) 그리고 이것이 의미하는 바는 다음과 같다.<ul><li>클래스 내부에서만 접근을 허용하겠다.</li></ul><p>따라서 클래스 외부에서 prviate으로 선언된 변수에 접근할 경우 컴파일 오류가 발생한다. 그렇다면 저 변수를 어떻게 사용해야 할까?</p><p>자바에서는 상태는 외부로부터 숨기고 오직 동작(메소드)를 통해서만 상태를 제어할 수 있는 방식을 권장하고 있다. 따라서 위의 두 유형의 메소드를 통해 값을 설정하고, 전달하는 일을 할 수있다.</p><p>상단의 setRadius는 값의 설정을 위한 메소드이고, 메소드 getRadius는 값의 참조를 위한 메소드이다. 이렇듯 값의 설정과 참조를 위한 메소드를 가리켜 각각 다음과 같이 부른다. </p><ul><li><p>getter</p><ul><li>인스턴스 변수의 값을 참조하는 용도로 정의된 메소드</li><li>변수의 이름이 name일 때, 메소드의 이름은 getName으로 짓는 것이 관계</li></ul></li><li><p>setter</p><ul><li>인스턴스 변수의 값을 설정하는 용도로 정의된 메소드</li><li>변수의 이름이 name일 때 , 메소드의 이름은 setName으로 짓는 것이 관례</li></ul></li></ul><p>private으로 선언된 모든 인스턴스 변수를 대상으로 게터와세터를 반드시 정의해야 하는 것은 아니다. 필요에 따라 정의하면 된다. 그러나 당장 필요하지 않더라도 나중을 고려하여 게터와 세터를 정의하기도 한다.</p><h2 id="접근-수준-지시자"><a href="#접근-수준-지시자" class="headerlink" title="접근 수준 지시자"></a>접근 수준 지시자</h2><p>앞의 예제에서 인스턴스 변수를 대상으로 private 선언을 하였는데, 이러한 유형의 키워드를 가리켜 ‘접근 수준 지시자 (Access-level Modifiers)’ 라 한다. 또는 ‘접근 제한자’ 라고도 한다. 이름 그대로 접근의 허용 수준을 결정할 때 선언하는 키워드이다.</p><p>접근제한자의 종류는 다음과 같이 4가지 이다.</p><ul><li>public, protected, private, default</li></ul><p>이중에서 default는 키워드가 아닌, 아무런 선언도 하지 않은 상황을 의미한다. 비록 이는 키워드가 아닌 일종의 상황이지만 이 역시 접근 제한자의 한 종류로 구분을 한다. </p><p>그리고 이러한 선언을 할 수 있는 대상은 다음 두 가지이다.</p><ul><li>클래스의 정의</li><li>클래스의 인스턴스 변수와 메소드</li></ul><p>클래스의 정의를 대상으로는 다음 두 가지 선언이 가능하다.</p><ul><li>클래스 정의대상 : public ,default</li></ul><p>그리고 인스턴스 변수와 메소드를 대상으로는 다음 네 가지 선언이 모두 가능하다.</p><ul><li>public, protected, private, default</li></ul><p>그럼 이제 각각의 기능을 알아보자. </p><h3 id="클래스-정의-대상의-public-과-default-선언이-갖는-의미"><a href="#클래스-정의-대상의-public-과-default-선언이-갖는-의미" class="headerlink" title="클래스 정의 대상의 public 과 default 선언이 갖는 의미"></a>클래스 정의 대상의 public 과 default 선언이 갖는 의미</h3><ul><li>public : 어디서든 인스턴스(객체) 생성이 가능하다. </li><li>default : 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용한다.</li></ul><h3 id="인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미"><a href="#인스턴스-멤버-대상의-public-protected-private-default-선언이-갖는-의미" class="headerlink" title="인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미"></a>인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미</h3><table><thead><tr><th>접근제한자</th><th>클래스 내부</th><th align="right">동일 패키지</th><th align="center">상속 받은 클래스</th><th align="right">이외의 영역</th></tr></thead><tbody><tr><td>private</td><td>o</td><td align="right">x</td><td align="center">x</td><td align="right">x</td></tr><tr><td>default</td><td>o</td><td align="right">o</td><td align="center">x</td><td align="right">x</td></tr><tr><td>protected</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">x</td></tr><tr><td>public</td><td>o</td><td align="right">o</td><td align="center">o</td><td align="right">o</td></tr></tbody></table><p>위의 표에서 말하는 이외의 영역은 다른 패키지에 속한 클래스를 뜻한다. 즉 서로 다른 패키지에 속한 두 클래스 사이의 접근을 의미한다. 그리고 위 표의 내용을 기준으로 접근 허용 범위에 대하여 다음과 같이 이해하고 있는 것도 도움이 된다. </p><ul><li>public &gt;  protected &gt; default &gt; private</li></ul><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>캡슐화는 정보 은닉과 더불어 객체지향 기반의 클래스 설계에 있어 가장 기본이면서 중요한 원칙 중 하나이다. 캡슐화는 문법적인 내용은 아니다. 클래스 안에 ‘무엇을 넣을까’ 에 대한 이론을 제시한는 내용이다.</p><p>캡슐화를 다음과 같이 정의할 수 있다. </p><ul><li>하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 캡슐에 담아 두는 것</li></ul><p>물론 객체지향 관점에서 위의 캡슐은 클래스에 해당한다. 즉 위의 문장은 다음과 같이 다시 쓸 수 있다.</p><ul><li>하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 클래스에 담아 두는 것</li></ul><p>무조건 많이 담는다고 해서 캡슐화가 아니다. 부족해도 안되고 넘쳐도 문제가 된다. 그리고 상황 및 목적에 따라서 동일한 이름의 클래스에도 담기는 내용이 달라진다. 캡슐화에 대한 예제들은 github 에 올려두었던 다음 예제들을 참고하면 괜찮을 것 같다.</p><ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9401.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 01</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9402.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 02</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch06_%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%EC%BA%A1%EC%8A%90%ED%99%94/%EC%BA%A1%EC%8A%90%ED%99%9403.java" rel="external nofollow noopener noreferrer" target="_blank">캡슐화 예제 03</a></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java06-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EA%B3%BC%20%EC%BA%A1%EC%8A%90%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 05. 클래스의 정의</title>
      <link>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/</guid>
      <pubDate>Sun, 26 Apr 2020 05:45:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;클래스와-인스턴스&quot;&gt;&lt;a href=&quot;#클래스와-인스턴스&quot; class=&quot;headerlink&quot; title=&quot;클래스와 인스턴스&quot;&gt;&lt;/a&gt;클래스와 인스턴스&lt;/h2&gt;&lt;p&gt;자바로 작성된 코드를 관찰해보면 종류에 상관 없이 모든 프로그램은 다음 두가지로 이뤄진다는 사실을 알 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 : 프로그램상에서 유지하고 관리해야 할 데이터&lt;/li&gt;
&lt;li&gt;기능 : 데이터를 처리하고 조작하는 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이중에서 데이터는 ‘변수의 선언’ 을 통해 유지 및 관리가 되고, 또 변수에 저장된 데이터는 ‘메소드의 호출’을 통해 처리가 된다. 이와 관련해서 다음 예제를 살펴보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="클래스와-인스턴스"><a href="#클래스와-인스턴스" class="headerlink" title="클래스와 인스턴스"></a>클래스와 인스턴스</h2><p>자바로 작성된 코드를 관찰해보면 종류에 상관 없이 모든 프로그램은 다음 두가지로 이뤄진다는 사실을 알 수 있다.</p><ul><li>데이터 : 프로그램상에서 유지하고 관리해야 할 데이터</li><li>기능 : 데이터를 처리하고 조작하는 기능</li></ul><p>이중에서 데이터는 ‘변수의 선언’ 을 통해 유지 및 관리가 되고, 또 변수에 저장된 데이터는 ‘메소드의 호출’을 통해 처리가 된다. 이와 관련해서 다음 예제를 살펴보자.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BankAccountPO.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankAccountPO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> balance = <span class="number">0</span>; <span class="comment">// 예금 잔액</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        deposit(<span class="number">10000</span>); <span class="comment">//입금 진행</span></span><br><span class="line">        checkMyBalance();</span><br><span class="line">        withdraw(<span class="number">3000</span>);</span><br><span class="line">        checkMyBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;<span class="comment">//입금을 담당하는 메소드</span></span><br><span class="line">        balance += amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;<span class="comment">//출금을 담당하는 메소드</span></span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span></span>&#123;<span class="comment">//예금 조회를 담당하는 메소드</span></span><br><span class="line">        System.out.println(<span class="string">"잔액: "</span> +balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 BankAcountPO 를 보면 맴버변수 balance 와 메소드 deposit, withdraw, checkMyBalance 는 긴밀히 연관되어 있다. 긴밀히 연관되어있다는 것은 다음 내용을 뜻한다.</p><ul><li>메소드 deposit, withdraw, checkMyBalance는 맴버변수 balance를 위한 메소드이다.</li></ul><p>이렇듯 연관 잇는 변수와 메소드를 묶기 위해 ‘클래스’라는 것이 존재한다. 클래스를 이용하면 다음과 같이 변수 balance 그리고 이와 연관 있는 모든 메소드를 하나로 묶을 수 있다. 위의 코드를 가르켜 <strong>‘클래스 정의’</strong>라 한다.</p><h2 id="인스턴트-만들기"><a href="#인스턴트-만들기" class="headerlink" title="인스턴트 만들기"></a>인스턴트 만들기</h2><p>상단에 선언된 변수 balance는 ‘인스턴트 변수’ 라고 한다. (또는 멤버변수, 필드 라고 불리기도 한다.) 인스턴트 변수 balance를 위해 존재하는 하위 메소드들은 ‘인스턴트 메소드’라고 한다.</p><p>인스턴트 변수는 앞서 변수의 스코프에서 다루었던 지역변수가 아니다.  인스턴트 변수가 선언된 위치는 메소드 내부가 아니므로 이 둘은 성격이 다르다. 이러한 인스턴스 변수의 중요한 특징 중 하나는 다음과 같다.</p><ul><li>인스턴스 변수는 같은 클래스 내에 위치한 메소드 내에서 접근이 가능하다.</li></ul><p>다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccountPO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"잔액: "</span> +balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 인스턴스만들기 </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @인스턴스</span></span><br><span class="line"><span class="comment">         * 위의 문장을 실행하면 밑에 만들어둔 BankEx 에 정의된 변수와 메소드를 담고 있는 '인스턴스'라는 것이 </span></span><br><span class="line"><span class="comment">         * 만들어진다. 만들어져서 실제 메모리 공간에 존재하게 된다.</span></span><br><span class="line"><span class="comment">         * (인스턴스는 다른말로 객체라고도 한다. 인스턴스의 생성과 객체의 생성은 그 의미가 완전히 동일하다.)</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 물론 다음과 같이 둘, 혹은 그 이상도 만들 수 있다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line">        <span class="keyword">new</span> BankAccountPO();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 이렇게 메모리상에 인스턴스를 만들기만 해서는 사용할 수가 없다. </span></span><br><span class="line"><span class="comment">         * 만들어진 인스턴스를 참조할 수 있는 무언가가 필요하다. </span></span><br><span class="line"><span class="comment">         * 그리고 이 무엇인가를 가리켜 '참조변수(Reference Variable)'이라고 한다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BankAccountPO june; <span class="comment">//참조변수 myAcnt1의 선언</span></span><br><span class="line">        BankAccountPO james; <span class="comment">//참조변수 myAcnt2의 선언</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 즉 다음과 같이 참조변수를 선언하고 이를 통해서 새로 생성되는 인스턴스(객체)를 가리키게 할 수 있다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        june = <span class="keyword">new</span> BankAccountPO02();<span class="comment">//참조변수 june 이 새로 생성되는 인스턴스를 가리킴</span></span><br><span class="line">        james = <span class="keyword">new</span> BankAccountPO02();<span class="comment">//참조변수 james 가 새로 생성되는 인스턴스를 가리킴</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@new</span></span></span><br><span class="line"><span class="comment">          * 키워드 new 를 통해서 인스턴스를 생성하면 생성된 인스턴스의 주솟값이 반환된다.</span></span><br><span class="line"><span class="comment">            즉 참조변수에는 생성된 인스턴스의 주솟값이 저장되는 셈이다. </span></span><br><span class="line"><span class="comment">            하지만 다음과 같이 표현하고 인식하자. 이것보다 일반적인 표현이다.</span></span><br><span class="line"><span class="comment">            (주솟값은 참조변수에 저장된 값이기에 본서에서는 이 값을 '참조 값' 이라고 한다.)</span></span><br><span class="line"><span class="comment">            - 참조변수는 인스턴스를 참조한다.</span></span><br><span class="line"><span class="comment">            - 참조변수는 인스턴스를 가리킨다.</span></span><br><span class="line"><span class="comment">            그리고 참조변수를 통해서 해당 인스턴스의 메소드를 호출하는것은 다음과 같다.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//각 인스턴스를 대상으로 예금을 진행</span></span><br><span class="line">          june.deposit(<span class="number">10000</span>);</span><br><span class="line">          james.deposit(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//각 인스턴스를 대상으로 잔액을 조회</span></span><br><span class="line">          System.out.println(<span class="string">"myAcnt1의 잔액 :"</span>);</span><br><span class="line">          june.checkMyBalance();</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"myAcnt2의 잔액 :"</span>);</span><br><span class="line">          james.checkMyBalance();</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 코드와 실행 결과를 보면, 참조변수 준과 제임스가 가리키는 인스턴스가 </span></span><br><span class="line"><span class="comment">           * 서로 다른 인스턴스인 것을 알 수 있다.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * @참조변수에 null 대입</span></span><br><span class="line"><span class="comment">              때로는 참조변소가 참조하는 인스턴스와의 관계를 끊고 아무런 인스턴스도 참조하지 않도록</span></span><br><span class="line"><span class="comment">              할 필요가 있다. 그리고 이때에는 다음과 같이 참조변수에 null을 대입하면 된다.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            james = <span class="keyword">null</span>;</span><br><span class="line">            june = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="인스턴스의-구분"><a href="#인스턴스의-구분" class="headerlink" title="인스턴스의 구분"></a>인스턴스의 구분</h2><p>앞서 정의한 BankAccount클래스를 다시 관찰해보자. 은행에서는 고객이 계좌를 개설할 때마다 이 클래스의 인스턴스를 생성해야 한다.</p><p>그런데 문제는 인스턴스를 구분할 수 있는 정보가 빠졌다는 것이다. 즉 이전 예제에 최소한 다음 두가지 정도는 추가가 되어야 한다. 그래야 누구의 계좌인지 구분할 수 있다.</p><ul><li>계좌번호 </li><li>주민번호 </li></ul><p>이것을 반영하여 새로운 클래스를 만들어보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 인스턴트만들기</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BankAccount jaebeom = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line">jaebeom.initAccount(<span class="string">"123-456-789"</span>, <span class="string">"950621"</span>, <span class="number">10000</span>);</span><br><span class="line">jaebeom.deposit(<span class="number">5000</span>);</span><br><span class="line">jaebeom.checkMyBalance();</span><br><span class="line"></span><br><span class="line">BankAccount jongwon = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line">jongwon.initAccount(<span class="string">"321-654-987"</span>, <span class="string">"960113"</span>, <span class="number">10000</span>);</span><br><span class="line">jongwon.withdraw(<span class="number">3000</span>);</span><br><span class="line">jongwon.checkMyBalance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span></span>&#123;</span><br><span class="line">String accNumber;<span class="comment">//계좌번호</span></span><br><span class="line">String ssNumber;<span class="comment">//주민번호</span></span><br><span class="line"><span class="keyword">int</span> balance = <span class="number">0</span>;<span class="comment">//예금 잔액</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화를 위한 메소드</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAccount</span><span class="params">(String acc, String ss, <span class="keyword">int</span> bal)</span> </span>&#123;</span><br><span class="line">accNumber = acc;</span><br><span class="line">ssNumber = ss;</span><br><span class="line">balance = bal; <span class="comment">//계좌 개설 시 예금액으로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance +=amount;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance -=amount;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMyBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"계좌번호:"</span>+accNumber);</span><br><span class="line">System.out.println(<span class="string">"주민번호:"</span>+ssNumber);</span><br><span class="line">System.out.println(<span class="string">"잔액:"</span>+balance+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>이번 예제에서는 새로운 메소드 initAccount가 추가되었다. 이 메소드는 다음과 같은 부분에서 다른 메소드들과 성격상 구분이 된다. </p><p>-인스턴스의 초기화를 위한 메소드이다.<br>-때문에 인스턴스 생성 시 반드시 한번 호출해서 초기화를 진행해야한다.</p><p>그러나 위와 같이 메소드를 정의하지 않고 <strong>‘생성자(Constructor)’</strong>라는 것을 정의해서 인스턴스의 초기화를 진행할 수도 있다. 생성자는 인스턴스 생성 과정에서 초기화를 위해 자동으로 호출되는 일종의 메소드이다. </p><h2 id="생성자의-정의"><a href="#생성자의-정의" class="headerlink" title="생성자의 정의"></a>생성자의 정의</h2><p>생성자는 메소드와 모습이 같다. 따라서 생성자를 ‘생성자 메소드’ 로 표현하는 경우도 있다. 그러나 생성자는 다음과 같은 부분에서 메소드와 차이가 있다. 달리 말하면 이는 생성자가 되기 위한 조건이기도 하다.</p><ul><li>생성자의 이름은 클래스의 이름과 동일해야 한다.</li><li>생성자는 값을 반환하지 않고 반환형도 표시하지 않는다. </li></ul><p>위의 조건을 모두 만족하면 이는 자바 컴파일러에 의해서 생성자로 인식된다. 따라서 인스턴스 생성 시 자동으로 호출되어 인스턴스를 초기화 하게 된다. 그럼 앞서 예제에서 인스턴스 초기화를 위해 생성자를 만들어보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">//this키워드는 class의 인스턴스 변수 자신을 가리킨다. 나중에 더 자세히 다루어보자.</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"저의 이름은 "</span> +name+<span class="string">" 입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"나이는 "</span>+ age +<span class="string">" 입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에 생성자를 보면 클래스와 이름이 동일하다. 그리고 반환하지 않으며 , 반환형도 선언하지 않았다. 따라서 생성자의 조건을 모두 갖췄다. 그리고 인스턴스를 메소드 main에서 생성할때 매개변수로 이름과 나이가 전달이 된다.</p><p>즉 위와같이 문장을 구성하면 ‘인스턴스 생성 마지막 단계’ 에서 다음의 생성자가 호출되면서 값들이 전달된다. 그리고 이 값들로 인스턴스 변수가 초기화 된다.</p><p>생성자와 관련하여 다음 사실을 반드시 기억해야 한다.</p><ul><li>인스턴스 생성의 마지막 단계는 생성자 호출이다.</li><li>어떠한 이유로든 생성자 호출이 생략된 인스턴스는 인스턴스가 아니다.</li></ul><h3 id="디폴트-생성자-Default-Constructor"><a href="#디폴트-생성자-Default-Constructor" class="headerlink" title="디폴트 생성자(Default Constructor)"></a>디폴트 생성자(Default Constructor)</h3><p>인스턴스 생성의 마지막 단계는 생성자 호출이라 하였다. 그리고 생성자 호출이생략된 인스턴스는 인스턴스가 아니라고 하였다. 하지만 앞서 생성자가 없는 클래스를 수차례 정의하였고 이들을 대상으로 인스턴스를 생성한 바 있다. 그렇다면 이렇게 생성된 인스턴스는 인스턴스가 아니란 뜻인가?<br>사실 다음과 같이 생성자를 생략한 상태의 클래스를 정의하면 자바 컴파일러가 ‘디폴트 생성자’ 라는 것을 클래스의 정의에 넣어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">//디폴트 생성자</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 보이듯이, 디폴트 생성자는 인자를 전달받지 않는 형태로 정의되어 삽입된다. 물론 내부적으로 하는 일도 없다. 하지만 이로 인해서 인스턴스의 생성 규칙인 ‘생성자의 호출’ 은 유지가 된다. 생성자를 정의하지 않더라도 말이다. 그런데 컴파일러에 의해서 디폴트 생성자가 삽입이 되더라도 생성자는 직접 정의해주는것이 좋다.    아주 예외적인 상황이 아니라면, 생성자가 필요 없는 클래스는 잘 정의된 클래스가 아닐 확률이 높기 때문이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/26/java/java05-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98%20%EC%A0%95%EC%9D%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 04. 메소드와 변수의 스코프</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
      <pubDate>Wed, 22 Apr 2020 09:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;메소드의-정의&quot;&gt;&lt;a href=&quot;#메소드의-정의&quot; class=&quot;headerlink&quot; title=&quot;메소드의 정의&quot;&gt;&lt;/a&gt;메소드의 정의&lt;/h2&gt;&lt;p&gt;앞서 예제를 작성하고 호출하기 위해 main메소드 안에서 작업한것을 알 수 있다. main메서드는 클래스의 내부에 존재해야한다.&lt;/p&gt;
&lt;p&gt;지금까지 만들어온 메서드의 이름이 항상 main인 이유는 다음 약속에 근거한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="메소드의-정의"><a href="#메소드의-정의" class="headerlink" title="메소드의 정의"></a>메소드의 정의</h2><p>앞서 예제를 작성하고 호출하기 위해 main메소드 안에서 작업한것을 알 수 있다. main메서드는 클래스의 내부에 존재해야한다.</p><p>지금까지 만들어온 메서드의 이름이 항상 main인 이유는 다음 약속에 근거한다. <a id="more"></a> 자바 프로그램은 main이라는 이름의 메소드에서부터 시작을 한다. 따라서 추가로 만들게 될 메소드의 이름은 다음과 같이 직접 결정하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hiEveryone</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"좋은 아침입니다."</span>);</span><br><span class="line">    System.out.println(<span class="string">"제 나이는 "</span> + age+<span class="string">" 입니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드 내용을 가리켜 ‘메소드 정의’라 한다. 즉 위의 코드는 ‘메소드 hiEveryone의 정의’이다. hiEveryone의 오른편 소괄호에는 정수형 변수 age가 있다. 이 변수가 어떻게 활용되는지 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    hiEveryone(<span class="number">26</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 결과를 보면 </p><p>‘좋은 아침입니다. 제 나이는 26입니다.’</p><p>가 출력되는 것을 볼 수 있다.</p><p>즉 main 메서드에서 hiEveryone메서드를 호출하고 파라미터로 26을 전달하는 것 이다. 일단 public 과 static은 무시하고  여기서 알 수 있는건 메서드를 정의 할때는</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">자료형(리턴타입) | 메서드명 | (매개변수를 받으면 소괄호안에 해당하는 타입의 변수를 작성)&#123;</span><br><span class="line"><span class="comment">//중괄호 안에 로직 작성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>으로 만들 수 있고, 메서드 사용시에는 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">메서드명(매개변수를 만들었다면, 전달할 인자값 작성);</span><br></pre></td></tr></table></figure><p>으로 사용할 수 있다. 물론 매개변수는 하나 이상 사용이 가능하다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myInfo</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"제 이름은 "</span>+ name+<span class="string">" 이고, 나이는 "</span> + age+<span class="string">" 입니다."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    myInfo(<span class="string">"고재범"</span>, <span class="number">26</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 매개변수를 두개, 혹은 그이상도 사용할 수 있다.</p><h2 id="메소드의-반환값"><a href="#메소드의-반환값" class="headerlink" title="메소드의 반환값"></a>메소드의 반환값</h2><p>이전에 다루었던 method는 매개변수를 사용하는 정도까지 알아보았다. 하지만 method의 실제 사용되는 모습이랑은 많이 다르다. 이번엔 method를 정의할 때 값을 반환 하는 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 메소드를 보면 void였던 부분에 int 가 들어가있다. 저 부분은 반환형을 지정하는 곳 인데, 지금까지 값을 반환하지 않았기 때문에 void를 사용하였다. </p><p>void는 값을 return 하지 않는다고 선언하는 방법이다. 하지만 위의 예제는 정수타입의 값을 return하고 있기때문에 반환형으로 int를 사용하였다. 그럼 return의 정확한 의미는 무엇일까? 다음과 같다.</p><ul><li>메소드를 호출한 영역으로 값을 반환.</li><li>메소드의 종료</li></ul><p>메소드의 종료는 알겠는데, 메소드를 호출한 영역으로 값을 반환한다는건 무슨 소리일까? 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정수형 변수 num을 선언하고 add()메소드로 초기화하고있다. 메소드 add는 반환 타입이 정수였다. 그렇기때문에 정수형 변수의 값으로 담을 수 있게 되는 것 이다. 이때는 정확히 메소드 add의 반환 값이 담긴다고 생각하면 되겠다.</p><p>이것은 위에서 설명한 메소드를 호출한 영역으로 값을 반환한다는 것과 같은 맥락이다. 위의 목적은 메소드 add에게 값을 전달해 연산을 하도록하여 연산된 값을 이부분에서 출력해보기 위한 것 같다. 그렇다면 저렇게 변수에 담지 않고 바로 출력하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(add(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메소드의-재귀적호출-맛보기"><a href="#메소드의-재귀적호출-맛보기" class="headerlink" title="메소드의 재귀적호출(맛보기)"></a>메소드의 재귀적호출(맛보기)</h2><p>자바는 메소드의 ‘재귀적 호출’을 지원한다.따라서 이에 대해 설명할 텐데, 메소드의 재귀적 호출은 자료구조와 알고리즘의 구현에 유용한 문법이므로 조금 내용이 어렵다.</p><h3 id="수학적-측면에서의-재귀적인-사고"><a href="#수학적-측면에서의-재귀적인-사고" class="headerlink" title="수학적 측면에서의 재귀적인 사고"></a>수학적 측면에서의 재귀적인 사고</h3><p>고등학교 수학에서 접하는 팩토리얼(Factorial)은 기호 !으로 표현하며 계산 방식은 다음과 같다.</p><p>5! = 5 x 4 x 3 x 2 x 1<br>4! = 4 x 3 x 2 x 1<br>3! = 3 x 2 x 1<br>2! = 2 x 1<br>1! = 1</p><p>때문에 위의 팩토리얼의 계산식은 다음과 같이 쓸 수 있다.<br>5! = 5 x 4!<br>4! = 4 x 3!<br>3! = 3 x 2!<br>2! = 2 x 1!<br>1! = 1<br>(뭐하는 건지 모르겟다;; 수학공부좀 열심히할껄..)</p><p>위의 식에서 재귀(순환)를 발견할 수 있다. 팩토리얼의 계산식에 다시 팩토리얼이 등장한 이 상황이 바로 ‘재귀’이기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"3 factorial : "</span> + factorial(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="comment">//if문 다음으로 오는 내용이 한줄만있다면 &#123;중괄호&#125;를 생략 가능하다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>본인도 아직 완벽히 이해하지 못했음으로 설명은 생략하겠다..ㅎ</p><h2 id="변수의-스코프"><a href="#변수의-스코프" class="headerlink" title="변수의 스코프"></a>변수의 스코프</h2><p>지금까지 중괄호 {…}가 사용되었던 때를 정리해 보면 다음과 같다.</p><ul><li>if문 또는 switch문 같은 조건문에 사용되었다</li><li>for , while등의 반복문에 사용되었다.</li><li>메소드의 몸체 부분을 감싸는 용도로 사용되었다. </li></ul><p>이처럼 중괄호는 다양한 경우에 사용된다. 그런데 이렇듯 중괄호로 특정 영역을 감싸면, 해당 영역은 변수에 관한 별도의 스코프를 형성하게 된다. 예를 들어서 다음과 같이 if문 안에 변수가 선언되게 되면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(num); 주석을 처리하면 에러가 난다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if문 밖에서는 변수 num을 사용할 수 없다. 이 변수 num은 중괄호 내에서만 접근이 가능하며,중괄호를 벗어나는 순간 소멸되어 접근이 불가능한 변수가 된다. 좋은 예는 아니지만 이말은 즉 똑같은 변수명으로 괄호 밖에서 다시 선언할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(num); 주석을 처리하면 에러가 난다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지 설명한 중괄호 내에 선언된 변수들을 가리켜 ‘지역변수(Local Variable)’라 한다. 그리고 for문의 초기화 부분에서 선언되는 변수화 매개변수까지도 지역변수의 범주에 포함된다. 그런데 이러한 지역변수들이 갖는 중요한 특징이 하나 있다.</p><ul><li>지역변수는 선언된 지역을 벗어나면 메모리 공간에서 소멸된다.</li></ul><p>즉 선언된 지역을 벗어나면 단순히 접근만 불가능해지는 것이 아니라 메모리상에서 삭제가 되는 것이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java04-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 03. 실행흐름의 컨트롤</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/</guid>
      <pubDate>Wed, 22 Apr 2020 08:16:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건문이란&quot;&gt;&lt;a href=&quot;#조건문이란&quot; class=&quot;headerlink&quot; title=&quot;조건문이란?&quot;&gt;&lt;/a&gt;조건문이란?&lt;/h2&gt;&lt;p&gt;조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="조건문이란"><a href="#조건문이란" class="headerlink" title="조건문이란?"></a>조건문이란?</h2><p>조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다. <a id="more"></a></p><h3 id="if문"><a href="#if문" class="headerlink" title="if문"></a>if문</h3><p>특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 키워드 if를 사용하면 된다. 그리고 두개의 문장 중 조건에 따라 하나만 실행하고 싶다면 거기에 else를 더 추가하면 된다. else는 if문 소괄호의 조건이 참이 아니라면 실행되는 곳이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if문 예제</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    <span class="comment">//조건 true 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"참입니다"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//조건 false 시 실행되는 영역</span></span><br><span class="line">    System.out.println(<span class="string">"거짓입니다"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if ~ else if 문은 2개 이상의 조건을 주고싶을 때 사용할 수 있는 방법이다. 밑의 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if ~ else if문 예제</span></span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1보다 num2가 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num2보다 num1이 큽니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 == num2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"num1과 num2는 같습니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"셋다 해당되지 않습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조건-연산자"><a href="#조건-연산자" class="headerlink" title="조건 연산자"></a>조건 연산자</h3><p>조건 연산자는 피연산자가 세 개인 연산자이다. (자바스크립트의 삼항연산자와 비슷하다.) 이러한 조건 연산자는 간단한 if~else문을 대체하는 용도로 주로 사용된다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//조건 연산자 예제</span></span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num5 = (<span class="keyword">false</span>) ? num3 : num4;</span><br><span class="line">System.out.println(<span class="string">"결과 : "</span>+ num5);</span><br></pre></td></tr></table></figure><p>변수 num5 는 선언과 동시에 조건연산자에 의한 값을 할당한다. ()안의 조건이 참이면 num3이 저장될 것이고 , 거짓이라면 num4가 저장될 것 이다. 하지만 임의적으로 false라는 값을 줌으로써 변수 num5에는 num4의 값, 즉 20이 저장되는것을 알 수 있다.</p><h3 id="switch문"><a href="#switch문" class="headerlink" title="switch문"></a>switch문</h3><p>조건에 따라 실행할 문장을 구분한다는 측면에서 if문과 유사하다. else if가 많이 들어가는 상황에서는 switch문이 더 좋은 선택이 될 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    String animal = <span class="string">"고양이"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">        System.out.println(<span class="string">"강아지가 맞습니다"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">        System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>레이블(Label)</strong></p><p>위의 switch 내부에 존재하는 키워드 case와 default를 가리켜 레이블이라고 한다. 레이블 case와 default는 코드상에서 위치를 표시하기 위해 사용된다. case는 switch 의 조건과 같은 타입을 가져야하고 같은 결과 값일 경우 그 case 이후의 값들이 출력이된다. 이것은 이후에 나오는 break문으로 제어할 수 있다. </p><p>default는 case에서 switch와 같은 조건의 값이 없다면 실행되는 구문이다. 그리고 case와 default를 보면 들여쓰기가 되어있지 않다. 이는 책에 위치를 표시하는 레이블과 그 성격이 같다. 그리고 레이블은 책을 펼치기 전에 보여야 한다. 이와 마찬가지로 case와 default도 조금이라도 잘 보이도록 들여쓰기 대상에서 제외하는 것이 일반적이다.</p><p>일단 위의 결과를 보게되면 switch의 참거짓을 판단하는 매개변수로 animal이라는 변수를 주었다. 이 변수에 할당된 값은 ‘고양이’ 이다. 당연히 콘솔에 고양이가 맞습니다. 라고 찍힐 것이라고 예상할 수 있지만 결과는 고양이가 맞습니다. 이후에 나오는 모든 조건의 결과</p><p>고양이가 맞습니다.<br>고라니가 맞습니다.<br>해당하는 동물이 없습니다.</p><p>가 찍힌다.</p><p>이는 break 라는 키워드로 case의 실행구문이 끝난 이후 사용해 주어야 하위 case들이 실행 되는 것을 막을 수 있다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(animal) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고양이"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고양이가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"강아지"</span>:</span><br><span class="line">    System.out.println(<span class="string">"강아지가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"고라니"</span>:</span><br><span class="line">    System.out.println(<span class="string">"고라니가 맞습니다."</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">    System.out.println(<span class="string">"해당하는 동물이 없습니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 switch문과는 다르게 각 case가 끝나는 부분에 break가 추가 되었다. 그리고 결과로는 고양이가 맞습니다. 이후의 출력은 사라졌다. 즉 if, else처럼 해당하는 조건에 맞는 결과값만이 출력이 되는 것을 확인 할 수 있다. 이는 switch문의 일반적인 사용 모델이다.</p><hr><h2 id="반복문이란"><a href="#반복문이란" class="headerlink" title="반복문이란?"></a>반복문이란?</h2><p>반복문은 어떤 작업이 반복적으로 수행되도록 할 때 사용된다. while, do~while, for문등을 예로 들 수 있다.</p><h3 id="while문"><a href="#while문" class="headerlink" title="while문"></a>while문</h3><p>먼저 while 문 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//While문</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 결과는 I Like Java가 5번 출력되는 것을 알 수 있다.</p><ul><li>while문의 소괄호에는 반복의 조건을 명시한다. </li><li>true 또는 false가 와야 하므로 이를 반환하는 연산이 오게 된다. </li><li>그리고 그 조건이 true를 반환하는 동안에는 횟수에 상관없이 while문의 중괄호가 반복 실행되는데 , 다음의 패턴으로 반복이 된다.<ol><li>먼저 조건검사</li><li>그리고 결과가 true이면 중괄호 영역 실행</li></ol></li></ul><p>반면에 밑에 예제에서 다루는 do ~ while문은 다음의 패턴으로 진행한다.</p><ol><li>먼저 중괄호 영역 실행</li><li>그리고 조건 검사 후 결과가 true이면 반복 결정<br>밑의 예제를 확인해 보자.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_while문</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"I Like Java "</span> + num2);</span><br><span class="line">    num2++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num2 &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br><p>위 예제는 이전의 while문을 do-while로 바꾼것 뿐이다. 따라서 실행결과는 동일하다. 보는것처럼 while문으로 작성된 문장은 do-while로도 작성가능한 경우가 대부분다. </p><p>따라서 “조건에 따른 반복이 필요하다. 그런데 반드시 한 번은 실행을 해야 한다.” 라는 경우에는 do~while문을 사용하는 것이 괜찮다. 이 이외의 경우에는 while문 또는 이어서 소개하는 for문을 사용하는 것이 바람직하다. 그래야 선택하는 반복문에 더 많은 의미를 부여할 수 있다. </p><h3 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h3><p>이전에 다루었던 while문에서 했던 예제들은 거의 반복하는 값이 정해져있었다. 이처럼 ‘반복의 횟수가 정해져 있는 상황’ 에서는 for문을 이용해서 다음과 같이 작성하는 것이 더 간결하고 뜻도 더 잘 통한다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for문 예제</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I Love Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서 실행 흐름을 보자면 </p><ol><li>변수의 선언및 초기화</li><li>반복 조건이 true인지 확인</li><li>반복 영역을 실행 (반복 조건이 true이면)</li><li>변수의 값 증가<br>그리고 그 이후 두번째 반복부터는 첫번째 조건인 변수의 선언및 초기화 부분은 지나치게 된다. </li></ol><h3 id="break-와-continue"><a href="#break-와-continue" class="headerlink" title="break 와 continue"></a>break 와 continue</h3><p>break 문은 앞서 switch문을 빠져나가는 용도로 다루었었는데, 마찬가지로 반복문을 빠져나가는 용도로도 사용된다.<br>보통 if문과 함께 사용되어 특정 조건이 만족될 때, 이를 감싸는 반복문을 빠져나가도록 구성이 된다. break는 이전에 다루던 것과 별 차이가 없기 때문에 따로 예제를 다루지 않는다.</p><p>continue문은 break문과 혼동하기 쉬워서 주의가 필요하다. 우선 continue는 반복문의 탈출과 거리가 멀다. 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건 검사 부분으로 이동시킨다. 밑의 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n++)&lt;<span class="number">5</span>) &#123;<span class="comment">//while 하단부에서 증가시켜줬던 구문을 이런식으로 작성할 수 있다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"I Like Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 구문을 실행시켜보면 총 4번 실행 되는 것을 알 수 있다. 0~4까지 총 5번 출력되는 것이 맞는 것 이라고 생각 할 수 있는데, 이유는 조건에 따른 continue 구문이 실행하게 되면 그 이후의 문장은 무시하고 다시 반복문의 조건 검사로 이동하게 되기때문이다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java03-%EC%A0%9C%EC%96%B4%EB%AC%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 02. 상수와 형변환</title>
      <link>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</link>
      <guid>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/</guid>
      <pubDate>Wed, 22 Apr 2020 07:22:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;상수의-특징&quot;&gt;&lt;a href=&quot;#상수의-특징&quot; class=&quot;headerlink&quot; title=&quot;상수의 특징&quot;&gt;&lt;/a&gt;상수의 특징&lt;/h3&gt;&lt;p&gt;자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값을 딱 한 번만 할당할 수 있다.&lt;/li&gt;
&lt;li&gt;한 번 할당된 값은 변경이 불가능하다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="상수의-특징"><a href="#상수의-특징" class="headerlink" title="상수의 특징"></a>상수의 특징</h3><p>자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. </p><ul><li>값을 딱 한 번만 할당할 수 있다.</li><li>한 번 할당된 값은 변경이 불가능하다.<a id="more"></a></li></ul><p>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mina</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span> CONST_CHAR = <span class="string">'상'</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CONST_ASSIGNED; </span><br><span class="line">    CONST_ASSIGNED = <span class="number">12</span>; <span class="comment">//할당하지 않았던 상수의 값 할당.</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(MAX_SIZE);</span><br><span class="line">    System.out.println(CONST_CHAR);</span><br><span class="line">    System.out.println(CONST_ASSIGNED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서는 다음과 같이 변수의 선언에 final을 추가하였다. 따라서 이 변수는 값의 변경이 불가능한 상수가 된다. CONST_ASSIGNED처럼 선언만해놓았다면 딱 한번 값을 할당할 수 있다. 물론 그이후로는 불가능 하다.</p><p><strong>상수의_관례</strong><br>그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다.</p><ul><li>상수의 이름은 모두 대문자로 짓는다.</li><li>이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.</li></ul><h2 id="리터럴-상수에-대한-이해"><a href="#리터럴-상수에-대한-이해" class="headerlink" title="리터럴 상수에 대한 이해"></a>리터럴 상수에 대한 이해</h2><p>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">157</span>;</span><br></pre></td></tr></table></figure><p>대입연산자의 오른편에 위치한 숫자 157을 리터럴 또는 리터럴 상수 라고한다. 컴파일러는 위 변수에 대입한 숫자 157을 무엇으로 인식할까?   결론은 int형 정수로 인식한다. 다음 예제를 통해 좀더 이해를 도와보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> num = <span class="number">3146234266</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>에러처리가 나서 주석처리를 하였다. </p><p><em>The literal 3146234266 of type int is out of range</em></p><p>라는  에러가 뜨는 것을 확인하였다. 숫자 3146234266 는 int형 정수여야하는데 값이 너무크다라고 한다. 이게 이해가 가지 않는다 당연히 큰숫자인것을 알고있기때문에 일부러 int가 아닌 long자료형의 변수에 값을 할당했는데 이런 오류가 나다니..</p><p>위에서도 언급하지만, 왼편에 있는 변수의 자료형에 상관없이 정수는 int형으로 표현하기로 약속되어있다. 그래서 위와같은 오류 메시지가 발생하는 것이다. 그렇다면 long형 변수에 다음과같은 큰 값을 어떻게 저장할 수 있을까?</p><h3 id="형-변환"><a href="#형-변환" class="headerlink" title="형 변환"></a>형 변환</h3><p><strong>자동 형변환</strong><br>다음 예제를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">long</span> num2 = <span class="number">3147483647L</span>;</span><br><span class="line">System.out.println(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 상황에서는 int형 변수에 담긴 값을 long형으로 변환해야 데이터의 손실 없이 연산이 가능하다. 따라서 다음의 과정을 거쳐서 연산을 마무리한다.</p><ul><li>변수 num1에 저장된 값을 long형으로 변환하여 메모리에 임시 저장한다.</li><li>이어서 이 변환된 값과 num2에 저장된 값을 대상으로 덧셈을 진행한다.</li></ul><p>이러한 일련의 과정을 가리켜 ‘자료형 변환’ 또는 줄여서 ‘형 변환’ 이라고 한다. 그리고 위의 예제의 특징으로 자동 형 변환 이라고 한다.  프로그래머가 명시한 형 변환이 아니고 필요한 상황에서 자동으로 형 변환이 일어났기 때문이다. 이렇듯 형 변환이 필요한 상황에서는 다음 두 규칙에 근거하여 자동으로 형 변환이 일어난다.</p><p><strong>자동 형변환 규칙</strong></p><ol><li>자료형의 크기가 큰 방향으로 형 변환이 일어난다.</li><li>자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.</li></ol><p>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</p><p><strong>자동 형변환의 예</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num3 = <span class="number">30</span>; <span class="comment">//int형 정수 30은 double형으로 자동 형 변환 한다.</span></span><br><span class="line">System.out.println(<span class="number">60L</span> + <span class="number">34.5</span>); <span class="comment">//long형 정수 60L은 double형으로 자동 형 변환 한다.</span></span><br></pre></td></tr></table></figure><p><strong>명시적 형변환</strong><br>자동형변환의 특징을 봤을땐 </p><p>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</p><p>의 특징을 가지고있었다. 그럼 거꾸로 실수에서 정수형으로 형변환을 하려고하는 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="comment">//int wholeNumber = pi; double형의 pi를 int형 wholeNumer에 할당하려 하자 에러가난다. 이것을 명시적으로 형변환하면 아래와 같다.</span></span><br><span class="line">    <span class="keyword">int</span> wholeNumer = (<span class="keyword">int</span>)pi; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//이전 예제였던 short의 합 명시적 형변환으로 해결</span></span><br><span class="line">    <span class="keyword">short</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">short</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">short</span> num3 = (<span class="keyword">short</span>) (num1+ num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 문장에 10번째 줄에 소괄호가 두번 등장하였다. 하나는 num1과 num2의 덧셈연산을 묶을 목적으로, 또 하나는 형 변환을 목적으로 등장하였다.      이중에서 형 변환에서 사용된 소괄호는 연산자로 분류한다. 반면에 묶거나 구분하는 목적으로 사용이 되는 소괄호는 ‘구분자’라 하여 그 성격이 연산자와 다르다.</p><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/22/java/java02-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 01. 변수와 자료형</title>
      <link>http://gojaebeom.github.io/2020/04/21/java/java01-%EB%B3%80%EC%88%98%EC%99%80%20%EC%9E%90%EB%A3%8C%ED%98%95/</link>
      <guid>http://gojaebeom.github.io/2020/04/21/java/java01-%EB%B3%80%EC%88%98%EC%99%80%20%EC%9E%90%EB%A3%8C%ED%98%95/</guid>
      <pubDate>Tue, 21 Apr 2020 10:25:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;변수란&quot;&gt;&lt;a href=&quot;#변수란&quot; class=&quot;headerlink&quot; title=&quot;변수란?&quot;&gt;&lt;/a&gt;변수란?&lt;/h3&gt;&lt;p&gt;변수란 데이터의 저장과 참조를 위해 ‘할당된 메모리 공간’ 에 붙인 이름을 말한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="변수란"><a href="#변수란" class="headerlink" title="변수란?"></a>변수란?</h3><p>변수란 데이터의 저장과 참조를 위해 ‘할당된 메모리 공간’ 에 붙인 이름을 말한다. <a id="more"></a></p><h3 id="변수의-이해와-활용"><a href="#변수의-이해와-활용" class="headerlink" title="변수의 이해와 활용"></a>변수의 이해와 활용</h3><p>다음 예제를 보며 변수를 선언하는 방법과 초기화등 변수를 다루는 방법을 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1; <span class="comment">//변수 num1 의 선언</span></span><br><span class="line">num1 = <span class="number">10</span>; <span class="comment">//변수 num1에 10을 저장</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>; <span class="comment">//변수 num2 선언과 동시에 20으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num3 = num1 + num2; <span class="comment">// 두 변수 값을 대상으로 덧셈한 값을 num3에 저장</span></span><br><span class="line"></span><br><span class="line">System.out.println(num1 + <span class="string">"+"</span> + num2 + <span class="string">"="</span> + num3);</span><br></pre></td></tr></table></figure><br><p>자바에서는 값의 대입의 의미로 = 기호가 사용된다. 기호 = 를 가리켜 <strong>대입 연산자</strong> 라고 한다.</p><p>앞서 int 라는 키워드를 사용하여 변수를 만들었는데, 이러한 키워드를 가리켜 <strong>자료형</strong> 이라고 한다. 그리고 자바에서는 다양한 자료형을 제공한다. 자바의 자료형은 크게 기본형(primitive type)과 참조형(referene type)으로 나뉜다. 그리고 기본형은 다시 정수형, 실수형, 문자형, 논리형 네 가지로 분류할 수 있다. 이것들을 다음 표에 정리하였다.</p><table><thead><tr><th>자료형</th><th>데이터</th><th align="right">크기</th><th align="center">표현 가능 범위</th></tr></thead><tbody><tr><td>boolean</td><td>참과 거짓</td><td align="right">1바이트</td><td align="center">true, false</td></tr><tr><td>char</td><td>문자</td><td align="right">2바이트</td><td align="center">유니코드 문자</td></tr><tr><td>byte</td><td>정수</td><td align="right">1바이트</td><td align="center">-128~127</td></tr><tr><td>short</td><td>정수</td><td align="right">2바이트</td><td align="center">-32,768~32,767</td></tr><tr><td>int</td><td>정수</td><td align="right">4바이트</td><td align="center">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>long</td><td>정수</td><td align="right">8바이트</td><td align="center">-9,223,372,036,854,775,808 ~ 엄청크다..</td></tr><tr><td>float</td><td>실수</td><td align="right">4바이트</td><td align="center">단정도 실수형 (유효 자리는 7 정도임)</td></tr><tr><td>double</td><td>실수</td><td align="right">8바이트</td><td align="center">배정도 실수형 (유효 자리는 15정도)</td></tr><tr><td><br></td><td></td><td align="right"></td><td align="center"></td></tr></tbody></table><h3 id="다수의-변수-한번에-선언하기"><a href="#다수의-변수-한번에-선언하기" class="headerlink" title="다수의 변수 한번에 선언하기"></a>다수의 변수 한번에 선언하기</h3><p>다수의 변수 역시 한번에 선언하는 것이 가능하다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num4, num5; <span class="comment">//이와 같이 자료형이 같은 변수를 , 로 구분하여 동시 선언 가능하다.</span></span><br><span class="line"><span class="keyword">double</span> result;</span><br><span class="line">num4 = <span class="number">1.0000001</span>;</span><br><span class="line">num5 = <span class="number">2.0000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//실수의 덧셈 예제</span></span><br><span class="line">result = num4 + num5;</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//출력을 하게되면 예상했던 숫자 3.0000002 가 아닌 3.0000001999999997 같은 수가 나온다</span></span><br><span class="line"><span class="comment">//이유는 기본적으로 컴퓨터의 실수 표현에는 오차가 존재한다. 따라서 위와 같이 실수 1.000001을 저장 할 경우</span></span><br><span class="line"><span class="comment">//변수에 저장되는 값은 이에 가까운 값일 뿐 정확히 1.000001은 아니기때문이다.</span></span><br></pre></td></tr></table></figure><br><h3 id="기본-자료형-정수"><a href="#기본-자료형-정수" class="headerlink" title="기본 자료형 - 정수"></a>기본 자료형 - 정수</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> num1 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">short</span> num2 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> result = num1 + num2;<span class="comment">//에러가 나는 코드</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int result = num1 + num2; // 에러가 나지않는 코드</span></span><br><span class="line"></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>위의 예제를 보면 11, 22 의 정수는 2바이트 정수로 표현할 수 있으므로 short형 변수를 사용하는것이 옳다고 생각된다.<br>논리적으로 보면 문제가 없지만 자바의 관점에서 보면 문제가 있는 코드 이다. </p><p>자바는 정수형 연산을 int형으로 진행한다. 따라서 byte나 short형 변수에 저장된 값을 대상으로 덧셈과 같은 연산을 진행하면 이를 먼저 int형 값으로 변경한다. 즉 위의 예제는 덧셈 연산 이전에 다음 과정을 거치게 된다. </p><ul><li>변수 num1 과 num2 에 저장된 값을 int형으로 변환한다.</li><li>그렇기 때문에 위의 short result 변수에 두 변수의 합을 할당하려하니 ‘short result = num1 + num2;’ 부분에서 에러가 난다. </li></ul><p>주석으로 처리된 int result = num1 + num2 로 구문 작성시 잘 동작하는 것을 볼 수 있다.</p><h3 id="기본-자료형-문자"><a href="#기본-자료형-문자" class="headerlink" title="기본 자료형 - 문자"></a>기본 자료형 - 문자</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1 = <span class="string">'헐'</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2 = <span class="string">'확'</span>;</span><br><span class="line">    <span class="keyword">char</span> ch3 = <span class="number">54736</span>; <span class="comment">//문자 '헐'의 유니코드 값</span></span><br><span class="line">    <span class="keyword">char</span> ch4 = <span class="number">54869</span>; <span class="comment">//문자 '확'의 유니코드 값</span></span><br><span class="line">    System.out.println(ch1);</span><br><span class="line">    System.out.println(ch2);</span><br><span class="line">    System.out.println(ch3);</span><br><span class="line">    System.out.println(ch4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 컴파일 과정에서 위의 문자(헐, 확)들은 유니코드 값으로 치환된다. 즉 변수에 실제 저장되는 값은 유니코드 값이다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문자의 표현에 대한 약속을 가리켜 ‘문자셋(Character Set)’ 이라고 한다. 이러한 문자 셋의 설계는 지역 및 국가별로 각각 이루어져 그 수가 다양하다. 때문에 데이터를 주고받거나 여러 국가의 언어를 동시에 표현하는 상황에서는 문제가 되는데, 그래서 모든 나라의 문자를 수용하여 전 세계적으로 사용할 수 있는 문자 셋을 설계하게 되었다. 이를 가리켜 <strong>‘유니코드(Unicode)’</strong>라고합니다</p><p><strong>유니코드</strong>는 문자 하나를 2바이트로 표현하는 문자 체계이다. 2바이트로 표현할 수 있는 데이터의 수는 2의 16승 개이므로 총 6만 개 이상의 문자 표현이 가능하다. (유니코드의 정보는 <a href="http://www.unicode.org" rel="external nofollow noopener noreferrer" target="_blank">www.unicode.org</a> 에서 확인할 수 있습니다.)</p><p>자바의 <strong>char</strong>는 문자의 저장을 위한 자료형이다. 그리고 자바는 유니코드를 기반으로 문자를 처리한다. 따라서 다음과 같이 char형 변수 하나에 한글 문자 하나를 저장하는 것이 가능하다. 그리고 위의 예제에서보이듯이 문자(char 타입 변수 값)는 작은따옴표로 감싸서 표현해야 한다.</p><h3 id="기본-자료형-논리"><a href="#기본-자료형-논리" class="headerlink" title="기본 자료형 - 논리"></a>기본 자료형 - 논리</h3><p>boolean형 변수를 사용하여 값의 참과 거짓을 판별하는 예제 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>; </span><br><span class="line">    </span><br><span class="line">    System.out.println(num1 &lt; num2);</span><br><span class="line">    System.out.println(num1 &lt; num2 &amp;&amp; b1); </span><br><span class="line">    System.out.println(num1 &lt; num2 &amp;&amp; b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="식별자-규칙"><a href="#식별자-규칙" class="headerlink" title="식별자 규칙"></a>식별자 규칙</h3><p>자바는 대소문자를 구분한다. 따라서 Num1 과 num1은 서로 다른 이름으로 인식된다. 때문에 자료형 int를 대신하여 INT를 사용할 수 없고  변수의 이름을 짓는데 다음과 같은 제약사항이 존재한다.</p><p><strong>식별자 규칙</strong></p><ol><li>첫 문자가 문자나 ‘_’, ‘$’의 특수문자로 시작되어야 한다. 숫자로 시작할 수 없다.</li><li>첫 문자가 아니라면, 문자나 ‘_’, ‘$’의 특수문자 그리고 숫자로 구성될 수 있다.</li><li>자바의 예약어는 식별자로 사용할 수 없다.</li><li>식별자 길이는 제한이 없고 공백은 포함할 수 없다.</li></ol><p><strong>일반적 관례</strong></p><ul><li>클래스 이름은 대문자의 명사로 시작</li><li>메서드 이름은 소문자의 동사</li><li>변수는 소문자의 명사</li><li>상수는 대문자의 명사</li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/21/java/java01-%EB%B3%80%EC%88%98%EC%99%80%20%EC%9E%90%EB%A3%8C%ED%98%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA 시작하기</title>
      <link>http://gojaebeom.github.io/2020/04/21/java/java00-%EC%9E%90%EB%B0%94%EB%9E%80/</link>
      <guid>http://gojaebeom.github.io/2020/04/21/java/java00-%EC%9E%90%EB%B0%94%EB%9E%80/</guid>
      <pubDate>Tue, 21 Apr 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;자바-JAVA-란-무엇인가&quot;&gt;&lt;a href=&quot;#자바-JAVA-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;자바(JAVA)란 무엇인가?&quot;&gt;&lt;/a&gt;자바(JAVA)란 무엇인가?&lt;/h3&gt;&lt;p&gt;오늘부터 자바에 대해서 포스팅을 시작한다. 시작하기 앞서 자바가 무엇인지 간단히 알아보고 진행하도록 하겠다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="자바-JAVA-란-무엇인가"><a href="#자바-JAVA-란-무엇인가" class="headerlink" title="자바(JAVA)란 무엇인가?"></a>자바(JAVA)란 무엇인가?</h3><p>오늘부터 자바에 대해서 포스팅을 시작한다. 시작하기 앞서 자바가 무엇인지 간단히 알아보고 진행하도록 하겠다.<a id="more"></a></p><p><strong>자바</strong>는 1991년 썬 마이크로시스템즈(Sun Microsystems)사에서 제임스 고슬링(James Gosling)이 고안하였고 그때 당시엔 <strong>오크(Oak)</strong>, 또는 <strong>그린(Green)</strong> 이라고 불렸다. </p><p><strong>오크</strong>는 최조에 가전제품에 쓰일 목적으로 개발이 되었지만 인터넷과 웹의 출현으로 오크의 초점은 가전제춤에서 인터넷으로 옮겨지게 되었다고 한다. 이후 1995년 이름을 <strong>자바</strong>로 변경하였다.</p><p>자바는 인기플랫폼에 무료 런타임을 제공하였고, 대부분의 브라우저들은 곧 자바 애플릿(Java Applet)을 웹페이지 안에서 실행할 수 있었으며 자바의 인기는 급상승 하였다.</p><p>2009년 <strong>썬 마이크로시스템즈</strong>는 <strong>오라클</strong>에 인수 합병되었고 자바에 대한 권리 및 유지보수 또한 오라클로 넘어가게 되었다.</p><h3 id="JVM-Java-virtual-machine"><a href="#JVM-Java-virtual-machine" class="headerlink" title="JVM(Java virtual machine)"></a>JVM(Java virtual machine)</h3><p>자바는 운영체제에 독립적이라고 한다. 이것을 가능하게 하는것으로 자바의 플랫폼역할을 하는 JVM(java virtual machine)이 있다.</p><p><em>운영체제 -&gt; JVM -&gt; java</em></p><p>example.java 확장자명의 파일을 작성하게 되면 jvm은 이 파일을 javac라는 명령어를 통해 .class 파일로 추출해낸다. .class 확장자 파일은 JVM이 읽을 수 있는 파일이다. 그리고 추출된 example.class 파일을  java example (여기선 확장자명은 생략한다) 로 실행할 수 있게 되는 것이다.</p><p>이클립스, vscode 등의 툴을 이용하면 이 과정을 툴이 알아서 해주기때문에 모르고 넘어갈 수 도 있는 부분이다.<br>메모장을 통해 작성하여 이 과정을 연습해 보는 것도 좋을 것 같다. (물론 javac, java 명령어를 사용하기위해선 내 컴퓨터의 환경변수 설정을 해 두어야 한다.)</p><h3 id="객체지향-언어란"><a href="#객체지향-언어란" class="headerlink" title="객체지향 언어란?"></a>객체지향 언어란?</h3><p>자바는 객체지향 언어이다. 그렇다면 객체란 정확히 무엇인가? 사전에 집고 넘어가야할 문제인것 같다. 실생활에서 객체는 물체를 말한다.     물체는 우리 주면에서도 많다. 지금 내가 사용하고 있는 노트북, 컴퓨터 그것 뿐만아니라 피아노, 차 등등 모든것이 물체이다.</p><p>소프트웨어에서 말하는 객체의 특징으로는 상태(state)와 동작(action)으로 이루어 져 있다. 여기서 상태는 필드(fields) 또는 변수(variables) 이고 동작은 메서드(method) 또는 함수(function)으로 사용된다. 어느 블로거의 분의 글들을 참고해가며 잘 보고있는데 어떤분은 행동(behavior)으로 설명해주셨다. 행동과 동작은 비슷한 느낌인것같아 본인이 이해하기 편한대로 action으로 바꾸었다. 한동안 리액트에 빠져 리액트에서 다루는 dispatch의 영향이 크긴 큰것같다..)</p><p>그럼 여기서 변수와 함수가 등장했는데 간단히 알아보자면 </p><p><strong>변수</strong> - 변수는 어떠한 값을 담을수있는 틀과도 같다. 이름에서 알 수 있듯이 할당된 값을 바꾸는 것도 가능하다. 프로그래밍에서는 프로그램을 만들기위해 사용되어야하는 값들을 이 변수에 할당하여 사용하는 것이다.</p><p><strong>함수</strong> - 함수는 변수들을 받아서 가공하고 그에 따른 결과를 반환하는 등의 기능을 한다. 자바에서는 이부분을 이용하여 객체지향 핵심 원리중 하나인 ‘캡슐화’를 사용한다. 자바에서는 접근제한자라는 기능이있는데 자세한건 나중에 다루자, 여튼 이기능을 이용해 필드변수들에게는 보통 private를 걸어 클래스 외부에선 이 값을 사용하지 못하게 막아놓는다. 그리고 setter, getter등의 메서드들을 통해 필드변수들을 다루며, 오직 이 메서드들을 통해서만 상호작용을 하게끔 하는것이다. </p><p>총 정리하자면 객체는 다음과 같은 이점을 가진다.</p><p><strong>모듈화</strong> - 객체를 위한 소스코드는 다른코드와 별도로 코딩되고 유지할 수 있다.<br><strong>정보은닉(캡슐화)</strong> - 오직 객체의 메서드로만 상호작용을 함으로 객체 내부의 상태들의 정보를 외부로부터 숨길 수 있다.<br><strong>코드 재사용</strong> - 누군가 어떠한 객체를 구현하였다면 그 객체를 사용할 수 있다.</p><p>이밖의 특징들이 많이 있지만 앞으로 글을 쓰면서 추가하도록 하겠다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/21/java/java00-%EC%9E%90%EB%B0%94%EB%9E%80/#disqus_thread</comments>
    </item>
    
    <item>
      <title>나비보벳따우</title>
      <link>http://gojaebeom.github.io/2020/04/21/piano/piano-%EB%82%98%EB%B9%84%EB%B3%B4%EB%B2%B3%EB%94%B0%EC%9A%B0/</link>
      <guid>http://gojaebeom.github.io/2020/04/21/piano/piano-%EB%82%98%EB%B9%84%EB%B3%B4%EB%B2%B3%EB%94%B0%EC%9A%B0/</guid>
      <pubDate>Tue, 21 Apr 2020 10:00:00 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/4i_O2t8-HO4&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/4i_O2t8-HO4" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a><br>요즈음 역주행 해버린 나비보벳따우. 매일 흥얼거리다가 피아노 악보까지 뽑게 되었네요..ㅎ]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/21/piano/piano-%EB%82%98%EB%B9%84%EB%B3%B4%EB%B2%B3%EB%94%B0%EC%9A%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github Blog 만들기 - 글 작성하기</title>
      <link>http://gojaebeom.github.io/2020/04/21/hexo/hexo05/</link>
      <guid>http://gojaebeom.github.io/2020/04/21/hexo/hexo05/</guid>
      <pubDate>Mon, 20 Apr 2020 23:00:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;MarkDown이란&quot;&gt;&lt;a href=&quot;#MarkDown이란&quot; class=&quot;headerlink&quot; title=&quot;MarkDown이란?&quot;&gt;&lt;/a&gt;&lt;strong&gt;MarkDown이란?&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;github page에서 글을 작성할때는 &lt;strong&gt;MarkDown&lt;/strong&gt; 문법을 사용하여 글을 작성합니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="MarkDown이란"><a href="#MarkDown이란" class="headerlink" title="MarkDown이란?"></a><strong>MarkDown이란?</strong></h3><p>github page에서 글을 작성할때는 <strong>MarkDown</strong> 문법을 사용하여 글을 작성합니다. <a id="more"></a> 마크다운은 일반 텍스트 문서의 양식을 편집하는 문법이에요. README 파일이나 온라인 문서, 혹은 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰입니다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 변환이 가능합니다.</p><p>마크다운 문법은 구글을 통해 검색하면, 쉽게 찾아볼 수 있습니다. 간단한 문법이니 사용하기 그리 어렵지 않습니다.</p><h3 id="새로운-글-작성"><a href="#새로운-글-작성" class="headerlink" title="새로운 글 작성"></a><strong>새로운 글 작성</strong></h3><p>우리가 hexo 프레임워크를 이용하여 포스트를 작성한다면, hexo의 명령어로 쉽게 포스트를 생성할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [레이아웃명] [새 포스트 명]</span><br></pre></td></tr></table></figure><p>을 통해 파일을 만들 수 있는데요. 여기서 레이아웃명에 post를 쓰면 되지만, 따로 명시하지않아도 default 값이 post로 되어 있어 괜찮습니다.</p><h3 id="임시저장-글-작성"><a href="#임시저장-글-작성" class="headerlink" title="임시저장 글 작성"></a><strong>임시저장 글 작성</strong></h3><p>만약 바로 발행되지 않는 글을 작성하고 싶다면 레이아웃명에 draft를 적어주세요.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> draft [새 포스트명]</span><br><span class="line"><span class="comment">// 이후 발행시에는</span></span><br><span class="line">$ hexo publish [포스트명]</span><br><span class="line"><span class="comment">// 으로 발행할 수 있습니다.</span></span><br></pre></td></tr></table></figure><p>위의 방법은 hexo에서 제공하는 명령어를 사용하여 만드는 방법입니다. 위와 같은 방법으로 파일을 만들었다면 hexo 폴더의 source 폴더에 _posts 폴더 내부에 파일들이 생성되어 있는 것을 알 수 있습니다. 그렇다면 저희가 직접 생성하는 것도 가능하겠네요!</p><p>_posts 폴더 내부에 원하는 파일명.md 형식으로 파일을 만들어도 똑같이 적용이 됩니다. 다만 명령어로 생성시 hexo에서 사용하는 기본 구조가 잡혀있는데요.</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello</span><br><span class="line">date: 2020-04-21 09:06:30</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>직접 생성시에는 상단에 저런 틀을 넣어주셔야합니다. </p><h3 id="tag-생성하기"><a href="#tag-생성하기" class="headerlink" title="tag 생성하기"></a><strong>tag 생성하기</strong></h3><p>위의 문법은 마크다운에서 제공하는 것이 아닌 hexo의 템플릿 양식입니다. 글의 제목, 날짜, 태그를 적어줄 수 있게 되어있네요. title과 date는 예시가 있으니 tag를 만드는 방법을 알아봅시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">- example1</span><br><span class="line">- example2</span><br><span class="line">- example3</span><br><span class="line"><span class="comment">// 이런식으로 다수의 태그를 지정할 수 있습니다.</span></span><br></pre></td></tr></table></figure><h3 id="category-만들기"><a href="#category-만들기" class="headerlink" title="category 만들기"></a><strong>category 만들기</strong></h3><p>위의 양식에는 입력이 안되어있지만, 저 속성들 뿐만아니라 다른 다양한 속성들을 사용할 수 있습니다. 저희가 작성한 글의 카테고리를 분류하고싶다면 위의 양식에 속성으로 category: 를 만들어주세요. 그리고 다음과 같이 적어주시면 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">category:</span><br><span class="line">- 웹 개발</span><br><span class="line"><span class="comment">//위의 카테고리에서 한번 더 분류하고 싶다면</span></span><br><span class="line">- java </span><br><span class="line"><span class="comment">//밑에 두번째 분류 속성을 만들어주시면 됩니다. 이렇게 작성하면 웹 개발/ java 이런식으로 만들 수 있습니다.</span></span><br></pre></td></tr></table></figure><h3 id="썸네일-이미지-등록"><a href="#썸네일-이미지-등록" class="headerlink" title="썸네일 이미지 등록"></a><strong>썸네일 이미지 등록</strong></h3><p>마찬가지로 thumbnail이라는 속성을 추가하여 썸네일 이미지를 등록할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thumbnail: <span class="comment">//이부분에 사용할 이미지의 주소를 입력해 주세요.</span></span><br></pre></td></tr></table></figure><h3 id="more-excerpt"><a href="#more-excerpt" class="headerlink" title="more, excerpt"></a><strong>more, excerpt</strong></h3><p>인덱스 페이지에 어느부분까지 표시할 건지에 대한 세팅을 할 수 있습니다. 본문에 아래 주석을 이용하면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">본문이 이렇게 있을 때 여기까지만 인덱스 페이지에 나타납니다.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">여기서부턴 인덱스에 안나옵니다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">여기까지의 내용은 인덱스 페이지에만 나타납니다.</span><br><span class="line">&lt;!-- excerpt --&gt;</span><br><span class="line">여기서부턴 본문 시작입니다.</span><br></pre></td></tr></table></figure><p>지금까지 post를 작성하는 방법에 대하여 알아보았습니다. 물론 이것 말고도 다른 여러가지 기술들이 있지만, 저도 아직 사용한지 얼마 안되어 이것저것 만져보고 이후에 더 추가하도록 하겠습니다. 감사합니다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/21/hexo/hexo05/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github Blog 만들기 - icarus 테마 커스터마이징</title>
      <link>http://gojaebeom.github.io/2020/04/20/hexo/hexo04/</link>
      <guid>http://gojaebeom.github.io/2020/04/20/hexo/hexo04/</guid>
      <pubDate>Mon, 20 Apr 2020 11:00:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;icarus-테마-살펴보기&quot;&gt;&lt;a href=&quot;#icarus-테마-살펴보기&quot; class=&quot;headerlink&quot; title=&quot;icarus 테마 살펴보기&quot;&gt;&lt;/a&gt;&lt;strong&gt;icarus 테마 살펴보기&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;테마를 적용하고난 이후 기쁜마음에 이곳저곳 살펴보다보면 아래 사진처럼 뭐지 싶은 박스들을 볼 수 있습니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="icarus-테마-살펴보기"><a href="#icarus-테마-살펴보기" class="headerlink" title="icarus 테마 살펴보기"></a><strong>icarus 테마 살펴보기</strong></h3><p>테마를 적용하고난 이후 기쁜마음에 이곳저곳 살펴보다보면 아래 사진처럼 뭐지 싶은 박스들을 볼 수 있습니다. <a id="more"></a></p><img src="/images/github/05.jpg" alt="너네들은 뭐냐.." style="border-radius:5px; border:3px dotted #F2F2F2;"/><p>저도 github 사이트를 만들때 여러 블로그의 글을 보면서 도움을 받았지만, 사실 상 이 부분이 까다로웠습니다.  icarus 테마를 다루는 블로거 분들은 모두 ejs 파일로 만들어진 icarus에 대하여 다루고있지만 본인이 다운받은 파일은 모두 react로 만들어져 있다는 것.. 현재 icarus 공식 github 사이트에 업로드 되어있는 파일은 react로 리팩토링되어 있는 것 같습니다.</p><p>react를 조금이나마 흥미를 가지고 배운적이 있기에 긍정적인 마음으로 임하였지만 가장 큰 문제는 블로그에서 다루는 커스터마이징 파일은 ejs 또는 pug등의 파일들로 제공되어있는데, react 로 수정된 버전은 방법이 조금 달라진 것 같습니다. 다행이도 어느정도 시간을 두고 삽질을 하니 많은 부분이 해결이 되었습니다.</p><h3 id="테마-일부-기능-삭제-추가하기"><a href="#테마-일부-기능-삭제-추가하기" class="headerlink" title="테마 일부 기능 삭제 / 추가하기"></a><strong>테마 일부 기능 삭제 / 추가하기</strong></h3><p>위의 사진의 박스들이 어느정도 짐작이 가시나요? 각자 광고, 공유, 후원, 댓글기능 등을 추가할 수 있는 카드들이라는 것 입니다. 일단 광고와 후원은 현재로서는 사용하지 않을 예정이니 기능을 꺼놓도록 하겠습니다.</p><p><strong>-구글 광고 카드 삭제</strong><br>hexo 블로그 폴더에 있는 config 파일이 아닌 icarus 테마 폴더에 있는 _config.yml 파일을 열어주세요. <em># Google AdSense unit configurations</em> 주석을 찾아 아래 내용과 같이 수정해주세요.<br> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Google AdSense unit configurations</span></span><br><span class="line"><span class="comment"># 구글 광고 카드 / 사용시 adsense 앞의 #을 제거해주세요.</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">      <span class="comment"># Where should the widget be placed, left sidebar or right sidebar</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">type:</span> <span class="comment">#adsense</span></span><br><span class="line">      <span class="comment"># AdSense client ID</span></span><br><span class="line">      <span class="attr">client_id:</span> <span class="string">''</span></span><br><span class="line">      <span class="comment"># AdSense AD unit ID</span></span><br><span class="line">      <span class="attr">slot_id:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><br> <br></p><p><strong>-후원 기능 삭제</strong><br>위와 같이 _config.yml 파일을 열어 <em># Donate plugin configurations</em> 주석 이하 내용을 삭제 또는 주석처리 해주세요.<br> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Donate plugin configurations</span></span><br><span class="line"><span class="comment"># https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Donation/</span></span><br><span class="line"><span class="attr">donates:</span></span><br><span class="line">    <span class="comment"># Alipay donate button configurations</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">alipay</span></span><br><span class="line">        <span class="comment"># Alipay qrcode image URL</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># "Buy me a coffee" donate button configurations</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">buymeacoffee</span></span><br><span class="line">        <span class="comment"># URL to the "Buy me a coffee" page</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Patreon donate button configurations</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">patreon</span></span><br><span class="line">        <span class="comment"># URL to the Patreon page</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Paypal donate button configurations</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">paypal</span></span><br><span class="line">        <span class="comment"># Paypal business ID or email address</span></span><br><span class="line">        <span class="attr">business:</span> <span class="string">''</span></span><br><span class="line">        <span class="comment"># Currency code</span></span><br><span class="line">        <span class="attr">currency_code:</span> <span class="string">USD</span></span><br><span class="line">    <span class="comment"># Wechat donate button configurations</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">wechat</span></span><br><span class="line">        <span class="comment"># Wechat qrcode image URL</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><br> <br></p><p><strong>-ShareThis(공유) 기능 연결하기</strong><br>ShareThis는 방문자가 여러 sns 등에 글을 공유할 수 있게 해주는 기능을 서비스 합니다. icarus(리액트 버전)테마 에서는 sharethis를 연결하는 방법이 조금 다릅니다.</p><p><a href="https://sharethis.com/">sharethis</a> 사이트를 방문하여 원하는 공유 버튼을 제출을 하고 코드를 받습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> </span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">'text/javascript'</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">'blablablabla:example_code'</span> </span></span><br><span class="line"><span class="tag"><span class="attr">async</span>=<span class="string">'async'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>원래는 위의 코드전체를 ejs 파일에 붙여야 하지만 저희는 저 코드에서 src의 코드부분만 복사를 해둡니다. 위의 src내용은 임시로 작성한 것입니다. 본인이 본인 사이트의 주소를 입력하고 발급을 받아야합니다!</p><p>복사한 코드를 install_url 부분에 붙여넣어 줍시다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Share plugin configurations</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/</span></span><br><span class="line"><span class="attr">share:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">sharethis</span></span><br><span class="line">    <span class="comment"># URL to the ShareThis share plugin script</span></span><br><span class="line">    <span class="attr">install_url:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><br><p><strong>-Disqus를 사용하여 댓글 기능 셋팅하기</strong><br><a href="https://disqus.com/">Disqus</a>는 소셜 댓글 서비스 입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다. 위의 사이트에 들어가 회원가입을하고 무료버전 서비스를 받아봅시다. </p><p>이번에도 ShareThis처럼 다른 테마들과는 다르게 태그 등은 필요하지 않고 ‘short-name’ 값만 가져오면 됩니다. short-name은 회원가입한 ShareThis 아이디에 운영중인 홈페이지 URL을 연결하면 받을 수 있습니다. 그리고 _config.yml의 다음 부분에 short-name의 값을 붙여넣어 주세요.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment plugin configurations</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">disqus</span></span><br><span class="line">    <span class="comment"># Disqus shortname</span></span><br><span class="line">    <span class="attr">shortname:</span> <span class="string">''</span> <span class="comment"># &lt;- 이 부분에 코드 넣기</span></span><br></pre></td></tr></table></figure><br><p>여기까지 잘 진행이 되었다면 먼저 hexo server 로 확인을 해주시고 적용이 된 것을 확인하였다면 github에 배포해주시면 됩니다. 남은 프로필을 수정하거나 카드의 배치같은 부분도 _config.yml에서 할 수 있으니 자신만의 느낌대로 적용하시면 될 것 같습니다.</p><p>다음 글은 hexo 프레임워크에서 post 하는 방법등을 알아보겠습니다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/20/hexo/hexo04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github Blog 만들기 - hexo 테마 적용하기</title>
      <link>http://gojaebeom.github.io/2020/04/20/hexo/hexo03/</link>
      <guid>http://gojaebeom.github.io/2020/04/20/hexo/hexo03/</guid>
      <pubDate>Mon, 20 Apr 2020 10:00:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Hexo-테마-설치하기&quot;&gt;&lt;a href=&quot;#Hexo-테마-설치하기&quot; class=&quot;headerlink&quot; title=&quot;Hexo 테마 설치하기&quot;&gt;&lt;/a&gt;&lt;strong&gt;Hexo 테마 설치하기&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;hexo에서는 수많은 &lt;a href=&quot;https://hexo.io/themes/index.html&quot;&gt;테마&lt;/a&gt;들이 존재합니다. 본인이 원하는 테마를 찾아 다운받을 수 있습니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="Hexo-테마-설치하기"><a href="#Hexo-테마-설치하기" class="headerlink" title="Hexo 테마 설치하기"></a><strong>Hexo 테마 설치하기</strong></h3><p>hexo에서는 수많은 <a href="https://hexo.io/themes/index.html">테마</a>들이 존재합니다. 본인이 원하는 테마를 찾아 다운받을 수 있습니다. <a id="more"></a> 저는 그중에서도 <a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a> 라는 테마를 사용하였습니다. icaurs는 material 스러운 디자인으로 저의 취향에 딱 맞는 느낌이더라고요ㅎㅎ</p><p>자신이 원하는 테마를 적용할 때는 해당 사이트에서 시키는 방법대로 적용하면 됩니다. 처음 테마를 설치하는 방법은 다 비슷한데 이번 글에서는 icarus theme를 적용하는 방법으로 글을 작성하겠습니다.</p><p><strong>-테마 다운로드</strong><br>hexo 블로그 디렉토리 위치에서 터미널을 통해 다음 명령어를 입력 해주세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br></pre></td></tr></table></figure><p>다운로드가 완료되면 hexo 블로그 폴더에 themes 폴더에 icarus 폴더가 생성된 것을 볼 수 있습니다.<br><br></p><p><strong>-테마 바꾸기</strong><br>처음 hexo를 실행시켰을때 보였던 블로그 테마는 landscape 라는 기본 테마인데요. 이것을 다운받은 icarus 테마로 바꿔주어야 합니다. _config.yml 파일을 열어 다음 부분을 수정해주세요.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span> <span class="comment"># &lt;- 이부분을 icarus로 바꾸어주세요.</span></span><br></pre></td></tr></table></figure><br><p><strong>-github에 hexo 블로그 재배포하기</strong><br>이전 글에서 다루었던 방법으로 지금까지 수정한 내용을 저장하고 다시 github에 올리면 github page가 바뀐것을 볼 수 있습니다. 다음과 같이 명령어를 입력해주세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><br><p>아마 <strong>ERROR: pakage [패키지명] is not installed.</strong> 라는 에러가 몇개 뜨는 것을 볼 수 있는데요. icarus 테마에서 필요로하는 패키지들이 인스톨되지 않았다는 것 입니다. 당황하지말고 로그에 필요하다고 하는 패키지들을 다음과같이 install 해주세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install [패키지명]</span><br></pre></td></tr></table></figure><p>이 이후에 다시 <strong>hexo g -d</strong> 를 통해 github에 배포 후 사이트에 접속해보세요. icarus테마가 적용되어 보이면 성공입니다!<br><br><br>이번 글에서는 hexo 블로그에 icarus 테마를 적용하는 방법에 대하여 알아 보았습니다. 다음 글에서는 icarus 테마의 일부분을 커스터마이징 하는 방법에 대해서 알아보겠습니다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/20/hexo/hexo03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github Blog 만들기 - hexo 설치 및 배포</title>
      <link>http://gojaebeom.github.io/2020/04/20/hexo/hexo02/</link>
      <guid>http://gojaebeom.github.io/2020/04/20/hexo/hexo02/</guid>
      <pubDate>Mon, 20 Apr 2020 09:00:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Hexo-설치&quot;&gt;&lt;a href=&quot;#Hexo-설치&quot; class=&quot;headerlink&quot; title=&quot;Hexo 설치&quot;&gt;&lt;/a&gt;&lt;strong&gt;Hexo 설치&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;저번 글에서 github page를 생성하는 것 까지 해보았습니다. 이어서 Hexo를 설치해 보겠습니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="Hexo-설치"><a href="#Hexo-설치" class="headerlink" title="Hexo 설치"></a><strong>Hexo 설치</strong></h3><p>저번 글에서 github page를 생성하는 것 까지 해보았습니다. 이어서 Hexo를 설치해 보겠습니다.<a id="more"></a> 다시 Hexo에 대하여 간단히 말하자면 NodeJS 기반으로 만들어진 정적사이트 생성기로써 github page를 좀더 쉽게 관리 및 아름다운 테마를 사용할 수 있게 해줍니다.</p><p>먼저 hexo를 설치하기 위해선 nodeJS가 설치되어 있어야 합니다. </p><ul><li><a href="https://nodejs.org/ko/">Node.JS 공식홈페이지 주소</a></li></ul><p>nodejs를 로컬에 설치하면 자동으로 npm도 함께 설치가 되는데 npm은 Node Packaged Manager의 약자로, 많은 사람들이 자바스크립트 패키지들을 만들어 공유하고 그런 오픈소스라이브러리들 쉽게 사용할 수 있게 해주는 프로그램입니다. 우리는 npm을 통해 Hexo를 설치해보겠습니다.</p><p><strong>1. hexo 클라이언트 설치</strong> : <em>cmd창이나 터미널을 열고 다음을 입력합니다.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line"><span class="comment">//install대신 i를 적어도 됩니다.</span></span><br><span class="line"><span class="comment">//-g는 global의 약자로 사용자의 로컬에 전역적으로 설치한다는 뜻 입니다.</span></span><br></pre></td></tr></table></figure><br><p><strong>2. hexo 폴더 생성</strong> : <em>핵소 클라이언트를 설치하였다면 이제 hexo 명령어를 사용할 수 있습니다. hexo를 통해 hexo 폴더를 생성해봅시다.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init 폴더명 <span class="comment">//폴더명 부분에 원하는 폴더명을 입력하세요</span></span><br><span class="line">$ cd 폴더명 <span class="comment">//cd 는 change directory의 약자로 해당 폴더로 이동하게 해줍니다.</span></span><br><span class="line">$ npm install <span class="comment">// 폴더내부에 package.json 파일의 내용을 읽어 필요한 모듈들을 인스톨하는 과정입니다.</span></span><br></pre></td></tr></table></figure><p>error없이 완료되면 성공입니다!<br><br></p><p><strong>3. config.yml 수정</strong> : <em>정적 사이트 생성기 프레임워크들의 공통적인 특징으로 사용자가 쉽게 사이트의 정보를 수정할 수 있는 config.yml이 존재합니다. 해당 파일을 코드에디터등을 활용하여 열어주세요.</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site 수정 : 제일 상단에 있습니다.</span></span><br><span class="line"><span class="comment"># 예시로 적어놓은 것 이니 본인한테맞게 적어주세요</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="comment"># 사이트 제목</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'hexo 블로그'</span> <span class="comment"># 사이트 부제</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'hexo로 만든 블로그 입니다'</span> <span class="comment"># 사이트 설명</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">hexo,</span> <span class="string">github,</span> <span class="string">github</span> <span class="string">pages,</span> <span class="string">git</span> <span class="comment"># 사이트 검색 키워드</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">JaeBeom</span> <span class="string">Go</span> <span class="comment"># 저자</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">ko</span> <span class="comment"># 사용 언어</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">'Asia/Seoul'</span> <span class="comment"># 표준시간</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL 수정 : 상단 쪽에 있습니다.</span></span><br><span class="line"><span class="comment"># 예시로 적어놓은 것 이니 본인한테맞게 적어주세요</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment 수정 : 제일 하단에 있습니다.</span></span><br><span class="line"><span class="comment"># 예시로 적어놓은 것 이니 본인한테맞게 적어주세요</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#카탈로그 생성 및 위치</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">toc</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">category</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">tagcloud</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line"><span class="comment">#위치고정 여부</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="attr">right:</span></span><br><span class="line">    <span class="attr">sticky:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><p><strong>4. hexo 서버 실행시켜 보기</strong> : <em>기본적인 셋팅은 끝났습니다. 해당 디렉토리 위치의 cmd에서 아래 명령어를 입력해주세요.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="comment">//server는 줄여서 s로 사용가능합니다.</span></span><br></pre></td></tr></table></figure><p>서버가 정상적으로 실행되면 <a href="http://localhost:4000">http://localhost:4000</a>에서 블로그를 볼 수 있습니다.</p><img src="/images/github/04.png" alt="img" style="border-radius:5px; border:3px dotted #F2F2F2;"/><p>실행시키면 이렇게 우주스러운테마의 홈페이지가 열리면 성공입니다.</p><p><strong>5. hexo 블로그파일 github에 배포하기</strong><br>방금 서버를 실행시킨것은 어디까지나 개인 컴퓨터에서만 보이는 서버입니다. 이제 github에 배포하여 다른 사람들도 볼 수 있도록 해봅시다.</p><p>-<em>정적 웹 리소스 생성하기</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"><span class="comment">//줄여서 hexo g 로도 사용가능합니다.</span></span><br></pre></td></tr></table></figure><p>-<em>github에 배포하기</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"><span class="comment">//줄여서 hexo -d 로도 사용가능합니다.</span></span><br><span class="line"><span class="comment">//위의 웹 리소스 생성과 배포를 'hexo g -d' 로 동시에 할 수 있습니다.</span></span><br></pre></td></tr></table></figure><p>배포시에 <strong>ERROR Deployer not found: git</strong> 라는 에러가 뜬다면 <strong>hexo-deployer-git</strong> 이라는 플러그인을 설치해주세요</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>설치 후 다시 ‘hexo -d’ 를 통해 github에 배포를 하면 됩니다. 그 후 브라우저에서 https://{username}.github.io 주소 입력시 우주스러운 홈페이지가 뜨면 성공입니다.</p><p>이번 글에서는 hexo 설치 및 배포하는 방법까지 알아보았습니다. 하지만 블로그 디자인이 너무 우주스러운게 맘에 들지않아요. hexo에서는 타 정적 웹사이트 프레임워크들과 같이 아름다운 테마들을 제공하는데요. 다음시간에는 테마 적용방법에 대하여 포스팅하겠습니다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/20/hexo/hexo02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github Blog 만들기 - github 페이지 생성</title>
      <link>http://gojaebeom.github.io/2020/04/17/hexo/hexo01/</link>
      <guid>http://gojaebeom.github.io/2020/04/17/hexo/hexo01/</guid>
      <pubDate>Fri, 17 Apr 2020 13:09:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;github-blog를-만든-계기&quot;&gt;&lt;a href=&quot;#github-blog를-만든-계기&quot; class=&quot;headerlink&quot; title=&quot;github blog를 만든 계기&quot;&gt;&lt;/a&gt;&lt;strong&gt;github blog를 만든 계기&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;요즈음 github에 프로젝트를 올리면서 동시에 글을 쓰는 데요. 아무래도 코딩과 동시에 설명을 적으니 주석 때문에 글도 지저분해 보이고
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="github-blog를-만든-계기"><a href="#github-blog를-만든-계기" class="headerlink" title="github blog를 만든 계기"></a><strong>github blog를 만든 계기</strong></h3><p>요즈음 github에 프로젝트를 올리면서 동시에 글을 쓰는 데요. 아무래도 코딩과 동시에 설명을 적으니 주석 때문에 글도 지저분해 보이고<a id="more"></a> 관리가 필요한 것 같더라고요. 그래서 시작한 github에서 제공하는 github pages 블로그 프레임워크 hexo를 이용하여 현재 블로그를 만들었습니다.</p><h3 id="github-pages란"><a href="#github-pages란" class="headerlink" title="github pages란?"></a><strong>github pages란?</strong></h3><p>먼저 git과 github에 대한 어느 정도의 지식이 필요합니다. github pages는 github에 저장소의 내용을 (정적인) 웹페이지로 만들어 주는 서비스입니다. 그리고 무료라는 게 큰 장점이지요.</p><ul><li>github pages : <a href="https://pages.github.com/">https://pages.github.com/</a></li></ul><h3 id="hexo란"><a href="#hexo란" class="headerlink" title="hexo란?"></a><strong>hexo란?</strong></h3><p>github pages에서 저장소를 웹페이지로써 호스팅할 수 있게 해준다면, 이것을 쉽게 관리하고 사용하게 해주는 프레임워크들이 있습니다. 정적 사이트 생성기(Static site generator)라고도 하며 대중적으로 유명한 hexo, jekyll, hugo 등이 있습니다. 이중의 뭐가 더 좋다~ 라는 건 저도 잘 모르겠습니다. 각 프레임워크들을 만든 프로그래밍언어들이 다른데 hexo는 nodejs, jekyll는 ruby, hugo는 go 언어로 만들어졌다고 합니다. 저는 nodejs를 접해본 경험이 있기 때문에 hexo가 가장 친근하게 다가왔습니다.</p><ul><li>hexo : <a href="https://hexo.io/">https://hexo.io/</a></li></ul><p>물론 T스토리나 다음 블로거 등등을 사용해도 되지만 github로 블로그에 포스트를 게시하면서 동시에 github의 잔디까지 깔 수 있겠다 싶은게 가장 컷구요.<br>(<em>하지만 블로그에 글을 올리고 github에 업로드하여도 잔디가 채워지지 않았습니다. 이거 어째서입니까..?</em> )</p><h3 id="github-page-생성"><a href="#github-page-생성" class="headerlink" title="github page 생성"></a><strong>github page 생성</strong></h3><p>본격적으로 github page를 만들어봅시다. 생각보다 엄청 간단한데요, 먼저 github계정이 있다는 전제 하에 github 메인페이지의 우측 상단에 추가버튼 을 누르고 new repository를 눌러주세요.</p><img src="/images/github/01.png" alt="img" style="border-radius:5px; border:3px dotted #F2F2F2;"/><p>그리고 repository를 만드는데 다음과 같이 repository명을 example.github.io 를 만들어주세요. example 부분에는 꼭 본인의 아이디명을 적어주셔야 합니다!</p><img src="/images/github/02.png" alt="img" style="border-radius:5px; border:3px dotted #F2F2F2;"/><p>마지막으로 하단의 Initialize this repository with a README 박스를 채크해주시고 create repository를 클릭해주세요. Initialize this repository with a README 을 채크할 경우 github에 바로 README 파일과함께 repository를 생성할 수 있습니다.</p><img src="/images/github/03.png" alt="img" style="border-radius:5px; border:3px dotted #F2F2F2;"/><p>위의 이미지처럼 {사용자명}/github.io 의 이름으로 repository가 생성되었다면 성공입니다. github page는 생성이 되었지만 아직 기본적인 설정이 하나 더 남았습니다. https://{사용자명}/github.io url로 주소를 치게되면 처음으로 보이는 index페이지를 하나 생성해봅시다.</p><ul><li>생성된 repository의 클론주소를 복사해줍니다.</li><li>본인의 로컬의 내려 받고싶은 폴더에 cmd나 터미널, git bash 등을 이용하여 ‘git clone {복사한 주소}’ 해줍니다.</li><li>로컬에 생성된 폴더에 들어가 index.html 파일을 만들고 hello world 등 예시 문구등을 적어주세요.</li><li>index.html이 만들어진 git 로컬저장소를 다시 github에 push 해줍니다.</li><li>브라우저에서 https://{사용자명}/github.io url 주소를 입력하면 사용자가 정의한 문구가 보이는 페이지가 뜨는 것을 확인 할 수 있습니다. (바로 생성되지 않을 수 도 있어요. 저의 경우엔 3분가량 소요되었던 것 같습니다.)</li></ul><p>여기까지 github page를 생성하는 방법을 알아보았습니다. 생각만큼 친절한 글은 아닌것 같아요. 중간중간 빠진 내용도 많아보이죠. 아마 이 글을 보러 오시는 분들이라면 웹에 관한 선행학습이 어느정도 되어있을 것 이라 괜찮다고 생각 하였습니다.</p><p>다음 글은 이어서 hexo 설치 및 배포방법에 대하여 포스팅하겠습니다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/17/hexo/hexo01/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
