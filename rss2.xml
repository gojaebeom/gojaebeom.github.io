<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jaebeom&#39;s Blog</title>
    <link>http://gojaebeom.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/98c3781dafc67dfe731441beeee5e4ec</url>
      <title>Jaebeom&#39;s Blog</title>
      <link>http://gojaebeom.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>재범의 기술 블로그 입니다.</description>
    <pubDate>Sat, 06 Jun 2020 17:22:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>war 파일 톰캣에 배포하기</title>
      <link>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven04/</link>
      <guid>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven04/</guid>
      <pubDate>Fri, 05 Jun 2020 11:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 글에선 maven-quickstart 프로젝트를 생성하여 톰캣에 배포하여 웹을 띄우기까지의 과정을 처음부터 작성하려고 한다. 물론 메이븐을 이해하기 위해 이클립스나 인텔리J는 사용하지 않고 vscode와 터미널 기능만 이용하려고 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 글에선 maven-quickstart 프로젝트를 생성하여 톰캣에 배포하여 웹을 띄우기까지의 과정을 처음부터 작성하려고 한다. 물론 메이븐을 이해하기 위해 이클립스나 인텔리J는 사용하지 않고 vscode와 터미널 기능만 이용하려고 한다.<a id="more"></a></p><p>이번 글의 내용은 기본적으로 maven tool과 톰캣이 설치되어 있다는 가정 하에 진행하도록 하겠다. </p><h2 id="maven-프로젝트-생성"><a href="#maven-프로젝트-생성" class="headerlink" title="maven 프로젝트 생성"></a>maven 프로젝트 생성</h2><p>먼저 파일이 생성되어질 경로를 잡고 터미널에서 기본 프로젝트 생성 코드를 입력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate</span><br></pre></td></tr></table></figure><p>수 많은 프로젝트들이 뜨고 난 이후 어떤 프로젝트 기반으로 만들지 입력하라고 한다. 그냥 enter를 누르면 quickstart 프로젝트로 진행</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 1610:</span><br></pre></td></tr></table></figure><p>이후 quickstart 프로젝트의 버전을 입력하라고 한다. default 값은 최신 버전인 1.4 이다. 그대로 enter 눌러주자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Choose org.apache.maven.archetypes:maven-archetype-quickstart version: </span><br><span class="line">1: 1.0-alpha-1</span><br><span class="line">2: 1.0-alpha-2</span><br><span class="line">3: 1.0-alpha-3</span><br><span class="line">4: 1.0-alpha-4</span><br><span class="line">5: 1.0</span><br><span class="line">6: 1.1</span><br><span class="line">7: 1.3</span><br><span class="line">8: 1.4</span><br><span class="line">Choose a number: 8:</span><br></pre></td></tr></table></figure><p>이후 차례대로 groupId, artifactId, version, package 등을 물어본다. groupId는 com.example로 artifactId는 demo로 적어주자. 이후 버전부터 enter를 눌러주면 된다. (혹시 같은 폴더 내에 동일한 이름의 demo 프로젝트 폴더가 있다면 에러가 나니 주의)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Define value for property &#39;groupId&#39;: com.example</span><br><span class="line">Define value for property &#39;artifactId&#39;: demo</span><br><span class="line">Define value for property &#39;version&#39; 1.0-SNAPSHOT: : </span><br><span class="line">Define value for property &#39;package&#39; com.example: : </span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: com.example</span><br><span class="line">artifactId: demo</span><br><span class="line">version: 1.0-SNAPSHOT</span><br><span class="line">package: com.example</span><br><span class="line"> Y: :</span><br></pre></td></tr></table></figure><p>다음과 같이 뜨면 정상적으로 프로젝트가 만들어졌다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Using following parameters for creating project from Archetype: maven-archetype-quickstart:1.4</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Parameter: groupId, Value: com.example</span><br><span class="line">[INFO] Parameter: artifactId, Value: demo</span><br><span class="line">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</span><br><span class="line">[INFO] Parameter: package, Value: com.example</span><br><span class="line">[INFO] Parameter: packageInPathFormat, Value: com&#x2F;example</span><br><span class="line">[INFO] Parameter: package, Value: com.example</span><br><span class="line">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</span><br><span class="line">[INFO] Parameter: groupId, Value: com.example</span><br><span class="line">[INFO] Parameter: artifactId, Value: demo</span><br><span class="line">[INFO] Project created from Archetype in dir: C:\_achive\java\maven\demo</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  16.241 s</span><br><span class="line">[INFO] Finished at: 2020-06-05T15:03:24+09:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="webapp-폴더-생성"><a href="#webapp-폴더-생성" class="headerlink" title="webapp 폴더 생성"></a>webapp 폴더 생성</h2><p>기본적인 폴더 구조는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">|-- pom.xml</span><br><span class="line">&#96;-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   &#96;-- java</span><br><span class="line">    |       &#96;-- com</span><br><span class="line">    |           &#96;-- example</span><br><span class="line">    |                   &#96;-- App.java</span><br><span class="line">    &#96;-- test</span><br><span class="line">        &#96;-- java</span><br><span class="line">            &#96;-- com</span><br><span class="line">                &#96;-- example</span><br><span class="line">                        &#96;-- AppTest.java</span><br></pre></td></tr></table></figure><p>위의 main 폴더에 다음 같이 폴더를 만들어주자. 우리가 직접 만들어 주었지만 webapp과 WEB-INF는 maven 웹프로젝트를 만들때 사용되는 폴더 구조이다. 이름을 반드시 동일하게 입력하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">|-- pom.xml</span><br><span class="line">&#96;-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   |-- java</span><br><span class="line">    |   |    &#96;-- com</span><br><span class="line">    |   |         &#96;-- example</span><br><span class="line">    |   |                &#96;-- App.java</span><br><span class="line">    |   &#96;-- webapp</span><br><span class="line">    |       |&#96;-- index.html</span><br><span class="line">    |       |&#96;-- WEB-INF</span><br><span class="line">    |              &#96;-- web.xml</span><br><span class="line">    &#96;-- test</span><br><span class="line">        &#96;-- java</span><br><span class="line">            &#96;-- com</span><br><span class="line">                &#96;-- example</span><br><span class="line">                        &#96;-- AppTest.java</span><br></pre></td></tr></table></figure><p>webapp 내부에 WEB-INF 폴더와 index.html, 그리고 WEB-INF 폴더에 web.xml이 있다. 먼저 index.html 파일은 단순하게 다음과 같이 만들어 주자.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello maven!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그리고 web.xml 기본 양식은 톰캣 폴더의 webapps -&gt; ROOT -&gt; WEB-INF -&gt; web.xml를 복사해 가져오면 된다. 내용은 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"4.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Welcome to Tomcat<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">     Welcome to Tomcat</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="war-file-배포하기"><a href="#war-file-배포하기" class="headerlink" title="war file 배포하기"></a>war file 배포하기</h2><p>maven의 기본 패키징타입은 jar이다. 우리는 web 프로젝트가 목적이기 때문에 war로 패키징 타입을 바꾸어 주어야 한다. </p><p>pom.xml에 따로 명시 되지 않았는데 상단의 기본정보들을 입력하는 태그 밑에 다음 내용을 넣어주자.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제 메이븐은 페키징을 할때 pom.xml에 기술된 위의 내용대로 war파일을 만들어줄 것이다. demo 프로젝트의 pom.xml이 있는 경로에서 다음과 같이 입력해주자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br></pre></td></tr></table></figure><p>에러가 없이 잘 완료 되었다면 target 폴더 하위에 <code>demo-1.0-SNAPSHOT.war</code> 라는 war 확장자 파일이 생겼을 것 이다. 우리는 이제 이 파일을 톰캣에 배포해주면 된다.</p><h2 id="톰캣에-war파일-배포하기"><a href="#톰캣에-war파일-배포하기" class="headerlink" title="톰캣에 war파일 배포하기"></a>톰캣에 war파일 배포하기</h2><ul><li>톰캣 최상위 디렉토리에서 webapps 폴더 하위에 <code>demo-1.0-SNAPSHOT.war</code> 파일을 옮겨준다. 이 파일은 톰캣이 구동시에 저절로 압축이 풀린다.</li><li>톰캣 최상위 디렉토리에서 bin 폴더 하위에 startup.bat 파일을 실행시켜준다. </li><li>브라우저에서 localhost:8080에 접속해보자. 톰캣 서비스가 뜨면 서버는 정상적으로 실행되고 있다는 것</li><li>브라우저에서 localhost:8080/demo-1.0-SNAPSHOT/index.html 와 같이 입력해보자. hello maven! 이 뜬다면 성공이다.<ul><li>실제 위의 주소명은 톰캣의 webapps 를 기본 경로로 하여 압축이 풀린 demo-1.0-SNAPSHOT 내부의 index.html이 보이는 것을 알 수 있다. </li></ul></li></ul><h2 id="maven-webapp-프로젝트-쉽게-만들기"><a href="#maven-webapp-프로젝트-쉽게-만들기" class="headerlink" title="maven webapp 프로젝트 쉽게 만들기"></a>maven webapp 프로젝트 쉽게 만들기</h2><p>사실 위의 maven 프로젝트 생성하기 단계는 처음 생성시에 옵션을 주는것으로 빠르게 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate -DinteractiveMode&#x3D;false  -DgroupId&#x3D;&lt;패키지명&gt; -DartifactId&#x3D;&lt;프로젝트명&gt; -DarchetypeArtifactId&#x3D;maven-archetype-webapp</span><br></pre></td></tr></table></figure><p><sup>*줄을 임의로 내리면 안된다. 옆으로 계속 이어서 써야한다.</sup></p><p>위와 같이 프로젝트를 만들게 되면 다음과 같이 기본적인 webapp 구조가 잡히게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">|-- pom.xml</span><br><span class="line">|</span><br><span class="line"> &#96;-- src</span><br><span class="line">      &#96;-- main</span><br><span class="line">            |&#96;-- resources</span><br><span class="line">            |</span><br><span class="line">             &#96;-- webapp</span><br><span class="line">                  |&#96;-- WEB-INF</span><br><span class="line">                  |       &#96;-- web.xml</span><br><span class="line">                   &#96;-- index.jsp</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven04/#disqus_thread</comments>
    </item>
    
    <item>
      <title>POM.xml</title>
      <link>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven03/</link>
      <guid>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven03/</guid>
      <pubDate>Fri, 05 Jun 2020 10:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;pom-xml&quot;&gt;&lt;a href=&quot;#pom-xml&quot; class=&quot;headerlink&quot; title=&quot;pom.xml&quot;&gt;&lt;/a&gt;pom.xml&lt;/h2&gt;&lt;p&gt;pom은 project object model의 약자로써 메이븐은 pom에 기술된 내용을 바탕으로 빌드를 진행한다. 즉 pom은 maven에서 사용하는 빌드 파일이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>pom은 project object model의 약자로써 메이븐은 pom에 기술된 내용을 바탕으로 빌드를 진행한다. 즉 pom은 maven에서 사용하는 빌드 파일이다.</p><a id="more"></a><p>아래의 코드는 이전 글의 메이븐 생성하기에서 만든 프로젝트의 pom.xml을 열었을 때 볼 수 있는 내용이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>뭔가 내용들이 많은데 간단하게 요약하자면 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 필수 : 프로젝트 정보 기재 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 선택 : 프로젝트에 대한 설명란 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>demo project!<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 선택 : pom.xml에서 공통적으로 사용할 버전, 설정 정보 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 각 dependency에 지정할 값들을 properties에 써두고</span></span><br><span class="line"><span class="comment">             변수처럼 활용할 수 있음. </span></span><br><span class="line"><span class="comment">             밑의 servelt.version 태그는 사용자가 임의로 지정한것</span></span><br><span class="line"><span class="comment">             이후의 dependency에서 사용하는 것을 보자</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet.version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">servlet.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 선택: 의존성 설정은 선택이지만 </span></span><br><span class="line"><span class="comment">       메이븐의 주 사용이유인 만큼 필수적으로 사용된다.</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dependencies안에 dependency로 구분지어 라이브러리를 추가할 수 있다 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- properties에 작성해 놓은 servlet.version 태그의 값을 사용함 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 필수내용 : 프로젝트 build 정보 기재 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 선택사항 : resource 파일의 경로를 지정할 수 있음 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 선택사항 : maven의 라이프사이클을 개별의 플러그인으로 관리함으로써 </span></span><br><span class="line"><span class="comment">    필요한 부분만 넣어 사용할 수 있다.</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 밖에 다른 기술들도 많이 있겠지만 기본 틀만 잡아놓고 이 후에 필요시 찾아볼 생각이다. </p><h2 id="project-기본정보"><a href="#project-기본정보" class="headerlink" title="project 기본정보"></a>project 기본정보</h2><p>보통 상단에<br>modelVersion, groupId, artifactId, version, name, url를 기재하는데 필수적이다. 추가로 프로젝트에 관한 설명을 적기위해 description 속성을 추가할 수 있다.</p><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><ul><li>프로젝트의 주요 설정들을 쉽게 모아보기 위해 정리한다. </li><li>pom.xml 내에서 자주 사용되는 정보들을 변수처럼 만들어서 사용할 수 있다.</li></ul><h2 id="dependency-관리"><a href="#dependency-관리" class="headerlink" title="dependency 관리"></a>dependency 관리</h2><p>pom.xml을 자주 들락날락 거리게 만들 이유이다. maven을 통해 불러온 라이브러리들은 java built path에서 maven dependencies 하위 목록으로 들어가게 된다. 그리고 그것들은 pom.xml을 통해서만 추가, 삭제, 버전 변경 등을 할 수 있다. </p><p>해당 경로에 추가된 라이브러리가 필요한 다른 라이브러리들이 있다면 해당하는 라이브러리까지 참조해서 불러들이는 기능이 있다. 이것을 의존성 전의라 한다.</p><h3 id="dependency태그-속성"><a href="#dependency태그-속성" class="headerlink" title="dependency태그 속성"></a>dependency태그 속성</h3><ul><li>groupId : 필수, 라이브러리의 그룹명을 적는다.</li><li>artifactId : 필수, 라이브러리의 이름을 적는다.</li><li>version: 필수? 라이브러리의 버전을 적는다.</li><li>type : 선택, 라이브러리의 유형을 적는다. defulat값은 jar이다.</li><li>scope : 라이브러리가 적용될 범위를 지정할 수 있다.<ul><li>compile(default): 모든 클래스 경로에서 사용할 수 있음. 컴파일 및 배포시 같이 재공</li><li>provided : jdk 또는 컨테이너가 런타임 시에만 해당 라이브러리를 제공. 컴파일 혹은 테스트 경로에서만 사용할 수 있다.</li><li>test : 태스트 시에만 해당 라이브러리를 사용한다.</li><li>system : 저장소에서 관리되지 않고 직접 관리하는 jar를 추가함</li></ul></li><li>optional : 선택, 의존성 정보를 다른 프로젝트에 전달하고 싶지 않을 때 true로 설정하자. </li></ul><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>빌드할 때 사용할 플러그인 목록을 기록할 수 있다. 그밖에 build 속성 내부에 resources 속성을 추가해 정적파일 경로를 설정할 수 있다.</p><p>정리랍시고 했지만 귀찮아서 생략한 부분도 많다.. <a href="https://maven.apache.org/guides/getting-started/index.html#How_do_I_setup_Maven" rel="external nofollow noopener noreferrer" target="_blank">https://maven.apache.org/guides/getting-started/index.html#How_do_I_setup_Maven</a> &lt;– 공식 홈페이지 문서이다. 글쓴이는 영어를 잘 못해 번역으로 돌려놓고 이해하려고 애쓰는데 영어 잘하시는 분들은 가서 보길 바란다. 설명 정말 잘 되어있다..</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/05/6.%20maven/maven03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Maven 프로젝트 만들기</title>
      <link>http://gojaebeom.github.io/2020/06/04/6.%20maven/maven02/</link>
      <guid>http://gojaebeom.github.io/2020/06/04/6.%20maven/maven02/</guid>
      <pubDate>Thu, 04 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Maven-download&quot;&gt;&lt;a href=&quot;#Maven-download&quot; class=&quot;headerlink&quot; title=&quot;Maven download&quot;&gt;&lt;/a&gt;Maven download&lt;/h2&gt;&lt;p&gt;이전 글에서 메이븐이 왜 필요한지 간단히 알아보았다. 이번엔 메이븐을 사용하는 방법에 대해서 다루고자 한다. 학습의 이해를 위해 IDE에서 지원하는 기능은 사용하지 않고 프로젝트를 만들어 보겠다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Maven-download"><a href="#Maven-download" class="headerlink" title="Maven download"></a>Maven download</h2><p>이전 글에서 메이븐이 왜 필요한지 간단히 알아보았다. 이번엔 메이븐을 사용하는 방법에 대해서 다루고자 한다. 학습의 이해를 위해 IDE에서 지원하는 기능은 사용하지 않고 프로젝트를 만들어 보겠다. <a id="more"></a></p><p>먼저 maven을 사용하기 위해 다운로드를 받아주어야 하는데 두가지 방법을 예로 들겠다. </p><h3 id="메이븐-공식-홈페이지"><a href="#메이븐-공식-홈페이지" class="headerlink" title="메이븐 공식 홈페이지"></a>메이븐 공식 홈페이지</h3><p><a href="https://maven.apache.org/download.cgi" rel="external nofollow noopener noreferrer" target="_blank">https://maven.apache.org/download.cgi</a> &lt;– 메이븐 공식 홈페이지의 다운로드 페이지에 접속하여 본인의 컴퓨터에 맞는 압축파일을 다운로드 받으면 된다. 현재 메이븐은 3.6.3 버전을 공식적으로 지원하고 있다.(참고로, 메이븐 3.3 이후부터는 자바 1.7 이상을 요구한다)</p><h3 id="chocolatey-패키지-매니저"><a href="#chocolatey-패키지-매니저" class="headerlink" title="chocolatey 패키지 매니저"></a>chocolatey 패키지 매니저</h3><p>보통 리눅스에서 파일을 쉽게 다운로드하고 관리하기위해 패키지 매니저인 apt를 사용한다. 윈도우도 이러한 이점을 반영하기 위해 생긴 것이 choco라는 패키지 매니저 이다. 이 프로그램을 사용하고 있다면 위의 방법보다 간편하게 cmd(관리자 모드)에서  <code>choco install maven</code> 을 입력하는것으로 다운 받을 수 있다. 공식 홈페이지와 동일하게 3.6.3 버전을 다운받는다.</p><p>파일을 받았다면 공식홈페이지에서 받은 파일은 압축파일로, choco 패키지 매니저로 받은 파일은 폴더로 풀려져 있을 것 이다. 압축파일은 풀어서 원하는 경로에 위치하면 된다. </p><h2 id="Maven-path-setting"><a href="#Maven-path-setting" class="headerlink" title="Maven path setting"></a>Maven path setting</h2><p>메이븐을 실행하기 위해선 사용자 경로\다운받은 메이븐 폴더\bin 의 mvn을 실행 시켜주어야 한다. 하지만 메이븐을 사용하기 위해 매번 긴 경로를 매번 입력하는것은 힘든 일이다.</p><p>윈도우 기준으로 환경변수를 등록하는 것으로 이를 해결할 수 있다.</p><ul><li>폴더의 왼쪽 디렉토리 아이콘사이의 내 PC의 우클릭을 하여 속성 클릭</li><li>고급 시스템 설정 클릭</li><li>환경 변수 클릭</li><li>시스템 변수 부분의 path를 찾아 path부분을 편집해준다.</li><li>maven의 bin 디렉토리 경로를 복사하여 입력해준다. 예) C:\apache-maven-3.6.3\bin</li><li>저장해주고 cmd에서 mvn -v 을 입력</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mvn -v</span><br><span class="line">Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: C:\_tools\apache-maven-3.6.3\bin\..</span><br><span class="line">Java version: 1.8.0_251, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_251\jre</span><br><span class="line">Default locale: ko_KR, platform encoding: MS949</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br><span class="line">PS C:\Users\gojaebeom&gt;</span><br></pre></td></tr></table></figure><ul><li>위와 같은 문장들이 출력되면 성공이다.</li></ul><h2 id="maven-프로젝트-생성하기"><a href="#maven-프로젝트-생성하기" class="headerlink" title="maven 프로젝트 생성하기"></a>maven 프로젝트 생성하기</h2><p>mvn 명령어를 사용하여 프로젝트를 생성할 수 있다. 물론 생성시 여러 옵션을 줄 수 있지만, 우리는 기본 생성 명령어인 <code>archetype:generate</code> 만 입력하도록 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate</span><br></pre></td></tr></table></figure><p>위의 명령어 입력시 엄청나게 많은 로그들이 나타난다. 먼저 mvn은 다른 사람이 만들어 놓은 프로젝트를 이어서 개발하는 것이 가능하다. 나열되는 프로젝트들은 해당 번호를 입력시 사용할 수 있지만, 우리는 현재 아무것도 모르기 때문에 그냥 엔터를 눌러주자. </p><p>번호를 따로 입력해주지 않으면 defulat값인 quick-start 프로젝트로 진행된다(기본 설정만 있는 프로젝트이다). 그 이후에는 quick-start 프로젝트의 버전을 정하라고 하는데 defulat 값은 항상 가장 최신 버전으로 되어 있다. 현재 2020-06-05일 기준으로 1.4 버전이 최신버전이다. 그대로 진행해 주자. </p><p>그다음 그룹아이디, 아티팩트 아이디는 다음과 같이 적었다.</p><ul><li>groupId: com.example</li><li>artifactId: demo</li></ul><p>그다음 부터는 무시하고 계속 엔터를 눌러주자.</p><ul><li>version: 1.0-SNAPSHOT (snapshot은 개발중인 프로젝트를 말한다. 그대로 넘어가자)</li><li>package: com.example</li></ul><h2 id="maven-프로젝트-기본-구조"><a href="#maven-프로젝트-기본-구조" class="headerlink" title="maven 프로젝트 기본 구조"></a>maven 프로젝트 기본 구조</h2><p>프로젝트 생성시 기본 구조는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">├─src</span><br><span class="line">│   ├─main</span><br><span class="line">│   │  └─java</span><br><span class="line">│   │      └─com</span><br><span class="line">│   │          └─example</span><br><span class="line">│   │              └─App.java</span><br><span class="line">│   ├─test</span><br><span class="line">│       └─java</span><br><span class="line">│           └─com</span><br><span class="line">│               └─example</span><br><span class="line">│                   └─AppTest.java</span><br><span class="line">└─pom.xml</span><br></pre></td></tr></table></figure><p>기본적으로 생성되는 폴더를 포함한 Maven 프로젝트의 주요 폴더는 다음과 같다.</p><ul><li>src/main/java - 자바 소스 파일이 위치한다.</li><li>src/main/resources - 프로퍼티나 XML 등 리소스 파일이 위치한다. 클래스패스에 포함된다.</li><li>src/main/webapp - 웹 어플리케이션 관련 파일이 위치한다. (WEB-INF 폴더, JSP 파일 등)</li><li>src/test/java - 테스트 자바 소스 파일이 위치한다.</li><li>src/test/resources - 테스트 과정에서 사용되는 리소스 파일이 위치한다. 테스트 시에 사용되는 클래스패스에 포함된다.</li></ul><p>기본적으로 생성되지 않은 폴더라 하더라도 직접 생성해주면 된다. 예를 들어 src/main 폴더에 resources 폴더를 생성해주면 Maven은 리소스 폴더로 인식한다.</p><h2 id="Maven의-lifecycle"><a href="#Maven의-lifecycle" class="headerlink" title="Maven의 lifecycle"></a>Maven의 lifecycle</h2><ul><li>generate-sources <ul><li>컴파일 과정에 포함될 소스를 생성</li></ul></li><li>process-sources    <ul><li>필터와 같은 작업을 소스 코드에 처리 </li></ul></li><li>generate-resources    <ul><li>패키지에 포함될 자원을 생성      </li></ul></li><li>process-resources    <ul><li>필터와 같은 작업을 자원 파일에 처리하고, 자원 파일을 클래스 출력 디렉토리에 복사</li></ul></li><li><strong>compile</strong><ul><li>소스 코드를 컴파일해서 클래스 출력 폴더에 클래스를 생성</li></ul></li><li>generate-test-sources    <ul><li>테스트 소스 코드를 생성</li></ul></li><li>process-test-sources    <ul><li>필터와 같은 작업을 테스트 소스 코드에 처리</li></ul></li><li>generate-test-resources    <ul><li>테스트를 위한 자원 파일을 생성     </li></ul></li><li>process-test-resources    <ul><li>필터와 같은 작업을 테스트 자원 파일에 처리, 테스트 자원 파일을 테스트 클래스 출력 폴더에 복사 </li></ul></li><li>test-compile    <ul><li>테스트 소스 코드를 컴파일해서 테스트 클래스 추력 폴더에 클래스를 생성</li></ul></li><li><strong>test</strong>    <ul><li>테스트를 실행</li></ul></li><li><strong>package</strong><ul><li>컴파일 된 코드와 자원 파일들을 jar, war와 같은 배포 형식으로 패키징</li></ul></li><li><strong>install</strong>    <ul><li>로컬 리포지토리에 패키지를 복사</li></ul></li><li><strong>deploy</strong>    <ul><li>생성된 패키지 파일을 원격 리포지토리에 등록하여, 다른 프로젝트에서 사용할 수 있도록 함</li></ul></li></ul><p>위의 라이프사이클중 굵게 표시된 단계는 명령어로 사용할 수 있다. 만약 <code>mvn compile</code> 입력시 처음부터 compile까지 순차적으로 실행된다. <code>mvn install</code> 입력시 처음부터 install까지 순차적으로 실행하게 되는 것 이다. 만약 그렇다면 위와 같은 라이프사이클은 항상 순차적으로 진행해야 하는것 인가? 라고 한다면 그것은 아니다. </p><p>maven은 위의 과정들을 각각 개별적인 플러그인으로 만들어 부품과 같이 사용하지 않을 플러그인은 무시하고 넘어갈 수 있도록 만들어져있다. </p><p>그리고 clean 명령어는 다음과 같은 상황에서 사용할 수 있다.</p><ul><li>clean<ul><li>메이븐 빌드를 통하여 생성된 모든 산출물을 삭제한다.</li></ul></li></ul><p>라이프사이클에 관한 내용을 잘 정리해주셔서 자바캔님의 블로그 내용을 인용하였습니다.<br>출처: <a href="https://javacan.tistory.com/entry/MavenBasic" rel="external nofollow noopener noreferrer" target="_blank">https://javacan.tistory.com/entry/MavenBasic</a> [자바캔]</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/04/6.%20maven/maven02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Maven을 알아보자</title>
      <link>http://gojaebeom.github.io/2020/06/01/6.%20maven/maven01/</link>
      <guid>http://gojaebeom.github.io/2020/06/01/6.%20maven/maven01/</guid>
      <pubDate>Mon, 01 Jun 2020 10:09:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Maven이란&quot;&gt;&lt;a href=&quot;#Maven이란&quot; class=&quot;headerlink&quot; title=&quot;Maven이란?&quot;&gt;&lt;/a&gt;Maven이란?&lt;/h2&gt;&lt;p&gt;메이븐은 자바 프로젝트의 빌드(build)를 자동화 해주는 관리 도구(build tool)이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Maven이란"><a href="#Maven이란" class="headerlink" title="Maven이란?"></a>Maven이란?</h2><p>메이븐은 자바 프로젝트의 빌드(build)를 자동화 해주는 관리 도구(build tool)이다.<a id="more"></a>  아파치 소프트웨어 제단에서 만들어졌으며,      이전의 Apache Ant 의 대안으로 만들어졌다. </p><p><code>Too Much Information</code></p><ul><li><sup>발표일은 2004년 7월 13일 이다.</sup></li><li><sup>안정화 버전은 3.5.3 버전으로 2018년 3월 8일 이다.</sup></li></ul><p>이클립스, 인텔리J 등을 사용하면 메이븐에 관한 설정들을 편하게 할 수 있었기 때문에 메이븐이 뭔지 잘 알지 못하고 넘어갔다. 이번 계기로 Spring 관련 글을 쓰기 이전에 Maven을 조금이나마 공부하고 넘어가고자 글을 쓰게 되었다.</p><h2 id="Maven-없이-Java-빌드하기"><a href="#Maven-없이-Java-빌드하기" class="headerlink" title="Maven 없이 Java 빌드하기"></a>Maven 없이 Java 빌드하기</h2><p>메이븐이 왜 필요한지 직접 예제를 만들어 비교해보도록 하자.</p><h3 id="기본적인-빌드"><a href="#기본적인-빌드" class="headerlink" title="기본적인 빌드"></a>기본적인 빌드</h3><p>먼저 파일을 만들 디렉토리를 하나 생성해주자. 경로는 본인이 편한 경로에 생성한다. 본인은 cmd에서 빨리 탐색할 수 있게 <code>C:\Users\[유저명]&gt;</code> 의 위치에 java_study 폴더를 생성한것으로 설명하겠다.</p><p>cmd를 통해 해당경로에 notepad Main.java 를 입력하여 java 파일을 만들어준다.(직접 메모장을 생성해도 상관없다) 그리고 다음 내용을 입력해주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd에 해당 경로에서 javac Main.java 입력, 이후 Main.class 파일이 잘 나오면 java Main 을 입력하면 Hello World!가 잘 출력될 것이다. </p><p>이것은 아주 단순한 예제다. 이제 위의 파일을 패키지에 담아서 빌드해보자. package는 도메인의 역순으로 만드는 것이 일반적인 관례이다.</p><h3 id="패키지화하여-빌드하기"><a href="#패키지화하여-빌드하기" class="headerlink" title="패키지화하여 빌드하기"></a>패키지화하여 빌드하기</h3><p>study_java 디렉토리(자신이 만든 폴더) 위치에서 다음과 같이 폴더를 만들어 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">study_java</span><br><span class="line">└── com</span><br><span class="line">    └── example</span><br><span class="line">        └── demo</span><br><span class="line">            └── Main.java</span><br></pre></td></tr></table></figure><p>그리고 자바 파일도 다음과 같이 패키지를 선언해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 조건들을 만족한다면 <code>javac com\example\demo\Main.java</code> 명령어로 패키지 내부의 Main.java를 Main.class 파일로 컴파일 할 수 있다. 이후 실행시에는 <code>java com.example.demo.Main</code> 로 실행 하면된다.</p><h3 id="jar-파일로-만들기"><a href="#jar-파일로-만들기" class="headerlink" title="jar 파일로 만들기"></a>jar 파일로 만들기</h3><p>이제 만든 자바파일을 배포한다고 생각해보자. 자바는 자바 클래스 파일과, 클래스 들이 이용하는 관련 리소스및 메타 데이터를 하나의 파일로 모아서 자바 플랫폼에 배포할 수 있게 Jar(Java Archive) 파일로 압축할 수 있다.</p><p>다음과 같이 명령어를 입력해보자</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; jar -c -f main.jar com\*</span><br></pre></td></tr></table></figure><p>-c는 create의 약자로 jar파일을 만든다는 뜻이다. 이후 -f Main.jar 는 파일명을 명시하라는 명령어로 Main.jar로 만들겠다는 뜻이다. 이 옵션들을 설정한 이후 공백을 기준으로 담을 파일들을 지정할 수 있는데, <code>com\*</code>는 com 하위 디렉토리를 모두 포함한다는 의미이다. 별다른 에러가 뜨지 않았다면 해당 디렉토리에 main.jar파일이 잘 생성되어있는 것을 볼 수 있을 것 이다.</p><p>이제 실행해보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -cp . main.jar com.example.demo.Main</span><br><span class="line"><span class="comment">// -cp는 classpath의 약자이다</span></span><br></pre></td></tr></table></figure><p>위의 방법은 현재 디렉토리를 classpath로 잡고 Main.jar의 압축을 푼 뒤 com.example.demo의 Main클래스를 실행한다고 보면 된다. 하지만 jar파일 자체를 실행할 수 도 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -jar main.jar</span><br></pre></td></tr></table></figure><p>위의 방법으로 실행시 <code>no main manifest attribute, in test.jar</code>라는 오류 문구가 뜨는 것을 볼 수 있을 것 이다. 이는 매니페스트 파일을 만들어 Main 클래스의 위치를 명시해주면 해결 할 수 있다.</p><blockquote><p>메니페스트<br>JAR 파일 안에 포함되어 있는 매니페스트 파일은, 메타데이터 정보를 포함하고 있다. 이 메타데이터 정보에는 확장 정보 및 패키지 관련 데이터가 기술되어 있으며, 섹션 형식으로 구성된 키-값 쌍 형태의 문자열이다. JAR이 실행 가능하도록 하기 위해서는, 메니페스트 파일에, 애플리케이션의 메인 클래스의 이름이 기술되어 있어야 한다. 메니페스트 파일의 명칭은 MANIFEST.MF이며, 이 파일이 포함되어 있는 디렉토리는, 압축된 파일의 내용물 가운데 가장 첫번째 위치에 배치되어야 한다.</p></blockquote><ol><li>먼저 java_study 디렉토리에 manifest.txt 파일을 만들어주자.</li><li>Main-Class: com.example.demo.Main 적어주자.</li><li>cmd 에서 <code>jar -c -m manifest.txt  -f main.jar com\*</code> 를 다시 입력 하여 manifest파일을 포함하여 다시 jar파일로 압축해준다.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -jar main.jar</span><br></pre></td></tr></table></figure><p>다시 명령어를 입력하면 hello world! 가 잘 출력되는 것을 볼 수 있다.</p><p>이정도만 했는데도 벌써 찐이 빠진다. 여기에 의존성을 추가해야한다면 어떻게 할 수 있을까?</p><h3 id="logback-라이브러리-추가해보기"><a href="#logback-라이브러리-추가해보기" class="headerlink" title="logback 라이브러리 추가해보기"></a>logback 라이브러리 추가해보기</h3><p>logback은 기본적으로 다음 세개의 라이브러리가 필요하다. 각 링크에서 file에 jar파일로 다운받아 보자.</p><ul><li><a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-classic/1.2.3" rel="external nofollow noopener noreferrer" target="_blank">logback-classic-1.2.3</a></li><li><a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-core/1.2.3" rel="external nofollow noopener noreferrer" target="_blank">logback-core-1.2.3</a></li><li><a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-api/1.7.30" rel="external nofollow noopener noreferrer" target="_blank">sl4j-api-1.7.30</a></li></ul><p>java_study 의 최상위 경로에 lib 폴더를 생성하고 위의 jar파일들을 위치해준다. 이후 Main.java 파일을 다음과 같이 수정한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">logger.info(<span class="string">"Hello World!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 위의 java파일을 컴파일 하면 되는데, 이전의 System.out.println은 자바 유틸에서 기본적으로 제공하기때문에 상관 없었지만 우리는 logback 라이브러리를 사용하였기때문에 해당 의존성들을 classpath로 추가해주어야한다. 다음과 같이 입력해보자</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; javac -cp lib\logback-classic<span class="number">-1.2</span><span class="number">.3</span>.jar;lib\logback-core<span class="number">-1.2</span><span class="number">.3</span>.jar;lib\slf4j-api<span class="number">-1.7</span><span class="number">.30</span>.jar com\example\demo\Main.java</span><br></pre></td></tr></table></figure><p>해당 라이브러리들을 클래스패스로 등록하고 컴파일한다. 이후</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib\logback-classic<span class="number">-1.2</span><span class="number">.3</span>.jar;lib\logback-core<span class="number">-1.2</span><span class="number">.3</span>.jar;lib\slf4j-api<span class="number">-1.7</span><span class="number">.30</span>.jar;. com.example.demo.Main</span><br></pre></td></tr></table></figure><p>다음과 같이 실행 시 <code>03:42:58.346 [main] INFO com.example.demo.Main - Hello World!!</code> 와 같이 현재 시간을 포함한 문구가 뜨면 성공이다. 마지막 관문이 남았다. 이쯤되면 maven이 왜 필요할지 알것 같기도 하지만 의존성을 포함하여 jar로 압축하는 것까지는 끝내보자.</p><p>먼저 manifest.txt 파일의 Main-Class 밑에 다음 문장을 추가하자.<br><code>Class-Path: lib\logback-classic-1.2.3.jar lib\logback-core-1.2.3.jar lib\slf4j-api-1.7.30.jar</code></p><p>cmd에 다음과 같이 작성하자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; jar -c -m manifest.txt -f test.jar com\*</span><br><span class="line"><span class="comment">//에러 없이 잘 압축되면 다음 명령어 실행</span></span><br><span class="line">&gt; java -jar test.jar</span><br></pre></td></tr></table></figure><p>오랜만에 IDE를 사용하지 않고 자바를 컴파일하니 기억나지 않는 부분이 많아 이곳 저곳 찾아본것 같다. 다음 글에서는 maven을 사용하여 위의 과정을 메이븐으로 빌드하여 얼마나 간편한지 느껴보도록 하자. 본인도 글을 쓰면서 점점 귀차니즘이 발동되어 갈 수록 내용이 산으로 갔다. 다루고 싶은 내용은 더 있지만 글로써 전달하는게 이렇게 어려운 일인가 싶다..ㅎ</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/06/01/6.%20maven/maven01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바 웹 프로그래밍</title>
      <link>http://gojaebeom.github.io/2020/05/20/5.%20servlet/servlet01/</link>
      <guid>http://gojaebeom.github.io/2020/05/20/5.%20servlet/servlet01/</guid>
      <pubDate>Wed, 20 May 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 &lt;a href=&quot;https://gojaebeom.github.io/categories/%EC%9E%90%EB%B0%94-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/1-java/&quot;&gt;자바 카테고리&lt;/a&gt; 에서는 자바 언어를 배우고 자바 프로그램을 만드는 과정을 진행하였다. &lt;/p&gt;
&lt;p&gt;하지만 자바의 주 사용 목적은 웹 프로그램을 만드는 것이고 앞으로 자바 웹 프로그램을 만드는 것을 목표로 할 것이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이전 <a href="https://gojaebeom.github.io/categories/%EC%9E%90%EB%B0%94-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/1-java/">자바 카테고리</a> 에서는 자바 언어를 배우고 자바 프로그램을 만드는 과정을 진행하였다. </p><p>하지만 자바의 주 사용 목적은 웹 프로그램을 만드는 것이고 앞으로 자바 웹 프로그램을 만드는 것을 목표로 할 것이다. <a id="more"></a></p><p>그렇다면 자바 프로그램과 자바 웹 프로그램은 다른점이 무엇일까? 먼저 자바 프로그램은 콘솔, 윈도우를 통해 사용자가 입, 출력을 하여 프로그램과 상호작용을 하는 것을 말한다. </p><p>지금까지 다루었던 예제들은 IDE에서 지원하는 터미널이나 콘솔창등을 통해 Scanner로 입력을 받거나 출력받아 볼 수 있었을 것 이다. </p><p>웹 프로그램은 말 그대로 웹을 통하여 사용자와 상호작용을 하는 프로그램이다.  콘솔을 통해 입력을 받고 결과를 출력 받는 곳이 웹의 브라우저로 바뀐것 뿐이다. </p><h2 id="웹-서버-web-server"><a href="#웹-서버-web-server" class="headerlink" title="웹 서버(web server)"></a>웹 서버(web server)</h2><p>클라이언트에서 웹서버에게 주소(url)를 가지고 통신규칙(http)에 맞게 요청하면 그에 따른 응답을 받는다. 여기서 응답은 보통 정적인 html문서를 보여주게 된다.</p><p><img src="https://gojaebeom.github.io//images/servlet/example01.png" alt="img"></p><p>여기서 문제가 발생한다. html은 프로그래밍 언어가 아니다. 정적인 파일이다보니 데이터의 변화를 줄 수 있는 방법이 없는 것이다. 이때 웹 어플리케이션 서버가 등장한다.</p><h2 id="웹-어플리케이션-서버-WAS-web-applicatioin-server"><a href="#웹-어플리케이션-서버-WAS-web-applicatioin-server" class="headerlink" title="웹 어플리케이션 서버(WAS: web applicatioin server)"></a>웹 어플리케이션 서버(WAS: web applicatioin server)</h2><p><sup>웹 어플리케이션이란?</sup><br><sup>- 웹에서 실행되는 응용 프로그램</sup></p><p>그렇다면 웹 어플리케이션 서버는 다음같이 설명할 수 있다.</p><ul><li>웹 어플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크이다.</li><li>웹 어플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달한다.</li></ul><p><img src="https://gojaebeom.github.io//images/servlet/example02.png" alt="img"></p><h2 id="서블릿-Servlet"><a href="#서블릿-Servlet" class="headerlink" title="서블릿(Servlet)"></a>서블릿(Servlet)</h2><p>서블릿은 <u>서버 쪽에서 실행되고 클라이언트의 요청에 따라 동적으로 서비스를 제공하는 자바 클래스</u> 를 말한다. </p><h3 id="서블릿의-특징"><a href="#서블릿의-특징" class="headerlink" title="서블릿의 특징"></a>서블릿의 특징</h3><ul><li>서버쪽에서 실행되면서 기능을 수행</li><li>기존의 정적인 웹 프로그램의 문제점을 보완</li><li>스레드 방식으로 실행</li><li>자바로 만들어짐</li><li>컨테이너에서 실행</li><li>컨테이너 종류에 상관없이 실행됨(플랫폼 독립적)</li><li>보안 기능을 적용하기 쉬움</li><li>웹 브라우저에서 요청 시 기능을 수행함</li></ul><p>다음 글 부터 본격적으로 servlet 예제들을 다루도록 하겠다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/20/5.%20servlet/servlet01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 26. 람다식</title>
      <link>http://gojaebeom.github.io/2020/05/17/4.%20java/JAVA-26-%EB%9E%8C%EB%8B%A4%EC%8B%9D/</link>
      <guid>http://gojaebeom.github.io/2020/05/17/4.%20java/JAVA-26-%EB%9E%8C%EB%8B%A4%EC%8B%9D/</guid>
      <pubDate>Sun, 17 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;람다식이란&quot;&gt;&lt;a href=&quot;#람다식이란&quot; class=&quot;headerlink&quot; title=&quot;람다식이란?&quot;&gt;&lt;/a&gt;람다식이란?&lt;/h2&gt;&lt;p&gt;람다식은 &lt;u&gt;식별자 없이 실행가능한 함수&lt;/u&gt; 를 말한다. 자바8 버전부터 지원하는 기술로 함수적인 프로그래밍을 위함이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="람다식이란"><a href="#람다식이란" class="headerlink" title="람다식이란?"></a>람다식이란?</h2><p>람다식은 <u>식별자 없이 실행가능한 함수</u> 를 말한다. 자바8 버전부터 지원하는 기술로 함수적인 프로그래밍을 위함이다. <a id="more"></a></p><p>자바는 객체지향언어이다. 그런데 함수지향적인 코드가 가능하게 된 것은 요즘 함수지향적 프로그래밍이 자주 언급되고있기때문에 자바에서도 이를 지원한 것으로 보인다. </p><h2 id="함수지향-프로그래밍"><a href="#함수지향-프로그래밍" class="headerlink" title="함수지향 프로그래밍"></a>함수지향 프로그래밍</h2><p>함수형 프로그래밍에서 다루는 개념을 잠깐 살펴보자.</p><h3 id="1급-객체"><a href="#1급-객체" class="headerlink" title="1급 객체"></a>1급 객체</h3><p>함수지향에서 함수는 1급 객체라는 표현을 쓴다. 1급 객체의 특징은 다음과 같다.</p><ul><li>함수를 변수나 데이터 구조안에 담을 수 있다.</li><li>함수를 파라미터로 전달 할 수 있다.</li><li>함수를 반환값으로 사용할 수 있다.</li></ul><p>위의 특징은 변수가 가지는 특징들이다. 함수지향에서는 함수를 변수처럼 취급할 수 있다는게 큰 특징이다.</p><h3 id="불변성"><a href="#불변성" class="headerlink" title="불변성"></a>불변성</h3><p>함수형 프로그래밍에서는 데이터가 변할 수 없는데, 이를 불변성 데이터라고 한다. 데이터 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터의 복사본을 만들어 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행한다.</p><h3 id="순수-함수-Pure-function"><a href="#순수-함수-Pure-function" class="headerlink" title="순수 함수(Pure function)"></a>순수 함수(Pure function)</h3><p>순수 함수란 함수형 프로그래밍에서 필수적인 개념으로 다음과 같은 조건을 만족하는 함수를 의미한다.<br> -동일한 인자를 주면 동일한 결과를 리턴<br> -부수효과가 없어야함<br> -외부의 상태를 변화시키지는다.<br> -인자로 들어온 값을 변화시키지않는다.<br> -평가시점이 중요하지않다.</p><p>이밖의 고차함수, 합성함수등의 개념등이 더 있지만 개인적으로 객체지향의 이점을 이용하기위해 자바를 배우는 입장으로 함수지향은 지금 자세히 공부할 생각은 없다. </p><h2 id="람다식-사용해보기"><a href="#람다식-사용해보기" class="headerlink" title="람다식 사용해보기"></a>람다식 사용해보기</h2><p>자바에서 함수형 프로그래밍은 인터페이스를 통해 제공된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//람다식 사용을 위한 인터페이스</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//테스트해보기</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//람다식</span></span><br><span class="line">    Test test = (<span class="keyword">int</span> x, <span class="keyword">int</span> y)-&gt;x + y;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 람다식을 사용하면 인터페이스를 따로 구현받는 클래스를 정의 할 필요 없이 익명함수로 사용이 가능하다. 중요한 것은 <u>인터페이스 하나당 하나의 함수</u>만 만들 수 있다는 것 이다. 익명함수를 사용하기 때문에 함수를 구분하지 못하는것 이다. </p><p>그래서 람다식을 사용하는 인터페이스를 정의할 때</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>@FunctionalInterface</code> 라는 어노테이션을 붙여주면 된다.</p><h2 id="람다식-예제"><a href="#람다식-예제" class="headerlink" title="람다식 예제"></a>람다식 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t = (<span class="keyword">int</span> x, <span class="keyword">int</span> y)-&gt; (x &gt; y) ? x : y;</span><br><span class="line">    System.out.println(t.check(<span class="number">90</span>, <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문법적인 생략이 있지만 문법을 자세히 다루지는 않겠다. 함수지향은 추후에 필요해지면 공부할 생각이다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/17/4.%20java/JAVA-26-%EB%9E%8C%EB%8B%A4%EC%8B%9D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 25. 예외 처리</title>
      <link>http://gojaebeom.github.io/2020/05/16/4.%20java/JAVA-25-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/</link>
      <guid>http://gojaebeom.github.io/2020/05/16/4.%20java/JAVA-25-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/</guid>
      <pubDate>Sat, 16 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;오류-에러-error-란-무엇인가&quot;&gt;&lt;a href=&quot;#오류-에러-error-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;오류, 에러(error)란 무엇인가?&quot;&gt;&lt;/a&gt;오류, 에러(error)란 무엇인가?&lt;/h2&gt;&lt;p&gt;프로그램을 실했할 때 오작동이나 비정상적으로 종료되는 원인을 오류나 에러라고 한다. 에러는 컴파일 에러와 런타임 에러로 나뉜다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="오류-에러-error-란-무엇인가"><a href="#오류-에러-error-란-무엇인가" class="headerlink" title="오류, 에러(error)란 무엇인가?"></a>오류, 에러(error)란 무엇인가?</h2><p>프로그램을 실했할 때 오작동이나 비정상적으로 종료되는 원인을 오류나 에러라고 한다. 에러는 컴파일 에러와 런타임 에러로 나뉜다.<a id="more"></a></p><ul><li>컴파일 오류: 프로그램 코드 작성 중 발생하는 문법적 오류</li><li>런타임 오류: 실행 중인 프로그램이 의도 하지 않은 동작을 하거나(bug) 프로그램이 중지되는 오류 </li></ul><h2 id="예외처리"><a href="#예외처리" class="headerlink" title="예외처리"></a>예외처리</h2><p>자바에서는 실행 시 발생할 수 있는 오류를 ‘에러(error)’와 ‘예외(Exception)’으로 구분한다. 에러는 메모리의 부족, stack over flow와 같이 발생하게 되면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습할 수 있을 정도의 프로그래머가 예외처리를 통해 막을 수 있는 오류이다.</p><ul><li>시스템 오류(error)<ul><li>가상 머신에서 발생, 프로그래머가 처리할 수 없음</li><li>동적 메모리를 다 사용한 경우, stack over flow 등</li></ul></li><li>예외(Exception)<ul><li>프로그램에서 제어할 수 있는 오류</li><li>읽으려는 파일이 없는 경우, 네트웍이나 소켓 연결 오류 등</li></ul></li></ul><h2 id="예외-클래스-Exception"><a href="#예외-클래스-Exception" class="headerlink" title="예외 클래스(Exception)"></a>예외 클래스(Exception)</h2><p>예외에 대한 최상위 클래스로 Exception이 있다. 그리고 입출력, 런타임 예외 등 각각 해당하는 예외를 담당하는 클래스들이 이를 상속하는 모습이다.<br><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/exception/example1.png?raw=true" alt="이미지"></p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>자바에서 예외에 대한 처리는 다음과 같이 <code>try-catch</code> 구문으로 정의할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//예외가 발생 할 수 있는 코드 부분</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(처리할 예외 타입 e)&#123;</span><br><span class="line">  <span class="comment">//try블록 안에서 예외가 발생했을 때 수행되는 부분</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//예외 발생 여부와 상관 없이 항상 수행 되는 부분</span></span><br><span class="line">  <span class="comment">//리소스를 정리하는 코드를 주로 씀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적인 <code>try catch</code> 구문은 위와 같이 이루어 진다. <code>try</code>문에서 <code>Exception</code> 예외가 발생할 경우 <code>catch</code> 구문을 실행하게 된다. </p><ul><li>발생한 예외와 일치하는 catch 문이 있는지 확인</li><li>일치하는 catch문이 있다면 catch 블럭 내의 문장을 실행하고 try catch문을 빠져 나감</li><li>finally는 예외 발생 여부와 상관 없이 항상 수행됨</li></ul><h3 id="try-catch-활용"><a href="#try-catch-활용" class="headerlink" title="try-catch 활용"></a>try-catch 활용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서는 에러가 난다. 배열 arr의 크기는 0~2까지 총 3인데 for문은 4번 반복하면서 arr의 4번째 공간의 값을 출력하려고하는 부분에서 나는 오류이다. 그리고 이후의 hi문자를 출력하지 않고 에러가나는 부분에서 프로그램이 멈추는 것을 볼 수 있다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>에러가 날것 같은 부분을 <code>try</code>구문으로 감쌌다. 그리고 에러가 나면 <code>catch</code> 구문에서 에러원인을 출력하는 것을 볼 수 있다. 여기서 중요한 점은 에러가 났음에도 그에 대한 원인만 출력하고 프로그램은 계속 실행되고 있다. 이처럼 예외에 대한 오류는 예외처리를 통해 프로그래머가 프로그램의 비정상적인 종료를 막을 수 있다.</p><h2 id="예외의-종류"><a href="#예외의-종류" class="headerlink" title="예외의 종류"></a>예외의 종류</h2><ul><li><strong>NullPointException</strong> : null 레퍼런스를 참조할 때 발생</li><li><strong>ClassCastExeption</strong> : 변환할 수 없는 타입으로 객체를 변환할 때 발생</li><li><strong>OutOfMemoryException</strong> : 메모리가 부족한 경우 발생</li><li><strong>IOException</strong> : 입출력 동작 중 인터럽트 발생. 자바에서 입출력 함수를 사용하는 경우 반드시 이 예외처리를 해주도록 되어있다.<ul><li>인터럽트(interrupt) : 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우 마이크로프로세서에게 알려 처리할 수 있도록 하는 것</li></ul></li><li><strong>NumberFormatException</strong> : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환하는 경우 발생한다.</li><li><strong>IllegalArgumentException</strong> : 잘못된 인자를 전달하는 경우 발생한다.</li><li><strong>ArrayIndexOutOfBoundsException</strong> : 배열의 범위를 벗어나서 접근을 하는 경우 발생한다.</li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/16/4.%20java/JAVA-25-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 24. 컬랙션 프레임워크</title>
      <link>http://gojaebeom.github.io/2020/05/13/4.%20java/JAVA-24-%EC%BB%AC%EB%9E%99%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/</link>
      <guid>http://gojaebeom.github.io/2020/05/13/4.%20java/JAVA-24-%EC%BB%AC%EB%9E%99%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/</guid>
      <pubDate>Wed, 13 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;컬랙션-프레임워크-Colletion-FrameWork&quot;&gt;&lt;a href=&quot;#컬랙션-프레임워크-Colletion-FrameWork&quot; class=&quot;headerlink&quot; title=&quot;컬랙션 프레임워크(Colletion FrameWork)&quot;&gt;&lt;/a&gt;컬랙션 프레임워크(Colletion FrameWork)&lt;/h2&gt;&lt;p&gt;우리가 프로그램을 만들다보면 기본적인 자료구조들이 많이 쓰이게 된다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="컬랙션-프레임워크-Colletion-FrameWork"><a href="#컬랙션-프레임워크-Colletion-FrameWork" class="headerlink" title="컬랙션 프레임워크(Colletion FrameWork)"></a>컬랙션 프레임워크(Colletion FrameWork)</h2><p>우리가 프로그램을 만들다보면 기본적인 자료구조들이 많이 쓰이게 된다.<a id="more"></a> 컬랙션 프레임워크들은 이러한 자료구조들을 미리 구현해놓은 라이브러리를 말한다. JDK를 다운받으면 같이 제공되는 라이브러리로 java.util 패키지에 구현되어있다. </p><ul><li>Collection 인터페이스와 Map 인터페이스로 구성되어있음</li></ul><h2 id="Collection-인터페이스"><a href="#Collection-인터페이스" class="headerlink" title="Collection 인터페이스"></a>Collection 인터페이스</h2><p><code>Collection</code>은 하나의 객체 관리를 위해 선언된 인터페이스로 필요한 기본 메서드가 선언되어 있다. (즉 하나의 객체를 대상으로 하는 자료구조이다)</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%BD%9C%EB%9E%99%EC%85%98/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C1.PNG?raw=true" alt="image"><br>위의 이미지와 같이 하위에 <code>List</code>와 <code>Set</code> 인터페이스가 있다. </p><h3 id="List-인터페이스의-특징"><a href="#List-인터페이스의-특징" class="headerlink" title="List 인터페이스의 특징"></a>List 인터페이스의 특징</h3><ul><li>순서가 있는 자료 관리</li><li>중복 허용</li><li>이 인터페이스를 구현한 클래스는 <code>ArrayList</code>, <code>Vectior</code>, <code>LinkedList</code>, <code>Stack</code>, <code>Queue</code> 등이 있음</li></ul><h3 id="Set-인터페이스의-특징"><a href="#Set-인터페이스의-특징" class="headerlink" title="Set 인터페이스의 특징"></a>Set 인터페이스의 특징</h3><ul><li>순서가 정해져 있지 않음</li><li>중복을 허용하지 않음</li><li>이 인터페이스를 구현한 클래스는 <code>HashSet</code>, <code>TreeSet</code> 등이 있음</li></ul><h2 id="Map-인터페이스"><a href="#Map-인터페이스" class="headerlink" title="Map 인터페이스"></a>Map 인터페이스</h2><p><code>Map</code>은 <code>Collection</code>과 다르게 쌍으로 이루어진 객체를 관리하는데 필요한 여러 메서드가 선언되어 있다. 여기서 객체는 <code>Key-value</code> 쌍으로 되어 있고 <code>key</code>는 중복될 수 없다.</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/%EC%BD%9C%EB%9E%99%EC%85%98/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C2.PNG?raw=true" alt="image"></p><p>위의 이미지와 같이 하위에 <code>HashTable</code>,<code>HashMap</code>,<code>TreeMap</code> 등의 인터페이스가 있다. </p><p>위의 인터페이스들의 각 설명은 다른 포스트에 작성하도록 하겠다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/13/4.%20java/JAVA-24-%EC%BB%AC%EB%9E%99%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 23. 제네릭 타입</title>
      <link>http://gojaebeom.github.io/2020/05/12/4.%20java/JAVA-23-%EC%A0%9C%EB%84%A4%EB%A6%AD/</link>
      <guid>http://gojaebeom.github.io/2020/05/12/4.%20java/JAVA-23-%EC%A0%9C%EB%84%A4%EB%A6%AD/</guid>
      <pubDate>Tue, 12 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;제네릭-Generic&quot;&gt;&lt;a href=&quot;#제네릭-Generic&quot; class=&quot;headerlink&quot; title=&quot;제네릭(Generic)&quot;&gt;&lt;/a&gt;제네릭(Generic)&lt;/h2&gt;&lt;p&gt;제네릭은 자바 5 이후에 도입되었다. &lt;strong&gt;제네릭(Generic)&lt;/strong&gt;은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다. 먼저 예제를 보자.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="제네릭-Generic"><a href="#제네릭-Generic" class="headerlink" title="제네릭(Generic)"></a>제네릭(Generic)</h2><p>제네릭은 자바 5 이후에 도입되었다. <strong>제네릭(Generic)</strong>은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다. 먼저 예제를 보자.<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 클래스명 뒤의 &lt;&gt;에 타입 매개변수를 지정할 수 있다. T는 Type의 약자인데 사실 이름은 아무렇게나 정의할 수 있다. 하지만 일반적으로 이름은 다음과 같이 짓는다.</p><h2 id="제네릭-기본문법"><a href="#제네릭-기본문법" class="headerlink" title="제네릭 기본문법"></a>제네릭 기본문법</h2><p>제네릭예제를 다루기 이전에 제네릭에대한 기본문법을 간략히 알아보자.</p><h3 id="타입-파라미터-명명-규칙"><a href="#타입-파라미터-명명-규칙" class="headerlink" title="타입 파라미터 명명 규칙"></a>타입 파라미터 명명 규칙</h3><ul><li>한문자로 이름 짓기</li><li>대문자로 이름 짓기</li></ul><p>보편적으로 자주 사용하는 타입 매개변수의 이름과 의미는 다음과 같다.</p><ul><li>E (Element)</li><li>K (Key)</li><li>N (Number)</li><li>T (Type)</li><li>V (Value)</li></ul><h3 id="다중-타입-파라미터"><a href="#다중-타입-파라미터" class="headerlink" title="다중 타입 파라미터"></a>다중 타입 파라미터</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example2</span></span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Example&lt;Example2,Example3&gt; example;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 타입은 두개 이상도 가능하다. 그에 따라 사용시 매개변수의 수만큼 사용할 클래스를 정의해주면 된다.</p><h3 id="기본-자료형-제한"><a href="#기본-자료형-제한" class="headerlink" title="기본 자료형 제한"></a>기본 자료형 제한</h3><p>제네릭 클래스에 대하여 타입 파라미터의 값을 받을때 기본 자료형의 이름은 타입 인자로 쓸 수 없다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example&lt;<span class="keyword">int</span>&gt; example = <span class="keyword">new</span> Example&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure><p>하지만 기본 자료형에 대한 래퍼 클래스가 존재하고, 필요한 상황에서 박싱과 언박싱이 자동으로 이뤄지기 때문에 다음과 같은 코드를 작성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Example&lt;Integer&gt; example = <span class="keyword">new</span> Example&lt;Integer&gt;();</span><br><span class="line">    example.set(<span class="number">100</span>); <span class="comment">//오토박싱</span></span><br><span class="line">    <span class="keyword">int</span> num = example.get(); <span class="comment">//오토 언박싱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="타입-인자의-생략"><a href="#타입-인자의-생략" class="headerlink" title="타입 인자의 생략"></a>타입 인자의 생략</h3><p>컴파일러는 프로그래머가 작성하는 제네릭 관련 문장에서 자료형의 이름을 추론하는 능력을 갖고 있다. 따라서 다음과 같은 문법이 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example&lt;String&gt; example = <span class="keyword">new</span> Example&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//위 문장을 아래와 같이 표현할 수 있다.</span></span><br><span class="line">Example&lt;String&gt; example = <span class="keyword">new</span> Example&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="타입-파라미터를-타입-인자로-전달"><a href="#타입-파라미터를-타입-인자로-전달" class="headerlink" title="타입 파라미터를 타입 인자로 전달"></a>타입 파라미터를 타입 인자로 전달</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example&lt;Example&lt;String&gt;&gt; example = <span class="keyword">new</span> Example&lt;&gt;();</span><br></pre></td></tr></table></figure><p>위와 같이 타입 인자로 타입 파라미터를 가진 클래스를 담을 수 있다.</p><h3 id="타입-인자-제한하기"><a href="#타입-인자-제한하기" class="headerlink" title="타입 인자 제한하기"></a>타입 인자 제한하기</h3><p>제네릭 클래스를 정의 시 담고 싶은 것을 용도에 따라 제한하는 일도 생긴다. 이때 타입을 제한하는 문법을 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Example&lt;String&gt; example = <span class="keyword">new</span> Example&lt;&gt;();<span class="comment">//에러</span></span><br><span class="line"></span><br><span class="line">        Example&lt;Integer&gt; example = <span class="keyword">new</span> Example&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 제네릭 타입을 정의할 때 타입 파라미터 <code>T</code>가 <code>Number</code> 클래스를 상속하는 코드를 작성하므로, Example 타입 인자로 Number 또는 이를 상속하는 하위 클래스만 담을 수 있는 것을 알 수 있다.</p><h2 id="제네릭-예제"><a href="#제네릭-예제" class="headerlink" title="제네릭 예제"></a>제네릭 예제</h2><h3 id="제네릭-이전-코드"><a href="#제네릭-이전-코드" class="headerlink" title="제네릭 이전 코드"></a>제네릭 이전 코드</h3><p>제네릭이 왜 필요한지 예제를 다루어보자. 먼저 제네릭 사용 이전의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericTest.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blueberry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BlueVerry"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleBox</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.apple = apple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueverryBox</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Blueverry blueverry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Blueverry blueverry)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blueverry = appleblueverry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Blueverry <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blueverry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>과일 박스를 추상화하여 만든 클래스이다. 사과와 블루베리 클래스를 각 사과박스와 블루베리박스가 담아서 사용하는 예제를 테스트해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        AppleBox aBox = <span class="keyword">new</span> AppleBox();</span><br><span class="line">        BlueverryBox bBox = <span class="keyword">new</span> BlueverryBox();</span><br><span class="line"></span><br><span class="line">        aBox.set(<span class="keyword">new</span> Apple);</span><br><span class="line">        bBox.set(<span class="keyword">new</span> Blueverry);</span><br><span class="line"></span><br><span class="line">        Apple apple = aBox.get();</span><br><span class="line">        Blueverry blueverry = aBox.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위의 <code>AppleBox</code> 와  <code>BlueverryBox</code>는 비슷한 코드들이 많다. 즉 따로 만들지 않고 Box라는 클래스를 통해 서로다른 객체로써 과일을 담을 수 있으니 다음과 같이 바꿀 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Box aBox = <span class="keyword">new</span> Box();</span><br><span class="line">        Box bBox = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        aBox.set(<span class="keyword">new</span> Apple);<span class="comment">//업캐스팅</span></span><br><span class="line">        bBox.set(<span class="keyword">new</span> Blueverry);<span class="comment">//업캐스팅</span></span><br><span class="line"></span><br><span class="line">        Apple apple = (Apple)aBox.get(); <span class="comment">//다운캐스팅</span></span><br><span class="line">        Blueverry blueverry = (Blueverry)bBox.get(); <span class="comment">//다운캐스팅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사과박스와 블루베리 박스역할을 하던 클래스두개를 하나의 클래스로 재정의하였다. Box 클래스는 사과와 블루베리 뿐만아니라 다른것들도 담을 수 있으므로 확장성과 제사용성이 더 좋아졌다. 그리고 위의 예제에서 보이고자 하는 부분은 <code>set 메소드</code>의 매개변수로 <code>Apple</code>과 <code>Blueverry</code>가 들어갈땐 업캐스팅으로 자동형변환이되어 들어간다. 하지만 그 값이 사용되는 부분에서 다운캐스팅을하는데 이때 명식적으로 형변환을 해주어야한다. 이 과정은 번거롭고 또 사용자의 실수가 발생할 수 있다. </p><h3 id="제네릭-적용-코드"><a href="#제네릭-적용-코드" class="headerlink" title="제네릭 적용 코드"></a>제네릭 적용 코드</h3><p>위의 코드를 제네릭을 적용하여 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Box aBox&lt;Apple&gt; = <span class="keyword">new</span> Box&lt;Apple&gt;();<span class="comment">//선언시에 타입을 지정</span></span><br><span class="line">        Box bBox&lt;Blueverry&gt; = <span class="keyword">new</span> Box&lt;Blueverry&gt;();<span class="comment">//선언시에 타입을 지정</span></span><br><span class="line"></span><br><span class="line">        aBox.set(<span class="keyword">new</span> Apple);<span class="comment">//업캐스팅</span></span><br><span class="line">        bBox.set(<span class="keyword">new</span> Blueverry);<span class="comment">//업캐스팅</span></span><br><span class="line"></span><br><span class="line">        Apple apple = aBox.get(); <span class="comment">//다운캐스팅</span></span><br><span class="line">        Blueverry blueverry = bBox.get(); <span class="comment">//다운캐스팅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 생성시에 타입 파라미터를 지정함으로써 다운캐스팅시 명시적으로 형변환을 해주지 않아도 되는것을 알 수 있다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/12/4.%20java/JAVA-23-%EC%A0%9C%EB%84%A4%EB%A6%AD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 22. String, Wrapper 클래스</title>
      <link>http://gojaebeom.github.io/2020/05/11/4.%20java/JAVA-22-String,%20wrapper/</link>
      <guid>http://gojaebeom.github.io/2020/05/11/4.%20java/JAVA-22-String,%20wrapper/</guid>
      <pubDate>Mon, 11 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;String-클래스&quot;&gt;&lt;a href=&quot;#String-클래스&quot; class=&quot;headerlink&quot; title=&quot;String 클래스&quot;&gt;&lt;/a&gt;String 클래스&lt;/h2&gt;&lt;p&gt;자바에서 문자열을 사용하기 위해 기본적으로 String 클래스라는 것을 재공한다. 선언 방법은 다음과 같다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="String-클래스"><a href="#String-클래스" class="headerlink" title="String 클래스"></a>String 클래스</h2><p>자바에서 문자열을 사용하기 위해 기본적으로 String 클래스라는 것을 재공한다. 선언 방법은 다음과 같다.<a id="more"></a></p><h3 id="String-사용하기"><a href="#String-사용하기" class="headerlink" title="String 사용하기"></a>String 사용하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// 인스턴스로 생성</span></span><br><span class="line">  String str2 = <span class="string">"world"</span>; <span class="comment">// 상수 풀에 있는 문자열을 가리킴</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 두가지 선언방법을 보았는데, 두가지 방법의 차이점은 다음과 같이 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// 인스턴스로 생성</span></span><br><span class="line">  String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// 인스턴스로 생성</span></span><br><span class="line"></span><br><span class="line">  String str3 = <span class="string">"hello"</span>; <span class="comment">// 상수 풀에 있는 문자열을 가리킴</span></span><br><span class="line">  String str4 = <span class="string">"hello"</span>; <span class="comment">// 상수 풀에 있는 문자열을 가리킴</span></span><br><span class="line"></span><br><span class="line">  System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">  System.out.println(str3 == str4); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 <code>str1</code>,<code>str2</code>은 서로 다른 인스턴스를 참조하기때문에 <code>false</code>라는 값이 출력되고 <code>str3</code>,<code>str4</code>는 상수 풀에 있는 같은 값을 가리키기 때문에 <code>true</code>가 출력되었다. 상수풀은 <a href="https://gojaebeom.github.io/2020/04/22/java/JAVA-03-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/">상수와 형변환</a> 편에서 한번 다룬적이 있다.</p><p>위의 코드는 다음과 같은 이미지로 비유될 수 있다.</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/string.png?raw=true" alt="이미지"></p><h3 id="String의-불변성"><a href="#String의-불변성" class="headerlink" title="String의 불변성"></a>String의 불변성</h3><p>String 객체가 하나 생성되면, 그 값은 길어지거나 줄어들 수 없으며, 그 문자들 중 어떤 것도 바뀔 수 없다. 그래서 String 객체는 변경불능(immutable)이라고 한다. 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String hello = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">  String world = <span class="keyword">new</span> String(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(System.identityHashCode(hello)); <span class="comment">//2036958521</span></span><br><span class="line">  hello = hello.concat(world);</span><br><span class="line">  System.out.println(System.identityHashCode(hello)); <span class="comment">//1945604815</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음 참조변수 <code>hello</code>의 주소값을 출력할때와 이후 <code>concat</code> 메소드를 통해 참조변수 <code>world</code>를 연결하고 주소값을 출력할때의 값이 각각 다르다.(여기서 <code>identityHashCode</code>라는 System클래스의 메소드는 객체가 메모리에서 가진 해쉬 주소값을 출력한다)</p><p>String 클래스는 처음 생성한 값의 변경이 불가능하다. 대신 <code>concat</code>이나 <code>+</code>로 연결하는 등 변화를 주게 되면 그 문자열은 다른 공간에 새로 생성이되고 참조변수는 그 주소를 가리키게 되는 것 뿐이다. </p><p>위의 방법은 메모리의 공간을 새로 참조하면서 낭비를 유발하기때문에 다음과 같은 상황에서는 자바에서 제공하는 <code>StringBuffer</code> 또는 <code>StringBuilder</code> 클래스를 사용하는 것이 좋다. </p><h3 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer, StringBuilder"></a>StringBuffer, StringBuilder</h3><p>두 클래스의 차이는 다음과 같다.</p><ul><li>StringBuffer는 멀티 쓰레드프로그래밍에서 동기화가 보장된다.</li><li>단일 쓰레드 프로그래밍에서는 StringBuilder를 사용하는것이 더 좋다.</li></ul><p>아직 쓰레드를 배우지 않았기에 이런 특징이 있다고만 이해하고 넘어가는게 좋을것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buffer 사용예제</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  StringBuffer buff = <span class="keyword">new</span> StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">  buff.append(<span class="string">" world"</span>);</span><br><span class="line">  System.out.println(buff); <span class="comment">//hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Wrapper-클래스"><a href="#Wrapper-클래스" class="headerlink" title="Wrapper 클래스"></a>Wrapper 클래스</h2><p>프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있다. 예를 들어, 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수는 없다. 이때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 한다.</p><p>이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 래퍼 클래스(Wrapper class)라고 한다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 준다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공이된다.</p><p>자바의 기본 타입에 대응하여 제공하고 있는 래퍼 클래스는 다음과 같다.</p><table><thead><tr><th>기본형 타입</th><th>wrapper class</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Charter</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>void</td><td>Void</td></tr></tbody></table><blockquote><p>void 클래스는 실체화될 수 없으며 단지 공 참조 개념을 나타낸다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/11/4.%20java/JAVA-22-String,%20wrapper/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 21. 객체지향의 특징</title>
      <link>http://gojaebeom.github.io/2020/05/06/4.%20java/JAVA-21-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/</link>
      <guid>http://gojaebeom.github.io/2020/05/06/4.%20java/JAVA-21-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/</guid>
      <pubDate>Wed, 06 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체지향-프로그래밍-Object-Oriented-Programming-이란&quot;&gt;&lt;a href=&quot;#객체지향-프로그래밍-Object-Oriented-Programming-이란&quot; class=&quot;headerlink&quot; title=&quot;객체지향 프로그래밍(Object Oriented Programming )이란?&quot;&gt;&lt;/a&gt;객체지향 프로그래밍(Object Oriented Programming )이란?&lt;/h2&gt;&lt;p&gt;객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체란 하나의 역할을 수행하는 ‘메소드와 변수(데이터)’의 묶음으로 봐야 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="객체지향-프로그래밍-Object-Oriented-Programming-이란"><a href="#객체지향-프로그래밍-Object-Oriented-Programming-이란" class="headerlink" title="객체지향 프로그래밍(Object Oriented Programming )이란?"></a>객체지향 프로그래밍(Object Oriented Programming )이란?</h2><p>객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체란 하나의 역할을 수행하는 ‘메소드와 변수(데이터)’의 묶음으로 봐야 한다.<a id="more"></a></p><p>어느 유튜버의 강의을 보다가 가장 마음에 와닿았던 맨트가 있었다. 철학자 <strong>플라톤</strong>의 <strong>이데아 론</strong>을 객체지향(OOP)과 빗대어 설명한 부분이다.</p><p>“<em>목수의 머릿속엔 가장 이상적이고 완벽한 책상이 하나 존재한다. 목수가 현실에 책상을 만들때는 그 이상적인 세계에 존재하는 책상을 본따서 만든다고 한다. 즉 현실의 책상은 목수의 머릿속에 있는 책상의 이상적인 설계도를 본따서 만든다고 생각할 수 있다. 플라톤은 이 이상적인 세계를 <strong>이데아</strong>라고 불렀다. 그리고 현실에 존재하는 물건은 그 이상적인 세계에 있는 물건을 가져와 복제한 <strong>레플리카</strong>라고 했다.</em>“</p><p>갑자기 철학적인 이야기가 나와 이상하다고 생각할 수 있지만, 우리가 프로그래밍에 사용하는 class, object 들은 실제로 고대 그리스 <strong>플라톤의 이데아론</strong>에서 왔다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>우리는 위와 같이 클래스를 정의하고 사용해왔다. 하지만 위의 클래스는 단지 정의 되어져 있을 뿐 사용된 것은 아니다. 이것은 우리가 머릿속에서 생각하는 이상적인 설계도일 뿐이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Dog backgoo = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">  Dog rudy = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">  Dog jack = <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 머릿속의 개라는 이미지를 현실에 만들었을때(인스턴스화), 비로소 이것은 객체로써 존재하게 되는 것 이다. 우리는 이것을 머리에 암기하는 것이 아니라, 자연스러운 흐름대로 이해할 필요가 있다.</p><p>이제 객체지향의 특징들에 대해서 알아보자.</p><h3 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h3><ul><li><em>추상화</em></li><li><em>캡슐화</em></li><li><em>상속</em></li><li><em>다형성</em></li></ul><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><p>추상화에 사전적 정의는 다음과 같다.</p><blockquote><p>추상(抽象)은 사물을 정확하게 이해하기 위해서는 사물이 지니고 있는 여러 가지 측면 가운데서 특정한 측면만을 가려내어 포착하는 것이다. 어떤 일면만을 추상하는 것은 다른 측면을 버린다는 것과 같다. 이것을 ‘사상(捨象)’이라 한다.</p></blockquote><p>추상화에 대한내용은 생각하기에 따라 다르기도하고 설명이 너무 난잡해질 수 도 있는 것 같다. 정말 간단하게 생각하자면, <strong>자바에서 추상화란 공통된 속성(변수)과 행위(메소드)를 모아서 클래스를 만드는 것이다.</strong></p><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>객체지향에서 캡슐화란 두가지 특징이 있다.</p><ul><li><em>객체의 속성(맴버변수, data fields)과 행위(메서드, methods)를 하나로 묶는다.</em></li><li><em>실제 구현 내용 일부를 외부에 감추어 은닉한다.</em></li></ul><p>외부에 감추는 방법으로는 언어적 측면으로 접근제한자를 두어 은닉의 정도를 기술하여 구현한다. 이것이 캡슐화에서 중요한 <strong>정보은닉</strong>이다.</p><h3 id="정보은닉-개념"><a href="#정보은닉-개념" class="headerlink" title="정보은닉 개념"></a>정보은닉 개념</h3><p>정보은닉이란 캡슐화된 객체의 내부구현을 외부로부터 숨기는 것이다. 이전 포스트에서도 다루었는데, 자바에서 정보란 클래스의 인스턴스변수(맴버변수, 필드, 속성 등)를 말한다. 보통 이러한 정보들은 접근제한자를 두어 외부에서 직접 접근하지 못하게 하고 메소드를 통해서만 변수에 접근할 수 있게 하는 방식을 많이 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 Person은 사람의 기본적인 특징 ‘이름을 가지고있다’ 를 반영한 클래스이다. 이를 인스턴스화하여 다음과 같이 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Person jaebeom = <span class="keyword">new</span> Person();</span><br><span class="line">  jaebeom.setName(<span class="string">"고재범"</span>);</span><br><span class="line">  System.out.println(jaebeom.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 작성자인 본인이 만든 클래스이다. 이것을 만든 의도는 본인이 가장 잘 이해하고있다.(잘 만들었던 못 만들었던 만든사람의 의도가 명확하다) 그리고 작성자는 맴버변수인 name에 값을 바로 대입하지 않고 메소드를 통해서 값을 할당하고 사용되길 원한다. 하지만 위의 예제의 경우에 접근지시자(접근제한자)를 사용하지 않았다. 그로 인하여 다른 사용자가 잘못 사용하게되는 예를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Person jade = <span class="keyword">new</span> Person();</span><br><span class="line">  jade.name = <span class="string">"고재범"</span>;</span><br><span class="line">  System.out.println(jade.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 클래스의 맴버변수에 바로 접근하여 값을 할당하고 출력하는 모습을 볼 수 있다. 이는 작성자의 의도와 다르게 잘못된 방향으로 사용이 되고있다. 위의 경우 치명적인 문제가 생길 일은 없지만, 맴버변수 name을 위해 정의한 setName, getName 메소드가 불필요하게 되어버렸다. 이렇게 작성자의 의도와는 반대로 사용이 되어지는 것을 막기위해 우리는 정보를 은닉할 필요가 있다. 사실 위의 예제로는 정보은닉의 필요성을 못 느낄 수 도 있다. 그렇다면 내용을 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(weight &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"몸무게는 0보다 작거나 같을 수 없습니다! 다시 입력해주세요"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 클래스에 몸무게라는 속성을 추가하였다. 그리고 setWeight 메소드를 보면 몸무게는 0키로그램보다 작거나 같을 수 없기 때문에 예외적인 부분을 처리하고 있다. 하지만 사용자가 이외의 방법으로 접근하여 -999 같은 값을 입력할 수 있다면 이는 프로그램 실행의 문제로도 이어질 수 있는 부분이다. 위의 예제를 다음과 같이 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(weight &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"몸무게는 0보다 작거나 같을 수 없습니다! 다시 입력해주세요"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>접근 제한자 private 을 속성에 지정하여 외부에서의 접근을 막는다. 그리고 이 속성들은 오직 메소드(행동)을 통해서만 통제할 수 있도록 할 수 있다. (public 은 외부의 모든 곳에서 사용이 가능하지만 따로 접근 제한자를 명시하지 않으면 default 제한자와 같다. 이는 외부 패키지와 상속받은 클래스등에서는 사용할 수 없게 된다)</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다. 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하게 되는데, 이러한 작업을 <strong>‘오버라이딩(Overriding)’</strong>이라고 한다. 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> IMEI;<span class="comment">//고유번호</span></span><br><span class="line">  <span class="keyword">private</span> String model;<span class="comment">//폰의 기종 이름</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//객체를 생성시 기본정보를 기입받는 생성자</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//전화</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messege</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//메세지</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 Phone에 대한 클래스의 정의이다. 이 클래스는 외부에서 잘 사용되어 지고 있다. 하지만 시대가 변함에 따라 스마트 폰이 나오고 Phone 클래스에도 새로운 기능들을 넣으려고 한다. 만약 Phone의 클래스 내부의 값이나 메소드들의 로직을 직접 수정하게 되면 지금까지 Phone 클래스와 의존성이 있는 모든 클래스들을 다시 수정해야 한다. 예를 들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> IMEI;</span><br><span class="line">  <span class="keyword">private</span> String model;</span><br><span class="line">  <span class="keyword">private</span> String OS; <span class="comment">//새로 추가된 속성, 안드로이드 또는 ios 의 OS 탑재 가능</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//객체 생성시 기본정보를 입력받는 생성자 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model, String OS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    <span class="keyword">this</span>.OS = OS; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//새로 추가된 메소드, 웹 검색을 할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webSearch</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">//하지만 기존의 phone에서는 불가능하기때문에 스마트폰이아니면 불필요한 메소드가 된다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Phone myPhone = new Phone(000000, "모토로라"); //에러</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 기존에 사용하던 생성자는 매개변수를 2개만 받았는데</span></span><br><span class="line"><span class="comment">      * OS의 종류까지 초기에 입력받는 것으로 수정되었다.</span></span><br><span class="line"><span class="comment">      * 물론 메소드 오버로딩으로 기존의 생성자는 유지하고 새로운 생성자를 만들 수 도 있지만, </span></span><br><span class="line"><span class="comment">      * 이 밖에도 추가되고 수정되어야 할것이 많다고 가정해보자.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//결국 다음과 같이 수정해야 한다.</span></span><br><span class="line">      Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>, <span class="string">"OS 없음"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 내부적인 코드의 변화로 인해 Phone과 의존성이 있는 클래스들은 모두 수정해야 한다. 하지만 기존의 Phone 클래스는 수정하지 않고 Phone의 기능을 상속받아 새로 SmartPhone이라는 클래스를 정의한다면 어떻게 될까. 예제를 통해 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> IMEI;</span><br><span class="line">  <span class="keyword">private</span> String model;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> IMEI, String model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IMEI = IMEI;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String OS;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SmartPhone</span><span class="params">(<span class="keyword">int</span> IMEI, String model, String OS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(IMEI, model);<span class="comment">//부모 클래스 생성자에게 필요한 매개변수 전달</span></span><br><span class="line">    <span class="keyword">this</span>.OS = OS;<span class="comment">//추가적으로 OS 종류 전달</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bluetooth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//블루투스</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiFi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//와이파이</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone myPhone = <span class="keyword">new</span> Phone(<span class="number">000000</span>, <span class="string">"모토로라"</span>);<span class="comment">//기존 사용자는 손대지 않는다.</span></span><br><span class="line"></span><br><span class="line">    SmartPhone yourPhone = <span class="keyword">new</span> SmartPhone(<span class="number">000001</span>, <span class="string">"A90"</span>, <span class="string">"안드로이드"</span>);<span class="comment">// 새로 스마트폰을 사용하는 사용자만 바꾸어주면 된다.</span></span><br><span class="line">    yourPhone.wiFi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제와 같이 기존의 폰을 사용 사용하는 사람은 따로 변화를 주지 않아도 되고, 새로 스마트폰을 쓰는 사람들만 SmartPhone 객체로 생성해주면 되는 것 이다. 이건 어디까지나 글쓴이가 생각하는 예제이다. 본인한테 맞는 방법으로 생각하는 것이 좋을 것 같다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p><a href="https://gojaebeom.github.io/2020/05/03/java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1">다형성</a>에 대한 정리 글을 참고해보자. 다형성은 여러 가지 형태를 가질 수 있는 기능을 말한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LolChampions</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">champName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">qSkill</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wSkill</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eSkill</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rSkill</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">champInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"챔피언 정보"</span>);</span><br><span class="line">    champName();</span><br><span class="line">    qSkill();</span><br><span class="line">    wSkill();</span><br><span class="line">    eSkill();</span><br><span class="line">    rSkill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heimerdinger</span> <span class="keyword">extends</span> <span class="title">LolChampions</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">champName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"하이머딩거"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Q스킬 : H-28G 진화형 포탑"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"W스킬 : 마법공학 초소형 로켓"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"E스킬 : CH-2 전자폭풍 수류탄"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"궁극기 : 업그레이드!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lux</span> <span class="keyword">extends</span> <span class="title">LolChampions</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">champName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"럭스"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Q스킬 : 빛의 속박"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"W스킬 : 프리즘 보호막"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"E스킬 : 광휘의 특이점"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"궁극기 : 최후의 섬광"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다형성을 설명하기위해 두개의 클래스가 하나의 추상클래스를 상속받는 예제를 보였다. 아래 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphismTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LolChampions lolChamp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"챔피언을 고르시오."</span>);</span><br><span class="line">    System.out.println(<span class="string">"1. 하이머딩거 / 2. 럭스"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(sc.nextInt()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      lolChamp = <span class="keyword">new</span> Heimerdinger();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      lolChamp = <span class="keyword">new</span> Lux();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      System.out.println(<span class="string">"잘못된 입력입니다!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lolChamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lolChamp.champInfo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LolChampions</code> 타입의 참조변수를 선언하고 <code>null</code> 값을 받고 있다. 그리고 스캐너를 통해 콘솔값 1을 입력받으면 참조변수 <code>lolChamp</code>에 <code>Heimerdinger</code> 인스턴스를 참조하고 2를 입력 받으면 <code>Lux</code> 인스턴스를 참조한다. 이것이 다형성이다. 하나의 참조변수에 타입이 다른 객체들이 참조되어 하나의 코드가 상황에 따라 다른 결과를 보여주게된다. </p><h2 id="오버라이딩-Overriding"><a href="#오버라이딩-Overriding" class="headerlink" title="오버라이딩(Overriding)"></a>오버라이딩(Overriding)</h2><p>상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello A"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello B"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.hello();</span><br><span class="line"></span><br><span class="line">    A b = <span class="keyword">new</span> B();<span class="comment">//B는 A를 상속받기 때문에 B객체를 A타입의 참조변수가 참조할 수 있다.</span></span><br><span class="line">    <span class="comment">//B b = new B(); // 물론 이 방법도 가능하다.</span></span><br><span class="line">    b.hello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 A클래스를 B클래스가 상속 받으면서 기존의 A클래스에 있는 Hello 메소드를 B클래스에서 재정의 하였다. 메소드명을 바꾼다거나, 매개변수를 바꾼다거나, 반환형을 바꾼다는 개념이 아니다. 메소드 내부 로직을 바꾸는 것을 의미한다. 위의 상속의 개념에서 사용되는 overriding은 상속을 보다 편리하게 해주는 장점이 있다.</p><h2 id="오버로딩-Overloading"><a href="#오버로딩-Overloading" class="headerlink" title="오버로딩(Overloading)"></a>오버로딩(Overloading)</h2><p>한 클래스 내에 동일한 이름의 메소드를 둘 이상 정의한느 것은 허용되지 않는다. 그러나 매개변수의 선언이 다르면 가능하다. 그리고 이것을 메소드 오버로딩이라 한다.</p><p><strong>메소드 오버로딩의 조건</strong></p><ul><li><em>메소드의 이름</em></li><li><em>메소드의 매개변수 정보</em></li></ul><p>실제로 우리가 자주 사용하는 println 메소드를 예로 들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br></pre></td></tr></table></figure><p>우리가 println을 쓰면서 String 값, int 값, double 값 등등의 값을 줄 수 있엇던 이유 역시 오버로딩이 있었기 때문에 가능하다. 만약 오버로딩이라는 것이 없었다면 아마 우리는 다음과 같은 메소드를 사용했을 것이다..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnBoolean</span><span class="params">(<span class="keyword">boolean</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnChar</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnString</span><span class="params">(String x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnDouble</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br></pre></td></tr></table></figure><p>원래 자바 포스트를 작성하기 이전에 다룰려고 했던 객체지향 특징이였다. 하지만 자바 문법에 어느정도 익숙해지고 예제를 이해하면서 넘어가면 더 자연스러울 거라고 생각하고 이 시점에 글을 작성하게 되었다.</p><p><em>이번 포스팅은 글쓴이의 주관적인 생각이 많이 들어가있는 글이기 때문에 틀리거나 추가 설명이 필요하다고 생각되는 부분은 지적해주시면 감사하겠습니다.(오타는 어디에나 존재합니다..)</em></p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/06/4.%20java/JAVA-21-%EC%9E%90%EB%B0%94%20%ED%8A%B9%EC%A7%95%20%EC%A0%95%EB%A6%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 20. 추상 클래스</title>
      <link>http://gojaebeom.github.io/2020/05/05/4.%20java/JAVA-20-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/</link>
      <guid>http://gojaebeom.github.io/2020/05/05/4.%20java/JAVA-20-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/</guid>
      <pubDate>Tue, 05 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;추상-클래스-Abstract-Class&quot;&gt;&lt;a href=&quot;#추상-클래스-Abstract-Class&quot; class=&quot;headerlink&quot; title=&quot;추상 클래스(Abstract Class)&quot;&gt;&lt;/a&gt;추상 클래스(Abstract Class)&lt;/h2&gt;&lt;p&gt;하나 이상의 추상 메소드를 갖는 클래스를 가리켜 추상 클래스라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="추상-클래스-Abstract-Class"><a href="#추상-클래스-Abstract-Class" class="headerlink" title="추상 클래스(Abstract Class)"></a>추상 클래스(Abstract Class)</h2><p>하나 이상의 추상 메소드를 갖는 클래스를 가리켜 추상 클래스라 한다.<a id="more"></a></p><h2 id="추상-클래스의-특징"><a href="#추상-클래스의-특징" class="headerlink" title="추상 클래스의 특징"></a>추상 클래스의 특징</h2><ul><li>선언시 abstract 예약어를 사용한다.</li><li>추상 메서드를 포함하는 클래스이다.</li><li>추상 메서드는 하위 클래스가 구현해야하는 메서드이다.</li><li>추상클래스는 인스턴트화 할 수 없다.</li></ul><h2 id="추상클래스의-선언"><a href="#추상클래스의-선언" class="headerlink" title="추상클래스의 선언"></a>추상클래스의 선언</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>class</code> 키워드 앞에 <code>abstract</code> 키워드를 붙이면 이는 추상 클래스로 사용이 가능하다. </p><h2 id="추상-메소드"><a href="#추상-메소드" class="headerlink" title="추상 메소드"></a>추상 메소드</h2><p>그리고 추상 클래스는 추상 메소드를 다음과 같이 정의할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인터페이스와 같이 메소드의 구현부를 생략하고 <code>세미클론;</code>으로 정의한다. 인터페이스는 <code>abstract</code> 키워드를 생략할 수 있지만, 추상클래스의 추상메서드는 abstract 키워드를 꼭 붙여주어야 한다. </p><h2 id="추상-클래스의-구현-메소드"><a href="#추상-클래스의-구현-메소드" class="headerlink" title="추상 클래스의 구현 메소드"></a>추상 클래스의 구현 메소드</h2><p>추상 클래스는 구현부가 있는 일반 메소드도 정의할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"동물 입니다."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이게 인터페이스와 추상 클래스의 차이점인가 생각할 수 있지만, 자바8 부터 인터페이스에서도 default 메소드로 구현부가 있는 메소드를 정의할 수 있게 되었다. 아직 알아가는 단계에서 본인은 추상 클래스와 인터페이스의 차이가 점점 모호해지고 있음을 느끼고 이런 저런 블로그를 찾아보았다. 의견이 조금식 다른 부분은 인터페이스가 추상클래스의 보완하는 용도이다~ 라는 글도 있지만, 서로의 목적은 명확하게 다르다는 글도 있다.</p><p>물론 이전에 <a href="http://localhost:4000/2020/05/04/java/JAVA-19-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%9E%80" rel="external nofollow noopener noreferrer" target="_blank">인터페이스</a>에대한 글을 포스팅할때에도 인터페이스는 상속이 아닌 구현이라고 하였다. 이 점만 보아도 <code>인터페이스</code>와 <code>추상 클래스</code>의 사용목적은 다르다는 것을 알 수 있다. </p><h2 id="인터페이스와-추상-클래스"><a href="#인터페이스와-추상-클래스" class="headerlink" title="인터페이스와 추상 클래스"></a>인터페이스와 추상 클래스</h2><p>먼저 인터페이스와 추상 클래스의 특징을 서로 비교해보자.</p><p><strong>공통점</strong></p><ul><li>추상 메소드를 사용한다.(선언만하고 구현부가 없다)<ul><li>추상 클래스는 <code>abstract</code> 키워드를 사용하지만, 인터페이스는 생략할 수 있다는 점이 다르다.</li></ul></li><li>일반 메소드의 선언이 가능하다.<ul><li>추상 클래스는 추상 메소드가 아닌 일반 메소드 선언이 가능하다. 인터페이스는 자바8 버전 이후에 default 키워드를 통해 메소드 내부를 구현할 수 있게 되었다.</li></ul></li><li>자기 자신을 인스턴트(객체)화 할 수 없다.</li></ul><p><strong>차이점</strong></p><ul><li>추상 클래스와 다르게 인터페이스에서 일반 변수는 사용할 수 없다.<ul><li>인터페이스에서 사용되는 변수는 상수이다.</li></ul></li><li>추상클래스는 extends로 상속될 수 있고, 인터페이스는 implements 로 구현 되어질 수 있다.</li><li>자바에서 상속은 다중상속이 안된다. 이에 반해 인터페이스를 구현하는 것은 다중 구현이 가능하게 된다.</li></ul><h2 id="템플릿-메소드-Template-Method-패턴"><a href="#템플릿-메소드-Template-Method-패턴" class="headerlink" title="템플릿 메소드(Template Method) 패턴"></a>템플릿 메소드(Template Method) 패턴</h2><p>위의 특징 외에도 추상 클래스가 자주 사용되는 이유중 하나가 <code>템플릿 메소드</code>의 구현이다. 템플릿 메소드는 알고리즘의 프로그램 뼈대를 정의하는 행위 디자인 패턴이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LolChampions</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">champName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">qSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">champInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"챔피언 정보"</span>);</span><br><span class="line">champName();</span><br><span class="line">qSkill();</span><br><span class="line">wSkill();</span><br><span class="line">eSkill();</span><br><span class="line">rSkill();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 추상클래스 <code>LolChampions</code>는 리그오브레전드라는 게임의 캐릭터를 추상화하는 클래스이다. 각 챔피언들의 특징인 이름과 q~r까지의 스킬을 가지고있는것으로 함축하여 만들었다. 끝으로 챔피언에대한 정보를 보여주는 <code>champinfo</code>라는 메소드를 정의하였다. </p><p>위의 추상 메소드들은 구현이 강제가 된다. 그렇기에 우리는 위의 추상 클래스를 상속받아 추상 메소드들을 재정의하여 각 챔프에게 맞는 스킬의 정보를 입력해주면 된다. 하지만 <code>champInfo</code>는 글쓴이가 설계 당시에 만들어놓은 메뉴얼과도 같다. 챔피언의 정보를 보여주되 이름부터 스킬도 q,w,e,r 순으로 순서있게 조회가 되길 원한다. 그러한 이유로 메소드에  <code>final</code> 키워드를 붙여 하위클래스에서 재정의하는것을 막아 놓았다. 이것이 템플릿 메소드 패턴이다. </p><p>인터페이스에선 디폴트 메소드를 통해 몸체를 구현하는 것은 가능하나, <code>final</code> 키워드를 붙여 템플릿메소드를 구현할 수 없다.(정확한 이유는 모른다. 시도해보았으나 구현되지 않았다)</p><p>정리하자면 추상 클래스는 비슷한 기능들을 가진 하위클래스들이 존재한다면 정의할 수 있는 부분을 제외한 나머지 부분은 추상 메소드로 남겨두고 하위클래스들이 상속을 받아 재정의하게 하는 것을 목적으로 하는 것 같다.</p><p>(인터페이스와 추상클래스의 다른점은 찾아볼 수 있었으나, 예제들을 보면 정확히 무엇을 어느시점에 어느 기준으로 나누어야하는지 정말 모호하다.)</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/05/4.%20java/JAVA-20-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 19. 인터페이스</title>
      <link>http://gojaebeom.github.io/2020/05/04/4.%20java/JAVA-19-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</link>
      <guid>http://gojaebeom.github.io/2020/05/04/4.%20java/JAVA-19-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</guid>
      <pubDate>Mon, 04 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;인터페이스란&quot;&gt;&lt;a href=&quot;#인터페이스란&quot; class=&quot;headerlink&quot; title=&quot;인터페이스란?&quot;&gt;&lt;/a&gt;인터페이스란?&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleIF&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위의 예제는 인터페이스 선언의 모습이다. 기본 골격은 클래스와 동일하다. 그러나 class 대신 interface라는 키워드를 사용하고, 내부에 있는 메소드는 몸체 없이 세미콜론으로 마무리 된다. 위와 같이 몸체가 비어있는 메소드를 가리켜 &lt;strong&gt;추상 메소드(Abstract Methods)&lt;/strong&gt; 라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="인터페이스란"><a href="#인터페이스란" class="headerlink" title="인터페이스란?"></a>인터페이스란?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ExampleIF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제는 인터페이스 선언의 모습이다. 기본 골격은 클래스와 동일하다. 그러나 class 대신 interface라는 키워드를 사용하고, 내부에 있는 메소드는 몸체 없이 세미콜론으로 마무리 된다. 위와 같이 몸체가 비어있는 메소드를 가리켜 <strong>추상 메소드(Abstract Methods)</strong> 라 한다. <a id="more"></a></p><p>그리고 인터페이스를 대상으로 인스턴스 생성이 불가능하다. 다른 클래스에 의해 상속이 되어 사용될 뿐이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>클래스가 인터페이스를 상속하는 행위는 <strong>상속</strong> 이 아닌 <strong>구현(Implementation)</strong> 이라 한다. 문법 관계는 상속과 동일하지만 본질은 구현이기 때문이다. 위의 예제에 클래스에서 인터페이스를 상속할때 extends 라는 키워드 대신 implements가 사용되어진 것을 볼 수 있다.</p><h2 id="인터페이스의-특징"><a href="#인터페이스의-특징" class="headerlink" title="인터페이스의 특징"></a>인터페이스의 특징</h2><p>클래스의 인터페이스 구현을 조금 더 구체적으로 보자면 다음과 같은 특징이 있다.</p><ul><li><em>구현할 인터페이스를 명시할 때 키워드 implements를 사용한다.</em></li><li><em>한 클래스는 둘 이상의 인터페이스를 동시에 구현할 수 있다.</em></li><li><em>상속과 구현은 동시에 가능하다.</em></li><li><em>인터페이스의 형(타입)을 대상으로 참조변수의 선언이 가능하다.</em></li><li><em>인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.</em></li></ul><p>implements를 사용하는 것은 위의 예제에서 알 수 있고, 다수의 인터페이스를 상속한다는 것은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF01</span>, <span class="title">ExampleIF02</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>상속과 구현이 동시에 가능하다는 말은 이전까지 상속에 대하여 포스팅하였는데, 하위 클래스가 상위 클래스를 상속하는 행위와 인터페이스를 구현하는 행위를 동시에 할 수 있다는 뜻이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">extends</span> <span class="title">ExampleSuperClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF01</span>, <span class="title">ExampleIF02</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>그 이후의 특징들은 말이 조금 어렵게 느껴질 수도 있다. 먼저 인터페이스의 타입을 대상으로 참조변수의 선언이 가능하다는 말은 상속에서도 비슷한 예제를 다루었는데 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">extends</span> <span class="title">SuperExampleClass</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExampleClass object1 = <span class="keyword">new</span>  ExampleClass();</span><br><span class="line">        SuperExampleClass object2 = <span class="keyword">new</span> ExampleClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 ExampleClass 의 인스턴스를 생성하고 참조변수에 할당하려고한다. 그렇다면 참조변수의 타입은 ExampleClass의 인스턴스(객체) 이기때문에 당연히 ExampleClass가 될 것 이다. 그리고 ExampleClass가 상속한 SuperExampleClass도 ExampleClass의 부모클래스이기때문에 ExampleClass의 참조변수 타입으로써 인스턴스 할당이 가능 한 것이다. (물론 자식 클래스에서 새로 구현된 메소드는 부모클래스 형인 참조변수에서는 사용할 수 없다)</p><p>본론으로 돌아와 인터페이스를 대상으로 참조변수의 선언이 가능하다는것은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> <span class="keyword">implements</span> <span class="title">ExampleIF</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExampleIF obj = <span class="keyword">new</span> ExampleClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 상속클래스의 참조변수 선언 예제와 비슷하다. 구현한 ExampleIF 인터페이스 역시 ExampleClass 클래스의 인스턴트를 할당할 수 있는 참조변수가 된다는 것 이다.</p><p>그렇다면 자연스럽게 ‘인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다’ 라는 것도 단순하게 생각하면 된다. 인터페이스의 구현되지않은 추상메소드 역시 메소드임으로, 이를 상속하는 인터페이스의 메소드를 재정의(오버라이딩)해주어야 한다. 이는 선택사항이 아닌 강제성이 부여된다.</p><h2 id="인터페이스의-본질적-의미"><a href="#인터페이스의-본질적-의미" class="headerlink" title="인터페이스의 본질적 의미"></a>인터페이스의 본질적 의미</h2><p>인터페이스의 사전적 의미는 연결점 또는 접점으로 둘 사이를 연결하는 매개체를 뜻한다. 실제로 자바의 인터페이스는 그런 역할을 한다. 그럼 이와 관련하여 간단한 예를 하나 들겠다.</p><ul><li><em>몬스터의 종류는 다양하다. 몬스터는 이름과 각자의 특성이 있다. 이중 슬라임과 스켈레톤을 몬스터의 한 예로 볼 수 있다.</em></li></ul><p>이렇듯 몬스터와 슬라임, 스켈레톤 등이 연결되는 한 예를 보았다. 그렇다면 이것을 코드로 구현해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//이름</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//특성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slime</span> <span class="keyword">implements</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"슬라임"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"몸이 액체로 되어있음"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skeleton</span> <span class="keyword">implements</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"스켈레톤"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"뼈만 앙상한 언데드 몬스터"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Monster slime = <span class="keyword">new</span> Slime();</span><br><span class="line">slime.name();</span><br><span class="line">slime.characteristic();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Monster skeleton = <span class="keyword">new</span> Skeleton();</span><br><span class="line">skeleton.name();</span><br><span class="line">skeleton.characteristic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 몬스터들이 가지고있는 기본적인 속성들을 인터페이스에 추상메소드를 만들어놓고 각 Slime과 Skeleton 클래스들이 이것을 구현한 예제이다. Slime과 Skeleton은 대부분의 RPG 게임에서 많이 다루는 괴물들이기때문에 Monster라는 접점이 있다.</p><h2 id="인터페이스의-문법-구성"><a href="#인터페이스의-문법-구성" class="headerlink" title="인터페이스의 문법 구성"></a>인터페이스의 문법 구성</h2><p>인터페이스에 존재할 수 있는 메소드에는 추상 메소드, 디폴트 메소드, static 메소드가 있다. 그리고 인터페이스 간 상속도 가능하며 인터페이스의 타입 이름을 대상으로 instance of 연산을 할 수도 있다. 즉 많은 특성이 클래스와 유사하다.</p><p>위의 예제에서 다음같이 인터페이스를 정의하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//추상 메소드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 위 인터페이스에 정의된 추상 메소드에는 다음의 특징이 있다.</p><ul><li><em>인터페이스의 모든 메소드는 public 선언된 것으로 간주합니다.</em></li></ul><p>즉 인터페이스 내에 위치하는 메소드는 별도의 선언이 없어도 public이 된다. 때문에 위의 인터페이스 정의에서 메소드 앞에 public을 붙일 필요가 없다. 그리고 인터페이스에서도 변수를 선언할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> DEFAULT_HP = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> DEFAULT_PAWER = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이렇게 인터페이스 내에 선언되는 변수에는 다음의 특징이 있다. </p><ul><li><em>반드시 선언과 동시에 값으로 초기화를 해야 한다.</em></li><li><em>모든 변수는 public, static, final 이 선언된 것으로 간주한다.</em></li></ul><p>결론적으로 인터페이스 내에 선언된 변수는 상수이다. </p><h2 id="인터페이스-간-상속"><a href="#인터페이스-간-상속" class="headerlink" title="인터페이스 간 상속"></a>인터페이스 간 상속</h2><p>위에 다루었던 몬스터 인터페이스를 통해 구현된 몬스터들이 있다. 하지만 설계를 하던중 보스몬스터급인 녀석들은 차별을 두려고 한다. 하지만 몬스터 인터페이스에 메소드를 만들게 되면 구현하는 클래스에서는 이것이 강제가 되기때문에 모든 몬스터에게 불필요한 보스몬스터의 기능을 담은 메소드를 강제구현시켜야한다. 그렇다고 보스몬스터가 몬스터와 다른것은 아니다. 공통되는 부분도 존재하기 때문이다. 이런 경우 우리는 인터페이스간의 상속을통해서 문제를 해결할 수 있다. 글로만 이해하기 어려우니 예제를 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//이름</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span></span>;<span class="comment">//특성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BossMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BossSkill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BossItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minotaur</span> <span class="keyword">implements</span> <span class="title">BossMonster</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"미노타우르스"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characteristic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"소 머리에 인간의 몸을 한 거대한 몬스터"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보스 몬스터 한정 기술"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보스 몬스터 한정 아이템"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전의 Monster 인터페이스는 수정하지 않고, 새로운 BossMonster 인터페이스를 만들었다. 그리고 이전의 Monster 인터페이스를 상속하여 Monster의 기본적인 기능들은 가져오고 보스몬스터만의 새로운 기능이 추가가 된 것을 알 수 있다. 이것은 이전에 만들었던 슬라임과 스켈레톤의 코드는 수정할 필요없이 앞으로 추가될 보스몬스터만 BossMonster 인터페이스를 구현할 수 있다는 이점이 있다.</p><p>그리고 위의 인터페이스간 상속을 명시할때 extends 키워드를 사용하는데 이에 대한 내용을 정리하자면 다음과 같다.</p><ul><li><em>두 클래스 사이의 상속은 extends로 명시한다.</em></li><li><em>두 인터페이스 사이의 상속도 extneds 로 명시한다.</em></li><li><em>인터페이스와 클래스 사이의 구현만 implements로 명시한다.</em></li></ul><blockquote><p>본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.</p></blockquote>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/04/4.%20java/JAVA-19-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 18. 다형성</title>
      <link>http://gojaebeom.github.io/2020/05/03/4.%20java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/</link>
      <guid>http://gojaebeom.github.io/2020/05/03/4.%20java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/</guid>
      <pubDate>Sun, 03 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;다형성-Polymorphism&quot;&gt;&lt;a href=&quot;#다형성-Polymorphism&quot; class=&quot;headerlink&quot; title=&quot;다형성(Polymorphism)&quot;&gt;&lt;/a&gt;다형성(Polymorphism)&lt;/h2&gt;&lt;p&gt;다형성은 상속과 깊은 관계가 있다. 객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함으로써 다형성을 프로그램적으로 구현하였다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="다형성-Polymorphism"><a href="#다형성-Polymorphism" class="headerlink" title="다형성(Polymorphism)"></a>다형성(Polymorphism)</h2><p>다형성은 상속과 깊은 관계가 있다. 객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함으로써 다형성을 프로그램적으로 구현하였다.<a id="more"></a></p><h2 id="다형성의-장점"><a href="#다형성의-장점" class="headerlink" title="다형성의 장점"></a>다형성의 장점</h2><p>다양한 여러 클래스를 하나의 자료형(상위 클래스)로 선언하거나 형변환 하여 각 클래스가 동일한 메서드를 오버라이딩 한 경우, 하나의 코드가 다양한 구현을 실행할 수 있다.</p><h2 id="다형성-예제"><a href="#다형성-예제" class="headerlink" title="다형성 예제"></a>다형성 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"동물이 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"사람이 두발로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"강아지가 네발로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"독수리가 날개로 움직인다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 <code>Animal</code> 클래스를 각 사람 , 강아지, 독수리 클래스가 상속 받아 <code>move</code> 메소드를 제정의(Overriding)하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphismTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal human = <span class="keyword">new</span> Human();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal eagle = <span class="keyword">new</span> Eagle();<span class="comment">//업캐스팅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Human</code>, <code>Dog</code>, <code>Eagle</code> 클래스는 Animal 클래스를 상속받으므로 위와 같이 Animal 참조변수로 형변환하여 참조할 수 있다. 이를 업캐스팅(Up-casting)이라고 한다.</p><p>만약 위와 같은 상황에서 각 객체의 <code>move</code> 메소드를 한번식 호출하는 코드를 작성하라고 한다면 어떻게 할 수 있을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphismTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal human = <span class="keyword">new</span> Human();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();<span class="comment">//업캐스팅</span></span><br><span class="line">        Animal eagle = <span class="keyword">new</span> Eagle();<span class="comment">//업캐스팅</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Animal&gt; animalList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        animalList.add(human);</span><br><span class="line">        animalList.add(dog);</span><br><span class="line">        animalList.add(eagle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Animal animal : animalList)&#123;</span><br><span class="line">            animal.move();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>human</code>, <code>dog</code>, <code>eagle</code> 은 서로 다른 클래스에서 생성된 객체이다. 하지만 같은 부모클래스형으로 참조되어, 세 객체 모두 <code>ArrayList</code>의 <code>Animal</code> 타입으로 추가될 수 있었다. 이 후 for each 문으로 <code>animal.move()</code> 메소드를 한번 호출한 것으로 세 객체의 move 메소드를 호출하는 것을 볼 수 있다. 이것이 다형성의 장점이다.</p><h2 id="다형성을-사용하지-않은-예제"><a href="#다형성을-사용하지-않은-예제" class="headerlink" title="다형성을 사용하지 않은 예제"></a>다형성을 사용하지 않은 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human human = <span class="keyword">new</span> Human();</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        Eagle eagle = <span class="keyword">new</span> Eagle();</span><br><span class="line"></span><br><span class="line">        human.move();</span><br><span class="line">        dog.move();</span><br><span class="line">        eagle.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 경우 코드의 양으로 보면 더 간단해 보일 수 있다. 하지만 Animal 클래스를 상속받는 다른 클래스가 더 많아진다고 가정해보자. 사람, 개, 독수리 뿐만아니라 동물의 범주에 모두 해당되는 10개체가 넘는 클래스만 정의하면 반복되는 코드량이 더 많아 질 것이다. 프로그램은 코드의 반복적인 작업을 줄이는것이 바람직하다. 이와 같은 관점에서 보면 다형성을 이용하여 작업하는 것이 이후의 코드 관리면에서도 큰 장점을 보인다.</p><h2 id="하위-클래스로-형변환"><a href="#하위-클래스로-형변환" class="headerlink" title="하위 클래스로 형변환"></a>하위 클래스로 형변환</h2><p><a href="http://localhost:4000/2020/05/01/java/JAVA-16.%EC%83%81%EC%86%8D/#more" rel="external nofollow noopener noreferrer" target="_blank">상속</a> 편에서 다루었던 업캐스팅은 묵시적인 형변환이다. 위의 예제에서도 알 수 있듯이 자동적으로 형변환이 된다. 만약 다시 자신의 참조변수에 참조하려고 할 때 우리는 <code>다운캐스팅</code>을 하여야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Human(); <span class="comment">// 업캐스팅</span></span><br><span class="line">Human h = (Human)a; <span class="comment">// 다운캐스팅</span></span><br></pre></td></tr></table></figure><h2 id="다운캐스팅-Down-Casting"><a href="#다운캐스팅-Down-Casting" class="headerlink" title="다운캐스팅(Down Casting)"></a>다운캐스팅(Down Casting)</h2><p>묵시적으로 상위 클래스 형변환된 인스턴스가 원래 자료형(하위클래스)로 변환되어야 할 때 다운캐스팅이라 한다.</p><ul><li>하위클래스로의 형 변환은 명시적으로 되어야 한다.</li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/03/4.%20java/JAVA-18-%EB%8B%A4%ED%98%95%EC%84%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 17. 메소드 오버라이딩</title>
      <link>http://gojaebeom.github.io/2020/05/02/4.%20java/JAVA-17.method%20overriding/</link>
      <guid>http://gojaebeom.github.io/2020/05/02/4.%20java/JAVA-17.method%20overriding/</guid>
      <pubDate>Sat, 02 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;메소드-오버라이딩-Method-Overriding-이란&quot;&gt;&lt;a href=&quot;#메소드-오버라이딩-Method-Overriding-이란&quot; class=&quot;headerlink&quot; title=&quot;메소드 오버라이딩(Method Overriding)이란?&quot;&gt;&lt;/a&gt;메소드 오버라이딩(Method Overriding)이란?&lt;/h2&gt;&lt;p&gt;상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="메소드-오버라이딩-Method-Overriding-이란"><a href="#메소드-오버라이딩-Method-Overriding-이란" class="headerlink" title="메소드 오버라이딩(Method Overriding)이란?"></a>메소드 오버라이딩(Method Overriding)이란?</h2><p>상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 ‘메소드 오버라이딩’ 이라 하는데, 여기서 말하는 오버라이딩은 ‘무효화 시키다’의 뜻으로 해석이 된다. <a id="more"></a></p><p>다음 예제를 통해 메소드 오버라이딩의 결과를 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;<span class="comment">// Cake의 Yummy 메소드를 오버라이딩 함</span></span><br><span class="line">System.out.println(<span class="string">"Yummy Cheese Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeOverriding</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> CheeseCake();</span><br><span class="line"></span><br><span class="line">c1.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">c2.yummy(); <span class="comment">//오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  실행 결과 : Yummy Cheese Cake가 두번 출력 되는 것을 알 수 있다.</p><p>위의 CheeseCake 클래스는 Cake를 상속하면서, Cake에 정의된 yummy메소드와 다음 세 가지가 같은 메소드를 정의하였다.</p><ul><li>메소드의 이름</li><li>메소드의 반환형</li><li>메소드의 매개변수 선언</li></ul><p>위의 세가지가 같아야 메소드 오버라이딩이 성립한다.</p><p>즉 Cake의 yummy 메소드를 CheeseCake의 Yummy 메소드가 오버라이딩 하였다. 그리고 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 오버라이딩된 메소드를 대신하게 된다. </p><p>위의 예제의 main 메소드에서 다음과 같이 Cake 형 참조변수로 CheeseCake 인스턴스를 참조하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> CheeseCake();<span class="comment">//업캐스팅</span></span><br></pre></td></tr></table></figure><p>그리고 다음과 같이 yummy 메소드를 호출하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy();</span><br></pre></td></tr></table></figure><p>앞서 설명한 바에 의하면 c1은 Cake형 참조변수이니, 위 문장의 경우 Cake의 yummy 메소드가 호출되어야 한다. CheeseCake 인스턴스를 참조하고 있는 상황이라도 말이다. 그러나 Cake의 yummy 메소드는 오버라이딩 되었다(무효화 되었다). 따라서 이 경우에는 CheeseCake의 yummy 메소드가 대신 호출이 된다.</p><h2 id="메소드-오버라이딩의-일반화"><a href="#메소드-오버라이딩의-일반화" class="headerlink" title="메소드 오버라이딩의 일반화"></a>메소드 오버라이딩의 일반화</h2><p>앞서 설명한 메소드 오버라이딩을 문법적으로 정리하기 위해서 클래스를 다음과 같이 정의하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 클래스를 정의한 경우 CheeseCake의 참조변수와 인스턴스의 생성문을 다음과 같이 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cake c1 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">CheeseCake c2 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br><span class="line">StrawberryCheeseCake c3 = <span class="keyword">new</span> StrawberryCheeseCake();</span><br></pre></td></tr></table></figure><p>그리고 다음 세 문장이 실행되었을 때 호출되는 메소드는 StrawberryCheeseCake의 yummy 메소드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c2.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br><span class="line">c3.yummy(); <span class="comment">//StrawberryCheeseCake의 yummy 메소드 호출</span></span><br></pre></td></tr></table></figure><h2 id="오버라이딩된-메소드를-호출하는-방법"><a href="#오버라이딩된-메소드를-호출하는-방법" class="headerlink" title="오버라이딩된 메소드를 호출하는 방법"></a>오버라이딩된 메소드를 호출하는 방법</h2><p>위의 예제들에서도 알 수 있듯이 Cake, CheeseCake에 정의된 yummy 메소드들을 위의 방법처럼 호출하는 것은 불가능하다.</p><p>하지만 클래스 외부가 아닌 내부에서 Cake의 yummy 메소드를 호출하는 방법은 있다. 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch11_상속;</span><br><span class="line"><span class="comment">//오버라이딩 된 메소드를 호출하는 방법 예제</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Yummy Cake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.yummy();</span><br><span class="line">System.out.println(<span class="string">"Yummy CheeseCake"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyCakeSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CheeseCake cake = <span class="keyword">new</span> CheeseCake();</span><br><span class="line">cake.yummy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 상위 클래스의 생성자를 호출할 목적으로 키워드 super를 사용하였다. 그런데 위의 예제에서 보이듯이 상위 클래스에 정의된, 오버라이딩 된 메소드의 호출을 목적으로도 super가 사용될 수 있다.</p><h2 id="Object-클래스"><a href="#Object-클래스" class="headerlink" title="Object 클래스"></a>Object 클래스</h2><p>클래스를 정의할 때 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>두 클래스의 정의는 동일하다.</p><p>물론 위의 설명에도 언급했듯이 상속하는 클래스가 있는 경우에는 Object 클래스를 상속하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>그러나 이 경우에도 OtherClass 또는 OtherClass가 상속하는 클래스가 Object 클래스를 상속한다. 결국 자바의 모든 클래스는 Object 클래스를 직접 혹은 간접적으로 상속하게 되어있다. 그렇다면 자바의 모든 클래스는 Object 클래스를 상속하도록 한 이유는 무엇일까?</p><p>이는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다. 한 예로 자바의 모든 인스턴스는 다음 메소드의 인자로 전달될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> <span class="comment">// System.out.println 메소드</span></span></span><br></pre></td></tr></table></figure><p>위 메소드의 매개변수 형이 Object이다. 따라서 자바의 모든 인스턴스는 위 메소드의 인자가 될 수 있다. 그리고 위의 메소드는 인자로 전달된 인스턴스의 다음 메소드를 호출한다. 이 메소드는 Object 클래스에 정의되어 있는 메소드이므로 모든 인스턴스를 대상으로 호출이 가능하다.</p><p>이 블로그엔 포스팅하지 않았지만 글쓴이의 github 에 <a href="https://github.com/gojaebeom/java_tutorial" rel="external nofollow noopener noreferrer" target="_blank">String 클래스 예제</a>에 대해 다루었다.(목차에서 String 클래스 부분의 글들을 찾아보면 된다) </p><p>이 예제에서 클래스를 정의하면서 toString 메소드를 정의한 바 있다. 그런데 사실 이것은 Object 클래스의 toString 메소드를 오버라이딩 한 것 이다. 이와 관련해서 다음 예제를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//오브젝트 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">super</span>.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"My Bread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreamBread</span> <span class="keyword">extends</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bread 클래스의 toString 메소드를 오버라이딩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"my CreamBread"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridingToString</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bread b1 = <span class="keyword">new</span> Bread();</span><br><span class="line">Bread b2 = <span class="keyword">new</span> CreamBread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//b1이 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2가 참조하는 인스턴스의 toString 메소드 호출로 이어짐</span></span><br><span class="line">System.out.println(b2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="클래스와-메소드의-final-선언"><a href="#클래스와-메소드의-final-선언" class="headerlink" title="클래스와 메소드의 final 선언"></a>클래스와 메소드의 final 선언</h2><p>클래스를 정의하는데 있어서 해당 클래스를 다른 클래스가 상속하는 것을 원치 않는다면, 다음과 같이 final 선언을 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;...&#125; <span class="comment">//MyClass 는 다른 클래스가 상속 할 수 없음</span></span><br></pre></td></tr></table></figure><p>대표적인 final 클래스로 String 클래스가 있다. 따라서 우리는 String 클래스를 상속할 수 없다. 또한 다음과 같이 메소드의 정의에 final 선언을 추가하여 해당 메소드의 오버라이딩을 허용하지 않을 수 도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>자바 5에서 ‘어노테이션(Annotations)’이라는 것이 소개되었다. 그리고 이와 관련하여 이후에 별도로 설명을 하겠다. 그러나 상속, 정확히는 메소드 오버라이딩과 관련 있는 내용이 있어 이에 대한 부분만 먼저 소개하고자 한다. 다음 예제를 보자. 이 예제는 컴파일도 되고 실행도 잘 된다. 그러나 프로그래머의 실수가 일부 포함되어 있다. 그 실수가 무엇인지찾아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideMistake</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ParentAdder adder = <span class="keyword">new</span> ChildAdder();</span><br><span class="line">System.out.println(adder.add(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 ChildAdder 는 ParentAdder를 상속한다. 그리고 ParentAdder의 add를 오버라이딩 할 의도였음을 주석을 통해 알 수 있다. 그러나 부모 메소드와 매개변수 타입과 반환형이 달랐기 때문이다. 이러한 유형의 실수는 매우 흔하다. 그럼에도 불구하고 발견이 쉽지 않기 때문에 치명적인 실수가 될 수 있다. 제일 좋은 것은 컴파일 과정에서 실수가 확인되는 것이다. 그러나 이 경우 문법적으로는 오류가 없기 때문에 컴파일도 되고 실행도 된다.</p><p>이러한 상황을 방지하기 위해서 ‘어노테이션’ 이라는 것을 사용할 수 있다. 어노테이션은 일종의 메모이다. 그것도 ‘자바 컴파일러에게 메시지를 전달하는 목적의 메모’이다. ChildAdder 클래스를 설계하는 과정에서 add 메소드가 ParentAdder의 add 메소드를 오버라이딩 할 의도였다면 다음과 같이 메모를 달아준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildAdder</span> <span class="keyword">extends</span> <span class="title">ParentAdder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상위 클래스의 add를 오버라이딩 하려고 합니다.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 어노테이션을 정의하면 컴파일러는 오버라이딩이 제대로 되었는지 확인을 하고, 프로그래머의 의도대로 오버라이딩이 되지 않았다면 컴파일 단계에서 에러를 전달해준다.</p><p>메소드를 오버라이딩 해야 한다면, 이렇듯 어노테이션을 사용하여 컴파일 과정에서 확인되지 않는 오류의 발생을 차단하는 것이 좋다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/02/4.%20java/JAVA-17.method%20overriding/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 16. 상속</title>
      <link>http://gojaebeom.github.io/2020/05/01/4.%20java/JAVA-16.%EC%83%81%EC%86%8D/</link>
      <guid>http://gojaebeom.github.io/2020/05/01/4.%20java/JAVA-16.%EC%83%81%EC%86%8D/</guid>
      <pubDate>Fri, 01 May 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;상속의-기본문법-이해&quot;&gt;&lt;a href=&quot;#상속의-기본문법-이해&quot; class=&quot;headerlink&quot; title=&quot;상속의 기본문법 이해&quot;&gt;&lt;/a&gt;상속의 기본문법 이해&lt;/h2&gt;&lt;p&gt;상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상속에 대한 문법적인 이해가 선행되어야 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="상속의-기본문법-이해"><a href="#상속의-기본문법-이해" class="headerlink" title="상속의 기본문법 이해"></a>상속의 기본문법 이해</h2><p>상속의 적절한 활용 방법은 한두 문자응로 가볍게 설명할 수 있는 내용이 아니다. 그리고 이에 대한 설명을 듣기에 앞서 상속에 대한 문법적인 이해가 선행되어야 한다. <a id="more"></a></p><h2 id="상속이란"><a href="#상속이란" class="headerlink" title="상속이란?"></a>상속이란?</h2><p>상속의 이유와 목적을 물어보면 </p><ul><li>상속은 코드의 재활용를 위한 문법입니다.</li></ul><p>그러나 이는 정확한 표현은 아니다.</p><ul><li>연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다.</li></ul><p>위의 답변은 매우 모범적인 답변이다.</p><h3 id="상속의-가장-기본적인-특성"><a href="#상속의-가장-기본적인-특성" class="headerlink" title="상속의 가장 기본적인 특성"></a>상속의 가장 기본적인 특성</h3><p>상속을 단순하게 설명하면 , 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것이 상속이다. 예를 들어서 다음의 클래스가 정의되어 있다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">Animal(String name)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"이 동물의 이름은 "</span>+name+<span class="string">"입니다."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 위의 클래스를 상속하여 다음과 같이 새로운 클래스를 정의 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">String cry;</span><br><span class="line"></span><br><span class="line">Cat(String name , String cry)&#123;</span><br><span class="line"><span class="keyword">super</span>(name);<span class="comment">//부모의 String타입의 매개변수를 받는 생성자 호출(super는 이후에 배우게 된다.)</span></span><br><span class="line"><span class="keyword">this</span>.cry = cry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name();<span class="comment">//Animal 클래스를 상속했기 때문에 호출 가능</span></span><br><span class="line">System.out.println(<span class="string">"울음소리는 "</span>+cry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제를 보면 새로운 super 키워드가 등장한 것을 알 수 있다. 이건 나중에 더 자세히 다루어보겠다.</p><h2 id="클래스-변수와-클래스-메소드의-상속이-가능한가"><a href="#클래스-변수와-클래스-메소드의-상속이-가능한가" class="headerlink" title="클래스 변수와 클래스 메소드의 상속이 가능한가?"></a>클래스 변수와 클래스 메소드의 상속이 가능한가?</h2><p>static 선언이 붙는 클래스 변수와 클래스 메소드도 상속의 대상에 포함이 되겠는가?</p><p>static 선언이 갖는 의미를 떠올리고 논리적으로 접근을 하면 이 질문에 스스로 답을 할 수 있다.</p><p>앞서 공부한 클래스 변수와 클래스 메소드의 특징을 정리하면 다음과 같다. </p><ul><li>인스턴스의 생성과 상관없이 접근이 가능하다.</li><li>클래스 내부와 외부에서 접근이 가능하다.</li><li>클래스 변수와 클래스 메소드가 위치한 클래스 내에서는 직접 접근이 가능하다.</li></ul><p>즉 클래스 변수와 클래스 메소드는 인스턴스에 속하지 않는, 딱 하나만 존재하는 변수와 메소드이다. <strong>따라서 상속의 대상이 아니다.</strong></p><p>그렇다면 다음 내용에 대해서는 생각을 해볼 필요가 있다. </p><ul><li>상위 클래스에 위치한 클래스 변수와 메소드에 하위 클래스에서 어떻게 접근하는가?</li></ul><p>결론을 말하자면 변수의 이름만으로 접근이 가능하다. 단 접근 수준 지시자가 접근을 허용해야 접근이 가능하다. 다음 예제를 통해 알아보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperClass sc1 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line">SuperClass sc2 = <span class="keyword">new</span> SuperClass(); <span class="comment">// 값 1 증가</span></span><br><span class="line"></span><br><span class="line">SubClass sub1 = <span class="keyword">new</span> SubClass();<span class="comment">//인스턴스 생성 과정에서 부모생성자가 호출 되므로 count 값 1 증가</span></span><br><span class="line">sub1.showCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//protected는 하위 클래스 접근을 허용</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서 변수 count의 접근 수준 지시자를 private으로 선언하면 이로 인해 컴파일 오류가 발생하는 것도 확인하기 바란다.</p><h2 id="IS-A"><a href="#IS-A" class="headerlink" title="IS - A"></a>IS - A</h2><p>두 클래스를 상속의 관계로 맺는 것이 도움이 되는 상황이 있고 도움이 되지 않는 상황이 있다. 그렇다면 언제 두 클래스를 상속의 관계로 맺어야 할까? </p><p>기본적으로 IS-A 관계라는 것이 성립해야 상속의 후보로 고려할 수 있다.</p><p>상속이 갖는 문법적 특성을 통해서 상위 클래스와 하위 클래스를 다음과 같이 이야기할 수 있다.</p><ul><li>하위 클래스는 상위 클래스의 모든 특성을 지닌다. </li><li>거기에 더하여 하위 클래스는 자신만의 추가적인 특성을 더하게 된다.</li></ul><p>이러한 상속의 특성을 현실 세계에서도 찾아볼 수 있다. 대표적인 예가 다음과 같다.</p><ul><li>모바일폰 vs 스마트폰</li></ul><p>모바일폰이 상위 클래스라면 스마트폰은 하위 클래스이다. 즉 이 둘을 객체지향의 관점에서 보면 다음과 같이 이야기할 수 있다. </p><ul><li>모바일폰을 스마트폰이 상속한다.</li></ul><p>스마트폰은 모바일폰이 갖는 특성을 모두 갖는다. 게다가 스마트폰은 앱의 설치 및 실행 등 컴퓨터의 특성을 추가적으로 갖고 있다. 따라서 클래스를 설계한다면 다음과 같은 설계가 논리적으로 타당하다.</p><ul><li>class 스마트폰 extends 모바일폰 {…}</li></ul><p>그런데 우리는 스마트폰도 모바일폰의 한 종류라 말한다. 즉 컴퓨터의 기능이 추가된 모바일폰이 스마트 폰인 것이다. 따라서 다음과 같이 이야기할 수 있다. </p><ul><li>스마트폰도 모바일폰이다.</li><li>스마트폰은 일종의 모바일폰이다.</li></ul><p>그리고 위의 문장들이 나타나는 관계를 가리켜 IS-A 관계라 하고, 이것이 상속의 관계를 맺기 위한 두 클래스의 기본 조건이 된다. 참고로 is a는 ~은 ~ 이다. 로해석 된다. 예를 들면 다음과 같다.</p><ul><li>Life is a journey - 인생은 여행이다. </li></ul><p>지금까지 설명한 내용을 정리하면 다음과 같다.</p><h3 id="IS-A-관계-총-정리"><a href="#IS-A-관계-총-정리" class="headerlink" title="IS-A 관계 총 정리"></a>IS-A 관계 총 정리</h3><ul><li>IS - A 관계는 ~은 ~이다. 로 표현되는 관계이다. </li><li>상속이 갖는 문법적 특성은 IS - A 관계의 표현에 적합하다.</li><li>따라서 상속 관계를 형성하기 위한 두 클래스는 IS -A 관계에 있어야 한다.</li></ul><h3 id="IS-A-관계-예제"><a href="#IS-A-관계-예제" class="headerlink" title="IS-A 관계 예제"></a>IS-A 관계 예제</h3><p>관련된 예제를 github에 올려두었다.</p><ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch11_%EC%83%81%EC%86%8D/IS_A_%EC%98%88%EC%A0%9C.java" rel="external nofollow noopener noreferrer" target="_blank">IS - A 예제</a></li></ul><h2 id="상위-클래스의-참조변수가-참조할-수-있는-대상의-범위"><a href="#상위-클래스의-참조변수가-참조할-수-있는-대상의-범위" class="headerlink" title="상위 클래스의 참조변수가 참조할 수 있는 대상의 범위"></a>상위 클래스의 참조변수가 참조할 수 있는 대상의 범위</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>따라서 다음과 같이 문장을 구성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그런데 다음과 같이 MobilePhone형 참조변수가 SmartPhone 인스턴스를 참조하게 할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>이렇듯 상위 클래스의 참조변수는 하위 클래스의 인스턴스를 참조할 수 있는데, 이 부분을 다음과 같이 이해하자.</p><ul><li>모바일폰을 상속하는 스마트폰도 일종의 모바일폰이다.<ul><li>Mobilephone을 상속하는 SmartPhone 인스턴스는 MobilePhone 인스턴스이기도 하다.</li></ul></li><li>따라서 MobilePhone형 참조변수는 SmartPhone 인스턴스를 참조할 수 있다.</li></ul><p>다음과 같이 상속 관계가 형성이 되면,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sartphone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>다음 인스턴스는 Smartphone 인스턴스인 동시에 MobilePhone 인스턴스가 된다.<br><br>(이는 스마트폰을 가리키며 모바일폰이다. 라고 말할 수 있는 것과 이치가 같다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SmartPhone(<span class="string">"010-555-666"</span>,<span class="string">"Nougat"</span>);</span><br><span class="line"><span class="comment">//스마트폰 인스턴스이면서 동시에 모바일폰 인스턴스</span></span><br></pre></td></tr></table></figure><br><p>따라서 위에 말한것처럼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><p>SmartPhone 인스턴스를 참조하는 변수를 선언하는 두 가지 방법이 가능하다.</p><h3 id="지금까지-설명한-것을-예제를-통해-알아보자"><a href="#지금까지-설명한-것을-예제를-통해-알아보자" class="headerlink" title="지금까지 설명한 것을 예제를 통해 알아보자"></a><em>지금까지 설명한 것을 예제를 통해 알아보자</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Overriding_Exam01.class </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String number;<span class="comment">// 전화번호</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MobilePhone</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number  = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hi ~ from "</span> + number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//모바일폰을 상속받는 하위클래스 스마트폰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">MobilePhone</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String androidVer;<span class="comment">// 안드로이드 운영체제 네임(버전)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmartPhone</span><span class="params">(String number, String ver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(number);</span><br><span class="line"><span class="keyword">this</span>.androidVer = ver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"App is running in "</span> + androidVer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SmartPhone ph1 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-111-222"</span>, <span class="string">"Andro01"</span>);</span><br><span class="line">MobilePhone ph2 = <span class="keyword">new</span> SmartPhone(<span class="string">"010-444-333"</span>, <span class="string">"Andro02"</span>);</span><br><span class="line"></span><br><span class="line">ph1.answers();</span><br><span class="line">ph1.playApp();</span><br><span class="line"></span><br><span class="line">ph2.answers();</span><br><span class="line"><span class="comment">//ph2.playApp();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서는 다음과 같이 인스턴스를 생성하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobilePhone phone = <span class="keyword">new</span> SmartPhone(<span class="string">"010-555-777"</span>, <span class="string">"Nougat"</span>);</span><br></pre></td></tr></table></figure><br><p>그리고 다음과 같이 mobilePhone 클래스에 정의된 메소드를 호출하는데 이는 당연히 가능한 일이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br></pre></td></tr></table></figure><br><p>그러나 다음과 같이 SmartPhone 클래스에 정의된 메소드의 호출은 불가능하다. 참조변수 ph2가 실제 참조 하는 인스턴스가 SmartPhone 인스턴스이지만 불가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph2.playApp(); <span class="comment">// 스마트폰 클래스에서 정의한 메소드</span></span><br></pre></td></tr></table></figure><br><p>참조변수 ph2는 MobilePhone형 참조변수이다. 이러한 경우 ph2를 통해서 접근이 가능한 멤버는 MobilePhone 클래스에 정의되었거나 이 클래스가 상속하는 클래스의 멤버로 제한된다.(ph2가 참조하는 인스턴스가 무엇인지는 상관이 없다)</p><p>지금 설명한 이 내용이 비합리적이라고 생각할 수 있다. 참조변수의 형에 상관없이, 참조하는 인스턴스에 따라서 접근가능한 멤버가 결정되어야 한다고 생각할 수 있다. 그러나 그렇게 설계하지 않은 이유가 두 가지 있는데 그중 하나는 다음과 같다.</p><ul><li><em>실행 시간을 늦추는 결과로 이어질 수 있습니다</em></li></ul><p>자바는 메소드 호출 시 참조변수의 형을 참조 하여 그 메소드 호출이 옳은 것인지 판단한다.예를 들면 다음과 같다.(다음과 같이 컴파일러가 판단하고 컴파일을 한다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ph2.answer();</span><br><span class="line"><span class="comment">//ph2가 MobilePhone형이므로 MobilePhone 클래스의 메소드 answer은 호출가능하다.</span></span><br></pre></td></tr></table></figure><br><p>이러한 형태의 판단은 그 속도가 빠르다.(컴파일 단계에서 쉽게 판단 가능하다) 그러나 실제 참조하는 인스턴스를 대상으로 메소드의 호출 가능성을 판단하는 일은 간단하지 않다. 참조하는 인스턴스의 종류는 코드의 흐름에 따라 얼마든지 달라질 수 있기 때문이다.</p><p>그런데 이러한 단점도 감수할 만한 가치가 있다면 감수했을 것이다. 그러나 이어서 언급하는 두 번째 이유는 이러한 단점을 감수할 필요가 없다는 결론을 내리게 한다. </p><ul><li><em>참조변수의 타입을 기준으로 접근 가능한 멤버를 제한하는 것은 코드를 단순하게 한다.</em></li></ul><p>단점이 많은 일부 기능을 제한함으로써 단순하고 명료한 코드의 작성을 유도하는 언어가 좋은 언어이다. 그런 측면에서 참조변수의 타입을 기준으로 접근 가능한 멤버를 제한한 것은 의미가 있는 일이다.<br><br></p><h2 id="업캐스팅-Up-Casting"><a href="#업캐스팅-Up-Casting" class="headerlink" title="업캐스팅(Up Casting)"></a>업캐스팅(Up Casting)</h2><p>업캐스팅이란 서브 클래스의 객체가 수퍼 클래스 타입으로 형변환되는 것을 말한다.</p><p>다음과 같이 상속 관계를 맺은 세 클래스가 존재한다고 가정하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sweet</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">milky</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawberryCheeseCake</span> <span class="keyword">extends</span> <span class="title">CheeseCake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sour</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이때 StrawberryCheeseCake 인스턴스는 다음과 같이 말할 수 있다.- _StrawberryCheeseCake 인스턴스는 CheeseCake 인스턴스이면서 Cake 인스턴스 이다._<p>따라서 다음과 같이 인스턴스를 참조할 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cake cake1 = <span class="keyword">new</span> StrawberryCheeseCake();<span class="comment">//업캐스팅</span></span><br><span class="line">CheeseCake cake2 = <span class="keyword">new</span> StrawberryCheeseCake();<span class="comment">//업캐스팅</span></span><br></pre></td></tr></table></figure><br>그러나 Cake형 참조변수 cake1을 통해서 호출할 수 있는 메소드는 다음 한 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cake1.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>그리고 CheeseCake형 참조변수 cake2를 통해서 호출할 수 있는 메소드는 다음 두 가지이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cake2.sweet();</span><br><span class="line"><span class="comment">//Cake에 정의된 메소드 호출</span></span><br><span class="line">cake2.milky();</span><br><span class="line"><span class="comment">//CheeseCake에 정의된 메소드 호출</span></span><br></pre></td></tr></table></figure><br>이렇듯 참조변수가 참조하는 인스턴스의 종류에 상관없이, 참조변수의 타입에 해당하는 클래스와 그 클래스가 상속하는 상위 클래스에 정의된 메소드들만 호출이 가능하다.]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/05/01/4.%20java/JAVA-16.%EC%83%81%EC%86%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 15. ArrayList</title>
      <link>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-15-AarrayList/</link>
      <guid>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-15-AarrayList/</guid>
      <pubDate>Thu, 30 Apr 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;p&gt;ArrayList는 순차적인 여러 값들을 저장하기 위해 자바에서 기본적으로 제공하는 자료구조중 하나이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList는 순차적인 여러 값들을 저장하기 위해 자바에서 기본적으로 제공하는 자료구조중 하나이다. <a id="more"></a></p><p>이전에 배웠던 배열의 특징과 비교하자면, 배열은 ArrayList에 비해 속도는 빠르지만 선언시에 크기를 정하고 한번 정한 값을 바꿀 수 없다. 즉 할당한 크기보다 값이 적게 들어가면 그만큼 공간을 낭비하는 것이고, 할당한 크기 이상의 값을 저장할 수 없기때문에 이러한 부분도 불편한점이 아닐 수 없다. </p><p>반면 ArrayList는 속도는 배열에 비해 느리지만 값을 추가하거나 삭제함에 따라 그 크기를 유동적으로 변화시키는 장점이 있다. 이제 ArrayList를 사용하는 방법에 대하여 알아보자.</p><h2 id="ArrayList-사용법"><a href="#ArrayList-사용법" class="headerlink" title="ArrayList 사용법"></a>ArrayList 사용법</h2><h3 id="선언-방법"><a href="#선언-방법" class="headerlink" title="선언 방법"></a>선언 방법</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>기본적인 선언 방법은 위와 같다.(ArrayList는 java.util.ArrayList에 포함되어 있으므로 사용시 import 가 필요하다)</p><p>만약 VScode나 이클립스와 같은 코드 에디터를 사용하고 있다면 ArrayList에 경고줄이 떠있는 것을 볼 수 있다. ArrayList는 사용시 어떠한 데이터 타입을 넣을 것 인가 선언 시에 지정할 수 있는데, 이것은 이후에 배울 제네릭때 더 자세히 알아보자. 지금은 그냥 아래 예제와 같이 선언 한다는 것만 알아두자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;(); <span class="comment">//&lt;&gt; 사이에 사용할 유형의 타입을 적는다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ex </span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 문자열 타입만 넣을 경우</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 정수형 타입만 넣을 경우</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Subject&gt; list = <span class="keyword">new</span> ArrayList&lt;Subject&gt;(); <span class="comment">// 특정 클래스형으로 사용할 경우</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 데이터 추가</span><br><span class="line">```java</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">list.add(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><h3 id="추가한-데이터-조회"><a href="#추가한-데이터-조회" class="headerlink" title="추가한 데이터 조회"></a>추가한 데이터 조회</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">  System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-사용-예제"><a href="#ArrayList-사용-예제" class="headerlink" title="ArrayList 사용 예제"></a>ArrayList 사용 예제</h2><p>이전의 학생과 과목 클래스를 정의를 하고 학생클래스에서 과목클래스를 사용한 적이 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Subject형 참조변수</span></span><br><span class="line">    Subject eng;</span><br><span class="line">    Subject math;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> id, String name)&#123;</span><br><span class="line">        studentId = id;</span><br><span class="line">        studentName = name;</span><br><span class="line">        Subject eng = <span class="keyword">new</span> Subject();</span><br><span class="line">        Subject math = <span class="keyword">new</span> Subject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        eng.subjectId = id;</span><br><span class="line">        eng.subjectName = name;</span><br><span class="line">        eng.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMathSubject</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        math.subjectId = id;</span><br><span class="line">        math.subjectName = name;</span><br><span class="line">        math.subjectScore = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>과목을 별도의 클래스로 나눈것 까지는 좋았지만 과목명을 직접 정의하여 나열하고있는 것은 좋은 코드가 아닐 것 이다. 과목 수가 많아짐에 따라 서로 중복되는 코드를 가지는 메소드들을 계속 생성해야 할 것 이다.</p><p>위와 같은 단점을 ArrayList를 사용하는 것으로 리팩토링해보자.</p><p><strong>Subject 클래스의 정의</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">//과목 이름</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> score;<span class="comment">//과목 점수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Student 클래스의 정의</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> serialNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//학생 번호</span></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//학생 이름</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Subject&gt; subjectList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.id = ++serialNum;</span><br><span class="line">subjectList = <span class="keyword">new</span> ArrayList&lt;Subject&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubject</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">subject.setName(name);</span><br><span class="line">subject.setScore(score);</span><br><span class="line">subjectList.add(subject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStudentInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"학생 번호: "</span>+ id);</span><br><span class="line">System.out.println(<span class="string">"학생 이름: "</span>+ name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(subjectList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"수강중인 과목이 없습니다."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Subject subject : subjectList) &#123;</span><br><span class="line">total += subject.getScore();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"수강 과목 "</span>+subject.getName() + <span class="string">": "</span>+ subject.getScore());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"과목 총합점수는 "</span> + total +<span class="string">" 이고 평균은 "</span> + total/subjectList.size() + <span class="string">" 입니다."</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스의 맴버변수 <code>private ArrayList&lt;Subject&gt; subjectList;</code> 를 선언, 그리고 생성자에서 초기화 시킨다. 예제와 같이 ArrayList는 Subject 클래스를 타입으로 받고 있다. </p><p>그리고 <code>addSubject</code> 메소드가 호출될때마다 subject 객체를 새로 생성해 매개변수로 받은  과목이름과 과목점수를 저장시킨다. 이후에 subject 타입의 subjectList에 추가시킨다.</p><p><code>showStudentInfo</code> 메소드는 기본적인 학생정보를 출력하고, subjectList에 값이 저장되지 않았다면 안내 문구를 출력하고 subjectList에 값이 존재하면 출력해주는 기능을 담당한다.</p><p><strong>StudentTest 클래스에서 테스트해보기</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student studentLee = <span class="keyword">new</span> Student(<span class="string">"Lee"</span>);</span><br><span class="line">studentLee.addSubject(<span class="string">"수학"</span>, <span class="number">80</span>);</span><br><span class="line">studentLee.addSubject(<span class="string">"영어"</span>, <span class="number">70</span>);</span><br><span class="line">studentLee.showStudentInfo();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">Student studentGo = <span class="keyword">new</span> Student(<span class="string">"Go"</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"수학"</span>, <span class="number">50</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"영어"</span>, <span class="number">90</span>);</span><br><span class="line">studentGo.addSubject(<span class="string">"과학"</span>, <span class="number">90</span>);</span><br><span class="line">studentGo.showStudentInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전의 ArrayList를 사용하지 않을때와의 차이점은 addSubject라는 메소드를 사용하여 과목을 필요한만큼 정의하여 추가하고 있다는 점이다. 이전의 코드에서 수학, 영어등의 과목명을 직접 정의하여 중복되는 코드를 계속사용하는 것을 수정하여 좀더 프로그램다운 코드가 되었다.</p><p>ArrayList는 이후의 컬랙션에서 한번더 다룰 예정이다.</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-15-AarrayList/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 14. 배열</title>
      <link>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-14-%EB%B0%B0%EC%97%B4/</link>
      <guid>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-14-%EB%B0%B0%EC%97%B4/</guid>
      <pubDate>Thu, 30 Apr 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배열이란&quot;&gt;&lt;a href=&quot;#배열이란&quot; class=&quot;headerlink&quot; title=&quot;배열이란?&quot;&gt;&lt;/a&gt;배열이란?&lt;/h2&gt;&lt;p&gt;배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란?"></a>배열이란?</h2><p>배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다. <a id="more"></a></p><h3 id="1차원-배열"><a href="#1차원-배열" class="headerlink" title="1차원 배열"></a>1차원 배열</h3><p>1차원 배열은 다음과 같이 정의할 수 있다.</p><ul><li>타입이 같은 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간</li></ul><p>그런데 자바는 배열도 인스턴스로 처리한다. 즉 자바에서는 배열도 인스턴스 이다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//길이가 5인 int형 1차원 배열의 생성문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위 문장에서 등호를 기준으로 왼편, 오른편에 위치한 것은 각각 참조변수의 선언과 배열의 생성이다. </p><p>물론 다음과 같이 참조변수의 선언과 배열 인스턴스의 생성을 구분할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ref;</span><br><span class="line">    ref = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//물론 int형 말고도 다양한 자료형으로 배열을 생성할 수 있다.</span></span><br><span class="line">    <span class="keyword">double</span>[] db = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>];</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//각 배열에 대한 길이 </span></span><br><span class="line">    System.out.println(db.length);</span><br><span class="line">    System.out.println(f.length);</span><br><span class="line">    System.out.println(str.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 보면 각 배열의 인스턴스 변수 length에 접근하여 배열의 길이 정보를 출력하였다. 이렇듯 인스턴스 변수에 접근이 가능하다는 것은 배열이 인스턴스임을 보인는 결과이기도 하다.</p><h2 id="배열-저장과-참조"><a href="#배열-저장과-참조" class="headerlink" title="배열 저장과 참조"></a>배열 저장과 참조</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>위 선언된 배열 arr에 첫 번째 공간에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><br><p>이렇듯 배열 요소의 위치를 지정하는 인덱스 값은 0에서부터 시작한다. 따라서 배열 arr의 두번째 , 새 번째 요소에 값을 저장하는 방법은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">//2번째</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">//3번째</span></span><br></pre></td></tr></table></figure><br><p>배열에 저장된 값을 참조하는 방법도 이와 유사하다. 다음은 배열 arr의 모든 요소에 저장된 값을 더하는 방법을 보여준다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = arr[<span class="number">0</span>] + arr[<span class="number">1</span>] + arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><br><h2 id="배열의-생성과-초기화"><a href="#배열의-생성과-초기화" class="headerlink" title="배열의 생성과 초기화"></a>배열의 생성과 초기화</h2><p>배열도 변수와 마찬가지로 생성과 동시에 초기화가 가능하다. 기본적인 배열의 생성 방식은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><p>이 배열을 생성과 동시에 초기화하려면 초기화할 값들을 다음과 같이 중괄호를 이용해서 나열하면 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int[] arr2 = new int[3] &#123;1, 2, 3&#125;; //컴파일 오류 발생</span></span><br></pre></td></tr></table></figure><br><p>그런데 위의 문장에서는 초기화할 값들의 수를 통해 배열의 길이 정보를 계산할 수 있으므로, 이경우 배열의 길이 정보를 생략하도록 약속하였다. 즉 위의 문장은 다음과 같이 수정해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><p>위의 문장을 통해 생성되는 배열의 길이는 3이다. 그리고 위의 문장은 다음과 같이 줄여서 표현할 수 도있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><br><h3 id="배열의-선언-두가지-방법"><a href="#배열의-선언-두가지-방법" class="headerlink" title="배열의 선언 두가지 방법"></a>배열의 선언 두가지 방법</h3><p>다음과 같이 배열을 생성하는 문장에서도 이 둘은 동일한 의미로 사용이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ar1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//조금 더 선호하는 방법</span></span><br><span class="line"><span class="keyword">int</span> ar2[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br><h3 id="배열의-참조-값과-메소드"><a href="#배열의-참조-값과-메소드" class="headerlink" title="배열의 참조 값과 메소드"></a>배열의 참조 값과 메소드</h3><p>배열도 인스턴스이므로 메소드 호출 시 참조 값의 전달이 가능하다. 예를 들어 다음과 같이 배열의 참조 값을 인자로 전달할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(sumOfAry(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//물론 아래 메소드처럼 메소드 생성시 배열의 참조변수를 매개변수로 선언해야 한다.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfAry</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>이 과정에서 배열이 새로 생성되는 것은 아니다. 그저 배열 인스턴스를 참조할 수 있는 참조 값만 인자로 전달이 되고, 이 값을 매개변수로 받을 뿐이다. 그리고 다음과 같이 배열의 참조 값을 반환하는 메소드를 정의하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] reIntArr(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line">    <span class="keyword">return</span> arr;<span class="comment">//배열의 참조값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-메서드의-매개변수"><a href="#main-메서드의-매개변수" class="headerlink" title="main 메서드의 매개변수"></a>main 메서드의 매개변수</h2><p>지금까지 배열에 대해서 알아보았다. 그렇다면 main메소드의 매개변수 선언이 무엇을 의미하는지 알 수 있을 것이다.</p><p>매개변수로 String 배열의 참조변수가 선언되었다. 따라서 다음과 같이 main 메소드를 호출해야 한다. (main 메서드를 직접 호출한다는 가정하에 작성된 코드이다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String []&#123;<span class="string">"Coffee"</span>, <span class="string">"Milk"</span>, <span class="string">"Orange"</span>&#125;;</span><br><span class="line">main(arr);</span><br></pre></td></tr></table></figure><br><p>물론 코드상에서 main메소드를 위와 같이 직접 호출하지는 않는다. 게다가 우리가 main 메소드에 전달할 String 배열을 만들지도 않는다. </p><p>그렇다면 어떻게 String 배열이 만들어지고 또 main 메소드의 인자로 전달되는 것일까?</p><p>String 배열을 구성하는 것도 main 메소드를 호출하는 것도 가상머신에 의해 이뤄지는 일이다. 다만 String 배열을 구성할 문자열은 프로그램 사용자가 전달해야 한다. </p><p>예를 들어서 Simple.class 에 위치한 main 메소드를 다음과 같이 호출한다고 가정해보자. </p><ul><li>C:\JavaStudy&gt; java Simple</li></ul><p>그러면 String 배열이 다음과 같이 구성이 되어 main 메소드에 전달이 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;&#125;;</span><br></pre></td></tr></table></figure><br><p>즉 빈 String 배열이 생성되어 main 메소드의 호출이 이뤄진다. 반면 다음과 같이 실행을 하면, </p><ul><li>C:/JavaStudy&gt; java Simple Coffee Mile Orange</li></ul><p>즉 실행 명령문에 이어서 공백을 구분 기준으로 문자열을 입력하면, 이 내용을 대상으로 String 배열이 구성되고, 이 배열의 참조 값이 전달되면서 main 메소드가 호출이 된다. 그럼 이러한 내용의 확인을 위해 다음 예제를 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">        System.out.println(args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>Coffee, Mile, Orange가 뜨는 것을 볼 수 있을 것이다.(참고로 이클립스에선 javac , java 명령어를 알아서 처리해주기때문에 cmd를 활용하여 명령어를 직접 입력해보는 것이 좋다)</p><p>이 밖에 다차원 배열등이 있지만 설명하는 것보단 직접 해보는 것이 더 효율적인 것 같다.</p><ul><li>배열 관련 예제코드<ul><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C01.java" rel="external nofollow noopener noreferrer" target="_blank">예제 01</a></li><li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C02.java" rel="external nofollow noopener noreferrer" target="_blank">예제 02</a></li></ul></li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/30/4.%20java/JAVA-14-%EB%B0%B0%EC%97%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 13. static 응용 - Singleton</title>
      <link>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/</link>
      <guid>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/</guid>
      <pubDate>Wed, 29 Apr 2020 12:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;싱글톤-패턴-Singleton-Pattern-이란&quot;&gt;&lt;a href=&quot;#싱글톤-패턴-Singleton-Pattern-이란&quot; class=&quot;headerlink&quot; title=&quot;싱글톤 패턴(Singleton Pattern)이란?&quot;&gt;&lt;/a&gt;싱글톤 패턴(Singleton Pattern)이란?&lt;/h2&gt;&lt;p&gt;싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="싱글톤-패턴-Singleton-Pattern-이란"><a href="#싱글톤-패턴-Singleton-Pattern-이란" class="headerlink" title="싱글톤 패턴(Singleton Pattern)이란?"></a>싱글톤 패턴(Singleton Pattern)이란?</h2><p>싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다.<a id="more"></a></p><h2 id="싱글톤이-사용되는-이유"><a href="#싱글톤이-사용되는-이유" class="headerlink" title="싱글톤이 사용되는 이유"></a>싱글톤이 사용되는 이유</h2><p>한번의 객체 생성으로 재 사용이 가능하기 때문에 메모리 낭비를 방지할 수 있다. 또한 싱글톤으로 생성된 객체는 무조건 한번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이하다.</p><h2 id="싱글톤-예제"><a href="#싱글톤-예제" class="headerlink" title="싱글톤 예제"></a>싱글톤 예제</h2><p>우리가 프로그램을 만들다보면 단 하나만 존재해야 하는 인스턴스들이 존재할 수 있다. 예를 들어 특정 학교와 학생이라는 객체를 만든다고 할 때 학생은 다수 존재하기 때문에 생성자를 계속 만들어 사용해왔다. 하지만 학생들을 대상으로 학교는 1이상 생성하는 것은 비효율적 이므로 한번만 생성할 수 있게 만들어야 한다. 그렇다면 우리는 기술적으로 어떻게 객체를 최초 한번만 생성하게 할 수 있을까?</p><p>객체를 새로 생성할 때 우리는 생성자를 호출하여 만들 수 있다. 그렇다면 생성자를 외부에서 호출하지 못하게 막는다면 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">School</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 생성자를 private로 정의하면 직접 생성자를 정의하였기 때문에 자바가상머신이 디폴트 생성자를 만들어주지도 않는다. 즉 외부에서 생성자를 호출 할 수 없게 되는 것 이다. 하지만 위와 같은 상황에선 School 의 객체를 아예 생성할 수 없기 때문에 몇가지 코드를 더 추가해 주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> School instance = <span class="keyword">new</span> School();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">School</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> School <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private 는 클래스 내부에선 접근할 수 있기 때문에 내부에서 생성자를 호출하여 새로운 객체를 만들고 <code>School타입</code>의 참조변수에 할당된 것을 볼 수 있다. 그리고 <code>getInstance</code> 메소드를 통해 참조변수(생성된 객체의 주솟값을 참조) <code>instance</code>를 반환함으로써 외부에서 이 값을 통해 <code>School 객체</code>를 사용할 수 있을 것 이다.</p><p>여기서 중요한 것은 참조변수 instance가 static 변수라는 점 인데, 만약 instance가 non-static한 변수였다면 생성자를 통해 객체가 생성될 때 존재하게 될 것이다. 하지만 static 변수는 자바가상머신이 클래스를 읽어올때 생성되는 변수이다. 그렇기때문에 생성자를 호출하지 않아도 외부에서 클래스를 통해 사용되어질 수 있는 것 이다. 물론 정보은닉적인 관점에서 instance 변수 자체는 private 키워드를 통해 외부에서 조작하지 못하게 하고 getInstance 메소드를 통해서만 사용될 수 있게 하였다.</p><p>그렇다면 자연스럽게 getInstance 메소드가 static 메소드인 이유도 알 수 있다. 일반 인스턴스 메소드 역시 객체가 생성될때 사용할 수 있다. 때문에 static 메소드로 정의 함으로써 외부에서 클래스를 통해 바로 호출이 가능하게 해야하는 것 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        School s1 = School.getInstance();</span><br><span class="line">        School s2 = School.getInstance();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SchoolTest 클래스를 테스트한 결과 School 클래스를 객체 생성없이 바로 <code>getInstance()</code> 를 호출하고 있다. <code>getInstance</code>가 반환하는 <code>참조변수 instance</code>는 클래스를 로딩하는 시점에서 객체가 생성되어 주솟값을 담고 있기때문에 참조변수의 값으로써 사용되어질 수 있다. 위의 참조변수 s1와 s2의 값을 출력해보면</p><p>test.School@79698539<br>test.School@79698539</p><p>위와 같이 같은 인스턴스를 참조하고 있는 것을 알 수 있다.</p><h2 id="싱글톤의-문제점"><a href="#싱글톤의-문제점" class="headerlink" title="싱글톤의 문제점"></a>싱글톤의 문제점</h2><p>전역성을 띄면서 다른 객체와 공통으로 사용하는 경우와 같은 몇 가지 케이스에서만 사용할 때 효율적이며 그 외에는 문제점이 생길 수 있다.<br>일단 싱글톤으로 만든 객체의 역할이 간단한 것이 아닌 역할이 복잡한 경우라면 해당 싱글톤 객체를 사용하는 다른 객체간의 결함도가 높아져서 객체 지향 설계 원칙에 어긋나게 된다. (개방-폐쇄)</p>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-13-static%20%EC%9D%91%EC%9A%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JAVA - 12. static 변수와 메소드</title>
      <link>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/</link>
      <guid>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/</guid>
      <pubDate>Wed, 29 Apr 2020 11:20:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;static-변수&quot;&gt;&lt;a href=&quot;#static-변수&quot; class=&quot;headerlink&quot; title=&quot;static 변수&quot;&gt;&lt;/a&gt;static 변수&lt;/h2&gt;&lt;p&gt;static 변수는 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="static-변수"><a href="#static-변수" class="headerlink" title="static 변수"></a>static 변수</h2><p>static 변수는 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.<a id="more"></a> 인스턴스를 생성하면, 각 인스턴스들은 서로 독립적기 때문에 서로 다른 값을 유지하게된다. 경우에 따라서는 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우가 있는데 이때 static 변수를 사용하면 된다. 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> studentId;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> studentId, String studentName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">        <span class="keyword">this</span>.studentName = studentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"jaebeom"</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"jongwon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전에 다루었던 학생 클래스이다. 위와 같이 학생을 식별하기위한 학생번호라는 속성을 주고 사용자가 직접 학생번호를 입력하고있다. 위와 같은 상황에 일어날 수 있는 일이 무엇이 있을까?</p><p>먼저 값을 하나하나 입력하기때문에 학생이 1000명일 경우 1부터 1000까지 직접 입력해야한다. 그리고 사용자가 직접 번호를 적다보면 잘못 입력하여 중복되는 값들이 생길 수 있다. 이것은 치명적인 문제가 될 것 이다. 이것을 개선한 다음 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> serialNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> studentId;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String studentName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentName = studentName;</span><br><span class="line">        serialNum++;</span><br><span class="line">        studentId = serialNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"jaebeom"</span>);</span><br><span class="line">        student1.showStudentInfo();</span><br><span class="line"></span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"jongwon"</span>);</span><br><span class="line">        student2.showStudentInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스의 속성으로 <code>serialNum</code> 이라는 static 변수(클래스 변수)가 추가되었다. 그리고 생성자가 호출될때마다 <code>serialNum</code>의 값을 1씩 증가시키고 <code>studentId</code>에 그 값을 할당하고있다. 위의 코드를 메모리 상태와 연관 지어보면 다음과 같이 될 것 이다.</p><p><img src="https://github.com/gojaebeom/hexo-blog-server/blob/master/themes/icarus/source/images/%EC%9E%90%EB%B0%94/static.png?raw=true" alt="이미지"></p><p>위의 두 <code>student1</code>, <code>student2</code> 참조변수는 서로 다른 인스턴트를 참조하고 있기 때문에 맴버변수 또한 서로 다른 메모리를 사용한다. 하지만 static 변수는 선언 시 메모리 영역에 따로 할당이 되기때문에 Student 클래스를 통해 생성된 모든 인스턴트들은 이 값을 모두 공유하게 되는 것이다.</p><p>결론적으로 static 변수가 모든 인스턴스에 공유되는 특징을 이용하여 사용자가 직접 학생번호를 입력하지 않고도 생성자가 호출될 때 마다 알아서 학생의 번호가 증가되게 만들었다. 이렇듯 static 변수는 객체가 공유해야하는 값을 필요로 할 때 사용할 수 있다.</p><h2 id="static-변수-접근-방법"><a href="#static-변수-접근-방법" class="headerlink" title="static 변수 접근 방법"></a>static 변수 접근 방법</h2><p>static 변수도 ‘접근 수준 지시자’ 의 규칙을 그대로 적용받기 때문에 public으로 선언되면 어디서든 접근이 가능하다. 물론 접근 방법에 있어서는 차이를 보이는데 이와 관련된 내용은 이어서 설명하겠다.</p><p>static 변수에 접근하는 방법은 접근 영역을 기준으로 다음과 같이 크게 두 가지로 나뉜다.</p><ul><li>클래스 내부 접근 : 변수의 이름을 통해 직접 접근</li><li>클래스 외부 접근 : 클래스 또는 인스턴스의 이름을 통해 접근</li></ul><p>다음예제를 보면서 static 변수의 접근 방법을 알아보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessWay</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AccessWay()&#123;</span><br><span class="line">incrCnt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++; <span class="comment">//클래스 내부에서 이름을 통한 접근</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWayTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AccessWay way = <span class="keyword">new</span> AccessWay();</span><br><span class="line">way.num++; <span class="comment">//외부에서 인스턴스의 이름을 통한 접근</span></span><br><span class="line">AccessWay.num++; <span class="comment">//외부에서 클래스의 이름을 통한 접근</span></span><br><span class="line">System.out.println(<span class="string">"num = "</span> + AccessWay.num);<span class="comment">// 총 3이 찍힌다.</span></span><br><span class="line"></span><br><span class="line">AccessWay way2 = <span class="keyword">new</span> AccessWay();<span class="comment">//way2라는 새로운 AccessWay의 인스턴스를 생성하였다.</span></span><br><span class="line">System.out.println(way2.num);<span class="comment">//그리고 way2의 클래스변수 num을 조회 하였는데 값은 4가 찍힌다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인스턴스의 이름을 통한 접근 방법을 보면서, static 변수를 인스턴스 내부에 위치한 것으로 오해하면 안된다. 그리고 static 변수 num은 default로 선언되었다. 따라서 클래스 내부는 물론 클래스 외부이더라도 동일 패키지로 묶여 있으면 접근이 가능하다.</p><h2 id="인스턴트-변수-맴버-변수-와-static-변수-클래스-변수-의-차이"><a href="#인스턴트-변수-맴버-변수-와-static-변수-클래스-변수-의-차이" class="headerlink" title="인스턴트 변수(맴버 변수)와 static 변수(클래스 변수)의 차이"></a>인스턴트 변수(맴버 변수)와 static 변수(클래스 변수)의 차이</h2><h3 id="맴버-변수"><a href="#맴버-변수" class="headerlink" title="맴버 변수"></a>맴버 변수</h3><ul><li>공간적 특성: 인스턴트 변수는 객체마다 별도로 존재한다.<br>인스턴스 멤버 라고 부른다.</li><li>시간적 특성: 객체 생성 시에 인스턴트 변수가 생성된다.<ul><li>객체가 생길 때 인스턴트 변수도 생성된다.</li><li>객체 생성 후 인스턴트 변수 사용이 가능하다.</li><li>객체가 사라지면 인스턴트 변수도 사라진다.</li></ul></li><li>공유의 특성: 공유되지 않는다.<ul><li>인스턴트 변수는 객체 내에 각각의 공간을 유지한다.</li></ul></li></ul><h3 id="static-변수-1"><a href="#static-변수-1" class="headerlink" title="static 변수"></a>static 변수</h3><ul><li>공간적 특성: static 변수는 클래스당 하나가 생성된다.<ul><li>static 변수는 객체 내부가 아닌 별도의 공간에 생성된다.</li></ul></li><li>시간적 특성: 클래스 로딩 시에 static 변수가 생성된다.<ul><li>객체가 생기기 전에 이미 생성된다.</li><li>객체가 생기기 전에도 사용이 가능하다. (객체를 생성하지 않고도 사용할 수 있다)</li><li>객체가 사라져도 static 변수는 사라지지 않는다.</li><li>static 변수는 프로그램이 종료될 때 사라진다.</li></ul></li><li>공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유된다.</li></ul><h3 id="클래스로딩"><a href="#클래스로딩" class="headerlink" title="클래스로딩"></a>클래스로딩</h3><p>앞서 설명에서 static 변수는 클래스 로딩시 생성된다고 하였는데, 이렇듯 가상머신이 특정 클래스 정보를 읽는 행위를 가리켜 클래스 로딩 이라 한다. 그리고 특정 클래스의 인스턴스 생성을 위해서는 해당 클래스가 반드시 가상머신에 의해 로딩되어야 한다. 즉 인스턴스 생성보다 클래스 로딩이 먼저이다.</p><h2 id="static-메소드"><a href="#static-메소드" class="headerlink" title="static 메소드"></a>static 메소드</h2><p>클래스 내에 정의된 메소드에 static 선언을 하면 static 메소드(클래스 메소드)가 된다. 그리고 static 메소드는 그 성격이 static 변수와 유사하다. 접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 static 변수와 동일하다.</p><h3 id="static-메소드의-정의와-호출"><a href="#static-메소드의-정의와-호출" class="headerlink" title="static 메소드의 정의와 호출"></a>static 메소드의 정의와 호출</h3><p>static 변수의 특성 두 가지는 다음과 같다.</p><ul><li>인스턴스 생성 이전부터 접근이 가능하다.</li><li>어느 인스턴스에도 속하지 않는다.</li></ul><p>이 두 가지는 static 메소드도 동일하게 갖는 특성이다. 따라서 이 사실을 다음 예제를 통해서 확인해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> myNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//static 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDouble</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;<span class="comment">//static 메소드</span></span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">myNum = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyNumber</span><span class="params">()</span> </span>&#123;<span class="comment">//인스턴스 메소드</span></span><br><span class="line">showInt(myNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinterTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NumberPrinter.showInt(<span class="number">50</span>);<span class="comment">// 클래스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 사실 위의 문장만 보더라도 static 메소드가 어느 인스턴스에도 속하지 않는다는 사실을 알 수 있다.</span></span><br><span class="line"><span class="comment"> * 인스턴스 생성 이전에 호출이 되었기 때문이다. </span></span><br><span class="line"><span class="comment"> * 그리고 예제의 주석에서 설명하고 있듯이 클래스의 내부와 외부에서 static 메소드를 호출하는 방법은</span></span><br><span class="line"><span class="comment"> * static 변수에 접근하는 방법과 차이가 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">NumberPrinter np = <span class="keyword">new</span> NumberPrinter();</span><br><span class="line">np.showDouble(<span class="number">3.15</span>); <span class="comment">// 인스턴스 이름을 통한 클래스 메소드 호출</span></span><br><span class="line">np.setMyNumber(<span class="number">30</span>);</span><br><span class="line">np.showMyNumber();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 질문에 답해보자. </p><ul><li>static 메소드에서 같은 클래스에 선언된 인스턴스 변수에 접근이 가능한가?</li></ul><p>이는 다음과 같은 코드의 작성이 가능한지를 묻는 질문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">num = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 에러가 난다. 논리적으로 생각을 하면 위와 같은 문장 구성이 불가능하다는 것을 알 수 있다.</p><p>인스턴스 변수는 인스턴스에 속한다. 더불어 인스턴스가 생성이 되어야 메모리 공간에 존재하게 된다. 반면 static 메소드는 인스턴스 생성 이전부터 호출이 가능하다. 따라서 위 질문에 대해서 다음과 같이 대답할 수 있다.</p><ul><li>static 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수에 접근이 불가능하다.</li><li>같은 이유로 static 메소드는 인스턴스 메소드의 호출도 불가능하다.</li></ul><p>그러나 static 메소드 같은 클래스에 정의되어 있는 다른 static 메소드나 성격이 동일한 static 변수에는 접근이 가능하다.(당연한 얘기지만)</p><h2 id="System-out-println-그리고-main-메소드"><a href="#System-out-println-그리고-main-메소드" class="headerlink" title="System.out.println 그리고 main 메소드"></a>System.out.println 그리고 main 메소드</h2><p>지금까지 main 메소드를 정의할 때 그 앞에 static 선언을 붙여왔다. 그리고 인스턴스의 생성 없이 println 메소드를 호출해 왔다.</p><h3 id="System-out-println-에서-out과-println의-정체는"><a href="#System-out-println-에서-out과-println의-정체는" class="headerlink" title="System.out.println()에서 out과 println의 정체는?"></a>System.out.println()에서 out과 println의 정체는?</h3><p>static 선언의 의미를 알았으니 System.out.println()의 구성을 이해할 수 있다. 일단 System은 자바에서 제공하는 클래스로 java.lang 패키지에 묶여있다. 따라서 원칙적으로는 다음과 같이 호출해야 한다.</p><ul><li>java.lang.System.out.println(…);</li></ul><p>그러나 컴파일러가 다음 문장은 삽입 해주기때문에 패키지의 이름부분은 생략할 수 있다. </p><ul><li>import java.lang.*;</li></ul><p>그리고 out은 System.out으로 접근을 하니, 이는 분명 static으로 선언된 static 변수가 분명하다. 클래스의 이름을 통해 접근하니 말이다.   실제로 out은 System 클래스 내에 다음과 같이 선언된 static 변수이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out; <span class="comment">//참조변수</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 println은 PrintStream 클래스의 인스턴스 메소드이다. 따라서 다음 문장을 보면서,</p><ul><li>System.out.println(…);</li></ul><p>다음과 같이 이해 할 수 있어야 한다.</p><ul><li>System에 위치한 클래스 변수 out이 참조하는 인스턴스의 println 메소드를 호출하는 문장</li></ul><h3 id="main-메소드가-public-이고-static인-이유에-대해서-알아보자"><a href="#main-메소드가-public-이고-static인-이유에-대해서-알아보자" class="headerlink" title="main 메소드가 public 이고 static인 이유에 대해서 알아보자."></a>main 메소드가 public 이고 static인 이유에 대해서 알아보자.</h3><p>main 메소드는 반드시 다음의 모양새를 갖춰야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇듯 main 메소드는 public 으로 그리고 static으로 선언해야 한다. 이는 일종의 약속이다. </p><p>main메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당함을 알 수 있다. 그리고 main메소드는 인스턴스가 생성되기 이전에 호출된다. 따라서 static 선언하는 것이 옳음을 알 수 있다.</p><p>다음의 예제를 보자. Car클래스와 Boat 클래스를 정의 하였다. 다음의 main 메소드가 호출이 되어 실제 실행이 되게 하려고 한다면 어떤 클래스에 두어야 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"밴츠"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBoat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"보트"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 메소드는 static 메소드이기 때문에, 즉 특정 인스턴스의 맴버로 존재하는 메소드가 아니기 때문에 정답은 어디든 상관은 없다. (물론 실행방식에선 차이가 발생한다. Car클래스에 두었으면 java Car 를 호출, Boat면 java Boat 호출)</p><p>그렇다면 Car클래스에 두었다고 가정해보자. main 메소드를 Car 클래스 내에 위치시켰는데 그 안에서 Car 인스턴스를 생성하고 있다. 혹시 이부분이 조금 난해하게 느껴지는가? 그렇다면 다음과 같이 생각하자.</p><ul><li>Car클래스와 static으로 선언된 main메소드는 사실상 별개다.</li><li>다만 Car 클래스가 main 메소드에게 공간을 제공했을 뿐이다. </li></ul>]]></content:encoded>
      
      <comments>http://gojaebeom.github.io/2020/04/29/4.%20java/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
