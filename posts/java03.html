<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/98227b176e912c58.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98227b176e912c58.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-1f10003e17636e37.js" defer=""></script><script src="/_next/static/chunks/main-1c56b9c461b692c3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/61-ab81cedf8f7f59db.js" defer=""></script><script src="/_next/static/chunks/84-ae52c575115d15de.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4689b7fc2dd17d73.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_buildManifest.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_ssgManifest.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="w-full h-full overflow-hidden md:flex md:flex-col md:items-center"><div id="DETAIL_THUMBNAIL" class="relative w-full md:w-[1240px] h-[300px] z-[1]"><div id="DETAIL_BACK_BTN" class="absolute z-10 flex items-center justify-center w-10 h-10 text-black rounded-full top-6 left-4 bg-white/30"><a href="/"><i class="text-xl fa-regular fa-angle-left mt-0.5 mr-0.5"></i></a></div><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:absolute;top:0;left:0;bottom:0;right:0"><img alt="image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="image" sizes="100vw" srcSet="/images/09.jpg?imwidth=640 640w, /images/09.jpg?imwidth=750 750w, /images/09.jpg?imwidth=828 828w, /images/09.jpg?imwidth=1080 1080w, /images/09.jpg?imwidth=1200 1200w, /images/09.jpg?imwidth=1920 1920w, /images/09.jpg?imwidth=2048 2048w, /images/09.jpg?imwidth=3840 3840w" src="/images/09.jpg?imwidth=3840" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span><div id="DETAIL_THUMBNAIL_BOTTOM" class="absolute bottom-0 left-0 w-full h-6 bg-white rounded-t-3xl"></div></div><div id="DETAIL_BODY" class="px-4 pt-4"><h1 id="DETAIL_TITLE" class="mb-10 text-3xl font-extrabold text-black">JAVA - 03. 상수와 형변환</h1><div id="DETAIL_CONTENT" class="prose prose-slate"><h2 id="상수constant란">상수(Constant)란?</h2>
<ul>
<li>변하지 않는 수를 말한다. <!-- more --></li>
</ul>
<h2 id="상수-선언">상수 선언</h2>
<p>자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 &#39;상수&#39;가 된다. 그리고 상수는 다음과 같은 특징이 있다. </p>
<ul>
<li>값을 딱 한 번만 할당할 수 있다.</li>
<li>한 번 할당된 값은 변경이 불가능하다.</li>
</ul>
<pre><code class="language-java">// tip.상수의 선언
final int NUM;

// tip.선언된 상수에 값 할당
NUM = 10;

// tip.그 이후로 값의 변경은 불가능하다
NUM = 5; // 에러

// tip.변수와 마찬가지로 선언과 동시에 초기화가 가능하다.
final int FINAL_NUMBER = 10;
</code></pre>
<p><strong>상수의 관례</strong>
그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다.</p>
<ul>
<li>상수의 이름은 모두 대문자로 짓는다.</li>
<li>이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.</li>
</ul>
<h2 id="리터럴literal">리터럴(literal)</h2>
<p>프로그램에서 사용하는 모든 숫자, 문자, 논리 값 등을 가리켜 리터럴이라고 한다. 모든 리터럴(리터럴 상수라고도 한다)들은 상수 풀(Constant Pool)이라는 곳에 저장되어 있다.</p>
<pre><code class="language-java">int num = 100; //right value에 해당하는 100이 리터럴이다.
char ch = &#39;A&#39;; //마찬가지로 A도 리터럴 이다.
</code></pre>
<p><strong>리터럴(숫자, 문자, 논리 값) --로딩--&gt; Constant Pool(10, &#39;A&#39;, true) --대입, 복사--&gt; 변수</strong></p>
<h2 id="형변환">형변환</h2>
<p>서로 다른 자료형의 값이 대입이 되는 경우 형변환이 일어난다.</p>
<p><strong>byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double</strong></p>
<p>일반적으로 위와 같이 화살표의 방향대로 대입이 되면 묵시적인 형변환이 일어나고 아닐 경우 직접 명시적인 형변환을 해주어야 한다.</p>
<h3 id="묵시적-형-변환implicit-type-conversion">묵시적 형 변환(Implicit Type Conversion)</h3>
<ul>
<li>작은 수에서 큰 수로 대입</li>
<li>덜 정밀한 수에서 더 정밀한 수로 대입(정수에서 실수)</li>
</ul>
<pre><code class="language-java">//ImplicitConterSionTest.java
public static void main(String[] args) {
  //정수
  byte bNum = 10;
  short sNum = bNum;
  int iNum = sNum;
  long lNum = iNum;

  //실수
  float fNum = lNum;
  double dNum = fNum;
}
</code></pre>
<p>위의 예제처럼 크기가 작은 수에서 큰 타입 순서로 대입을 할경우 자동적인 형변환이 일어난다.</p>
<h3 id="명시적-형-변환explicit-type-conversion">명시적 형 변환(Explicit Type Conversion)</h3>
<ul>
<li>변환되는 자료형을 명시(타입 캐스팅)<ul>
<li>이에 따른 자료의 손실이 발생할 수 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//ExplicitConterSionTest.java
public static void main(String[] args) {
  // 예제 1
  int iNum = 1000;
  byte bNum = (byte)iNum;
  //형변환을 억지로 하면 데이터 손실을 불러올 수 있다.
  System.out.println(bNum);//-24

  // 예제 2
  double dNum = 1.2;
  float fNum = 0.9F;

  int iNum1 = (int)dNum + (int)fNum; //1
  int iNum2 = (int)(dNum + fNum); //2

  System.out.println(iNum1);
  System.out.println(iNum2);
}
</code></pre>
<p>예제 1은 int형 변수에 1000의 값을 할당하였다. 그리고 byte에게 대입하려고 한다. 하지만 byte는 int보다 크기가 작음으로 <code>(byte)</code> 와같이 프로그래머가 직접 byte형으로 변환 하겠다고 명시해주어야한다. 그리고 명시적인 형변환을 하게 되면 데이터가 손실될 수 도 있다. 예제 1의 경우 byte가 담을 수 있는 크기를 초과하여 값이 잘려 -24가 출력 되는 것을 알 수 있다.</p>
<p>예제 2의 핵심은 두개의 실수를 더하여 정수형 변수에 대입하려고 하는 것 이다. <code>iNum1</code>의 경우엔 각 <code>dNum</code>, <code>fNum</code> 의 값을 형변환 하고 연산을 진행한다. 즉 각자의 값은 소숫점이 잘려나가 1, 0이된다. 결국 1+0의 연산을 통해 1이라는 값이 <code>iNum1</code>에 대입이 된다. <code>iNum2</code>의 경우 먼저 변수의 값이 연산을 진행 한 이후 타입캐스팅이 일어난다 1.2 + 0.9 = 2.1이 되고 그 이후 소숫점이 잘려 2라는 값이 대입이 되는 것을 알 수 있다. 이것은 이 다음에 다룰 연산자에서 연산 우선순위를 통해 알 수 있다.</p>
</div></div><div id="FOOTER" class="bg-gradient-to-tr from-[#16a085] to-[#f4d03f] mt-20 md:w-full"><div class="relative col-span-3 "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#ffffff" fill-opacity="1" d="M0,32L14.1,64C28.2,96,56,160,85,186.7C112.9,213,141,203,169,170.7C197.6,139,226,85,254,58.7C282.4,32,311,32,339,53.3C367.1,75,395,117,424,149.3C451.8,181,480,203,508,208C536.5,213,565,203,593,197.3C621.2,192,649,192,678,186.7C705.9,181,734,171,762,181.3C790.6,192,819,224,847,208C875.3,192,904,128,932,128C960,128,988,192,1016,229.3C1044.7,267,1073,277,1101,240C1129.4,203,1158,117,1186,90.7C1214.1,64,1242,96,1271,117.3C1298.8,139,1327,149,1355,133.3C1383.5,117,1412,75,1426,53.3L1440,32L1440,0L1425.9,0C1411.8,0,1384,0,1355,0C1327.1,0,1299,0,1271,0C1242.4,0,1214,0,1186,0C1157.6,0,1129,0,1101,0C1072.9,0,1045,0,1016,0C988.2,0,960,0,932,0C903.5,0,875,0,847,0C818.8,0,791,0,762,0C734.1,0,706,0,678,0C649.4,0,621,0,593,0C564.7,0,536,0,508,0C480,0,452,0,424,0C395.3,0,367,0,339,0C310.6,0,282,0,254,0C225.9,0,198,0,169,0C141.2,0,113,0,85,0C56.5,0,28,0,14,0L0,0Z"></path></svg></div><footer class="w-full p-10 font-bold text-center text-white">Created By jaebeom Go 🎉</footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"java03","data":{"title":"JAVA - 03. 상수와 형변환","category":"java","excerpt":"자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 '상수'가 된다. 그리고 상수는 다음과 같은 특징이 있다.","createdAt":"2019-05-03","thumbnail":"java/thumbnail01.png"},"content":"\r\n## 상수(Constant)란?\r\n- 변하지 않는 수를 말한다. \u003c!-- more --\u003e\r\n\r\n## 상수 선언\r\n자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 '상수'가 된다. 그리고 상수는 다음과 같은 특징이 있다. \r\n- 값을 딱 한 번만 할당할 수 있다.\r\n- 한 번 할당된 값은 변경이 불가능하다.\r\n\r\n```java\r\n// tip.상수의 선언\r\nfinal int NUM;\r\n\r\n// tip.선언된 상수에 값 할당\r\nNUM = 10;\r\n\r\n// tip.그 이후로 값의 변경은 불가능하다\r\nNUM = 5; // 에러\r\n\r\n// tip.변수와 마찬가지로 선언과 동시에 초기화가 가능하다.\r\nfinal int FINAL_NUMBER = 10;\r\n```\r\n\r\n**상수의 관례**\r\n그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다.\r\n- 상수의 이름은 모두 대문자로 짓는다.\r\n- 이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.\r\n\r\n## 리터럴(literal)\r\n프로그램에서 사용하는 모든 숫자, 문자, 논리 값 등을 가리켜 리터럴이라고 한다. 모든 리터럴(리터럴 상수라고도 한다)들은 상수 풀(Constant Pool)이라는 곳에 저장되어 있다.\r\n```java\r\nint num = 100; //right value에 해당하는 100이 리터럴이다.\r\nchar ch = 'A'; //마찬가지로 A도 리터럴 이다.\r\n```\r\n\r\n**리터럴(숫자, 문자, 논리 값) --로딩--\u003e Constant Pool(10, 'A', true) --대입, 복사--\u003e 변수**\r\n\r\n## 형변환\r\n서로 다른 자료형의 값이 대입이 되는 경우 형변환이 일어난다.\r\n\r\n**byte -\u003e short -\u003e int \u0026\u0026 char -\u003e long -\u003e float -\u003e double**\r\n\r\n일반적으로 위와 같이 화살표의 방향대로 대입이 되면 묵시적인 형변환이 일어나고 아닐 경우 직접 명시적인 형변환을 해주어야 한다.\r\n\r\n### 묵시적 형 변환(Implicit Type Conversion)\r\n- 작은 수에서 큰 수로 대입\r\n- 덜 정밀한 수에서 더 정밀한 수로 대입(정수에서 실수)\r\n\r\n```java\r\n//ImplicitConterSionTest.java\r\npublic static void main(String[] args) {\r\n  //정수\r\n  byte bNum = 10;\r\n  short sNum = bNum;\r\n  int iNum = sNum;\r\n  long lNum = iNum;\r\n\r\n  //실수\r\n  float fNum = lNum;\r\n  double dNum = fNum;\r\n}\r\n```\r\n위의 예제처럼 크기가 작은 수에서 큰 타입 순서로 대입을 할경우 자동적인 형변환이 일어난다.\r\n\r\n### 명시적 형 변환(Explicit Type Conversion)\r\n- 변환되는 자료형을 명시(타입 캐스팅)\r\n  - 이에 따른 자료의 손실이 발생할 수 있다.\r\n\r\n```java\r\n//ExplicitConterSionTest.java\r\npublic static void main(String[] args) {\r\n  // 예제 1\r\n  int iNum = 1000;\r\n  byte bNum = (byte)iNum;\r\n  //형변환을 억지로 하면 데이터 손실을 불러올 수 있다.\r\n  System.out.println(bNum);//-24\r\n\r\n  // 예제 2\r\n  double dNum = 1.2;\r\n  float fNum = 0.9F;\r\n\r\n  int iNum1 = (int)dNum + (int)fNum; //1\r\n  int iNum2 = (int)(dNum + fNum); //2\r\n\r\n  System.out.println(iNum1);\r\n  System.out.println(iNum2);\r\n}\r\n```\r\n예제 1은 int형 변수에 1000의 값을 할당하였다. 그리고 byte에게 대입하려고 한다. 하지만 byte는 int보다 크기가 작음으로 `(byte)` 와같이 프로그래머가 직접 byte형으로 변환 하겠다고 명시해주어야한다. 그리고 명시적인 형변환을 하게 되면 데이터가 손실될 수 도 있다. 예제 1의 경우 byte가 담을 수 있는 크기를 초과하여 값이 잘려 -24가 출력 되는 것을 알 수 있다.\r\n\r\n예제 2의 핵심은 두개의 실수를 더하여 정수형 변수에 대입하려고 하는 것 이다. `iNum1`의 경우엔 각 `dNum`, `fNum` 의 값을 형변환 하고 연산을 진행한다. 즉 각자의 값은 소숫점이 잘려나가 1, 0이된다. 결국 1+0의 연산을 통해 1이라는 값이 `iNum1`에 대입이 된다. `iNum2`의 경우 먼저 변수의 값이 연산을 진행 한 이후 타입캐스팅이 일어난다 1.2 + 0.9 = 2.1이 되고 그 이후 소숫점이 잘려 2라는 값이 대입이 되는 것을 알 수 있다. 이것은 이 다음에 다룰 연산자에서 연산 우선순위를 통해 알 수 있다."},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"java03"},"buildId":"Ax74oeIwTnOL-khlokt1j","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script src="https://kit.fontawesome.com/e5541f9036.js" crossorigin="anonymous"></script></body></html>