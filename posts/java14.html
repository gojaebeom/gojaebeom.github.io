<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/98227b176e912c58.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98227b176e912c58.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-1f10003e17636e37.js" defer=""></script><script src="/_next/static/chunks/main-1c56b9c461b692c3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/61-ab81cedf8f7f59db.js" defer=""></script><script src="/_next/static/chunks/84-ae52c575115d15de.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4689b7fc2dd17d73.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_buildManifest.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_ssgManifest.js" defer=""></script><script src="/_next/static/Ax74oeIwTnOL-khlokt1j/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="w-full h-full overflow-hidden md:flex md:flex-col md:items-center"><div id="DETAIL_THUMBNAIL" class="relative w-full md:w-[1240px] h-[300px] z-[1]"><div id="DETAIL_BACK_BTN" class="absolute z-10 flex items-center justify-center w-10 h-10 text-black rounded-full top-6 left-4 bg-white/30"><a href="/"><i class="text-xl fa-regular fa-angle-left mt-0.5 mr-0.5"></i></a></div><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:absolute;top:0;left:0;bottom:0;right:0"><img alt="image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="image" sizes="100vw" srcSet="/images/09.jpg?imwidth=640 640w, /images/09.jpg?imwidth=750 750w, /images/09.jpg?imwidth=828 828w, /images/09.jpg?imwidth=1080 1080w, /images/09.jpg?imwidth=1200 1200w, /images/09.jpg?imwidth=1920 1920w, /images/09.jpg?imwidth=2048 2048w, /images/09.jpg?imwidth=3840 3840w" src="/images/09.jpg?imwidth=3840" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span><div id="DETAIL_THUMBNAIL_BOTTOM" class="absolute bottom-0 left-0 w-full h-6 bg-white rounded-t-3xl"></div></div><div id="DETAIL_BODY" class="px-4 pt-4"><h1 id="DETAIL_TITLE" class="mb-10 text-3xl font-extrabold text-black">JAVA - 14. 배열</h1><div id="DETAIL_CONTENT" class="prose prose-slate"><h2 id="배열이란">배열이란?</h2>
<p>배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다. <!-- more --></p>
<h3 id="1차원-배열">1차원 배열</h3>
<p>1차원 배열은 다음과 같이 정의할 수 있다.</p>
<ul>
<li>타입이 같은 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간</li>
</ul>
<p>그런데 자바는 배열도 인스턴스로 처리한다. 즉 자바에서는 배열도 인스턴스 이다. 다음 예제를 보자.</p>
<pre><code class="language-java">public static void main(String[] args) {
    int[] ref = new int[5];//길이가 5인 int형 1차원 배열의 생성문
}
</code></pre>
<br>

<p>위 문장에서 등호를 기준으로 왼편, 오른편에 위치한 것은 각각 참조변수의 선언과 배열의 생성이다. </p>
<p>물론 다음과 같이 참조변수의 선언과 배열 인스턴스의 생성을 구분할 수도 있다.</p>
<pre><code class="language-java">public static void main(String[] args){
    int[] ref;
    ref = new int[5];

    //물론 int형 말고도 다양한 자료형으로 배열을 생성할 수 있다.
    double[] db = new double[5];
    float[] f = new float[3];
    String[] str = new String[10];
    
    //각 배열에 대한 길이 
    System.out.println(db.length);
    System.out.println(f.length);
    System.out.println(str.length);
}
</code></pre>
<br>

<p>위의 문장을 보면 각 배열의 인스턴스 변수 length에 접근하여 배열의 길이 정보를 출력하였다. 이렇듯 인스턴스 변수에 접근이 가능하다는 것은 배열이 인스턴스임을 보인는 결과이기도 하다.</p>
<h2 id="배열-저장과-참조">배열 저장과 참조</h2>
<pre><code class="language-java">int[] arr = new int[3];
</code></pre>
<br>

<p>위 선언된 배열 arr에 첫 번째 공간에 값을 저장하는 방법은 다음과 같다.</p>
<pre><code class="language-java">arr[0] = 7;
</code></pre>
<br>

<p>이렇듯 배열 요소의 위치를 지정하는 인덱스 값은 0에서부터 시작한다. 따라서 배열 arr의 두번째 , 새 번째 요소에 값을 저장하는 방법은 다음과 같다.</p>
<pre><code class="language-java">arr[1] = 3; //2번째
arr[2] = 5; //3번째
</code></pre>
<br>

<p>배열에 저장된 값을 참조하는 방법도 이와 유사하다. 다음은 배열 arr의 모든 요소에 저장된 값을 더하는 방법을 보여준다. </p>
<pre><code class="language-java">int num = arr[0] + arr[1] + arr[2];
</code></pre>
<br>

<h2 id="배열의-생성과-초기화">배열의 생성과 초기화</h2>
<p>배열도 변수와 마찬가지로 생성과 동시에 초기화가 가능하다. 기본적인 배열의 생성 방식은 다음과 같다.</p>
<pre><code class="language-java">int[] arr = new int[3];
</code></pre>
<br>

<p>이 배열을 생성과 동시에 초기화하려면 초기화할 값들을 다음과 같이 중괄호를 이용해서 나열하면 된다. </p>
<pre><code class="language-java">//int[] arr2 = new int[3] {1, 2, 3}; //컴파일 오류 발생
</code></pre>
<br>
    
<p>그런데 위의 문장에서는 초기화할 값들의 수를 통해 배열의 길이 정보를 계산할 수 있으므로, 이경우 배열의 길이 정보를 생략하도록 약속하였다. 즉 위의 문장은 다음과 같이 수정해야 한다.</p>
<pre><code class="language-java">int[] arr2 = new int[] {1, 2 ,3};
</code></pre>
<br>
    
<p>위의 문장을 통해 생성되는 배열의 길이는 3이다. 그리고 위의 문장은 다음과 같이 줄여서 표현할 수 도있다.</p>
<pre><code class="language-java">int[] arr3 = {1, 2, 3};
</code></pre>
<br>
    
<h3 id="배열의-선언-두가지-방법">배열의 선언 두가지 방법</h3>
<p>다음과 같이 배열을 생성하는 문장에서도 이 둘은 동일한 의미로 사용이 된다.</p>
<pre><code class="language-java">int[] ar1 = new int[3]; //조금 더 선호하는 방법
int ar2[] = new int[3];
</code></pre>
<br>
    
    
    
<h3 id="배열의-참조-값과-메소드">배열의 참조 값과 메소드</h3>
<p>배열도 인스턴스이므로 메소드 호출 시 참조 값의 전달이 가능하다. 예를 들어 다음과 같이 배열의 참조 값을 인자로 전달할 수 있다.</p>
<pre><code class="language-java">public static void main(String[] args) {
    int[] arr = {1, 2, 3};
    System.out.println(sumOfAry(arr));
}
    
//물론 아래 메소드처럼 메소드 생성시 배열의 참조변수를 매개변수로 선언해야 한다.
static int sumOfAry(int[] arr) {
    int sum = 0;
    for(int i = 0; i&lt; arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
</code></pre>
<br>

<p>이 과정에서 배열이 새로 생성되는 것은 아니다. 그저 배열 인스턴스를 참조할 수 있는 참조 값만 인자로 전달이 되고, 이 값을 매개변수로 받을 뿐이다. 그리고 다음과 같이 배열의 참조 값을 반환하는 메소드를 정의하는 것도 가능하다.</p>
<pre><code class="language-java">static int[] reIntArr(int x) {
    int[] arr = new int[x];
    return arr;//배열의 참조값을 반환
}
</code></pre>
<h2 id="main-메서드의-매개변수">main 메서드의 매개변수</h2>
<p>지금까지 배열에 대해서 알아보았다. 그렇다면 main메소드의 매개변수 선언이 무엇을 의미하는지 알 수 있을 것이다.</p>
<p>매개변수로 String 배열의 참조변수가 선언되었다. 따라서 다음과 같이 main 메소드를 호출해야 한다. (main 메서드를 직접 호출한다는 가정하에 작성된 코드이다.)</p>
<pre><code class="language-java">String[] arr = new String []{&quot;Coffee&quot;, &quot;Milk&quot;, &quot;Orange&quot;};
main(arr);
</code></pre>
<br>

<p>물론 코드상에서 main메소드를 위와 같이 직접 호출하지는 않는다. 게다가 우리가 main 메소드에 전달할 String 배열을 만들지도 않는다. </p>
<p>그렇다면 어떻게 String 배열이 만들어지고 또 main 메소드의 인자로 전달되는 것일까?</p>
<p>String 배열을 구성하는 것도 main 메소드를 호출하는 것도 가상머신에 의해 이뤄지는 일이다. 다만 String 배열을 구성할 문자열은 프로그램 사용자가 전달해야 한다. </p>
<p>예를 들어서 Simple.class 에 위치한 main 메소드를 다음과 같이 호출한다고 가정해보자. </p>
<ul>
<li>C:\JavaStudy&gt; java Simple</li>
</ul>
<p>그러면 String 배열이 다음과 같이 구성이 되어 main 메소드에 전달이 된다. </p>
<pre><code class="language-java">String[] arr = new String[] {};
</code></pre>
<br>

<p>즉 빈 String 배열이 생성되어 main 메소드의 호출이 이뤄진다. 반면 다음과 같이 실행을 하면, </p>
<ul>
<li>C:/JavaStudy&gt; java Simple Coffee Mile Orange</li>
</ul>
<p>즉 실행 명령문에 이어서 공백을 구분 기준으로 문자열을 입력하면, 이 내용을 대상으로 String 배열이 구성되고, 이 배열의 참조 값이 전달되면서 main 메소드가 호출이 된다. 그럼 이러한 내용의 확인을 위해 다음 예제를 실행해보자.</p>
<pre><code class="language-java">public static void main(String[] args) {
    for(int i=0; i&lt;args.length; i++) {
        System.out.println(args[i]);
    }
}
</code></pre>
<br>

<p>Coffee, Mile, Orange가 뜨는 것을 볼 수 있을 것이다.(참고로 이클립스에선 javac , java 명령어를 알아서 처리해주기때문에 cmd를 활용하여 명령어를 직접 입력해보는 것이 좋다)</p>
<p>이 밖에 다차원 배열등이 있지만 설명하는 것보단 직접 해보는 것이 더 효율적인 것 같다.</p>
<ul>
<li>배열 관련 예제코드<ul>
<li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C01.java">예제 01</a></li>
<li><a href="https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C02.java">예제 02</a></li>
</ul>
</li>
</ul>
</div></div><div id="FOOTER" class="bg-gradient-to-tr from-[#16a085] to-[#f4d03f] mt-20 md:w-full"><div class="relative col-span-3 "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#ffffff" fill-opacity="1" d="M0,32L14.1,64C28.2,96,56,160,85,186.7C112.9,213,141,203,169,170.7C197.6,139,226,85,254,58.7C282.4,32,311,32,339,53.3C367.1,75,395,117,424,149.3C451.8,181,480,203,508,208C536.5,213,565,203,593,197.3C621.2,192,649,192,678,186.7C705.9,181,734,171,762,181.3C790.6,192,819,224,847,208C875.3,192,904,128,932,128C960,128,988,192,1016,229.3C1044.7,267,1073,277,1101,240C1129.4,203,1158,117,1186,90.7C1214.1,64,1242,96,1271,117.3C1298.8,139,1327,149,1355,133.3C1383.5,117,1412,75,1426,53.3L1440,32L1440,0L1425.9,0C1411.8,0,1384,0,1355,0C1327.1,0,1299,0,1271,0C1242.4,0,1214,0,1186,0C1157.6,0,1129,0,1101,0C1072.9,0,1045,0,1016,0C988.2,0,960,0,932,0C903.5,0,875,0,847,0C818.8,0,791,0,762,0C734.1,0,706,0,678,0C649.4,0,621,0,593,0C564.7,0,536,0,508,0C480,0,452,0,424,0C395.3,0,367,0,339,0C310.6,0,282,0,254,0C225.9,0,198,0,169,0C141.2,0,113,0,85,0C56.5,0,28,0,14,0L0,0Z"></path></svg></div><footer class="w-full p-10 font-bold text-center text-white">Created By jaebeom Go 🎉</footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"java14","data":{"title":"JAVA - 14. 배열","category":"java","excerpt":"배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다.","createdAt":"2022-05-01","thumbnail":"java/thumbnail01.png"},"content":"\r\n## 배열이란?\r\n배열은 자료형이 같은 둘 이상의 값을 저장할 수 있는 메모리 공간을 의미한다. 그리고 배열은 그 구조에 따라서 1차원 배열과 2차원 이상의 다차원 배열로 나뉜다. \u003c!-- more --\u003e\r\n\r\n### 1차원 배열\r\n1차원 배열은 다음과 같이 정의할 수 있다.\r\n- 타입이 같은 둘 이상의 데이터를 저장할 수 있는 1차원 구조의 메모리 공간\r\n\r\n그런데 자바는 배열도 인스턴스로 처리한다. 즉 자바에서는 배열도 인스턴스 이다. 다음 예제를 보자.\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\tint[] ref = new int[5];//길이가 5인 int형 1차원 배열의 생성문\r\n}\r\n```\r\n\u003cbr\u003e\r\n\r\n위 문장에서 등호를 기준으로 왼편, 오른편에 위치한 것은 각각 참조변수의 선언과 배열의 생성이다. \r\n\r\n물론 다음과 같이 참조변수의 선언과 배열 인스턴스의 생성을 구분할 수도 있다.\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    int[] ref;\r\n    ref = new int[5];\r\n\r\n    //물론 int형 말고도 다양한 자료형으로 배열을 생성할 수 있다.\r\n    double[] db = new double[5];\r\n    float[] f = new float[3];\r\n    String[] str = new String[10];\r\n    \r\n    //각 배열에 대한 길이 \r\n    System.out.println(db.length);\r\n    System.out.println(f.length);\r\n    System.out.println(str.length);\r\n}\r\n```\r\n\u003cbr\u003e\r\n\r\n위의 문장을 보면 각 배열의 인스턴스 변수 length에 접근하여 배열의 길이 정보를 출력하였다. 이렇듯 인스턴스 변수에 접근이 가능하다는 것은 배열이 인스턴스임을 보인는 결과이기도 하다.\r\n\r\n## 배열 저장과 참조\r\n\r\n```java\r\nint[] arr = new int[3];\r\n```\r\n\u003cbr\u003e\r\n\r\n위 선언된 배열 arr에 첫 번째 공간에 값을 저장하는 방법은 다음과 같다.\r\n```java\r\narr[0] = 7;\r\n```\r\n\u003cbr\u003e\r\n\r\n이렇듯 배열 요소의 위치를 지정하는 인덱스 값은 0에서부터 시작한다. 따라서 배열 arr의 두번째 , 새 번째 요소에 값을 저장하는 방법은 다음과 같다.\r\n\r\n```java\r\narr[1] = 3; //2번째\r\narr[2] = 5; //3번째\r\n```\r\n\u003cbr\u003e\r\n\r\n배열에 저장된 값을 참조하는 방법도 이와 유사하다. 다음은 배열 arr의 모든 요소에 저장된 값을 더하는 방법을 보여준다. \r\n```java\r\nint num = arr[0] + arr[1] + arr[2];\r\n```\r\n\u003cbr\u003e\r\n\r\n## 배열의 생성과 초기화\r\n배열도 변수와 마찬가지로 생성과 동시에 초기화가 가능하다. 기본적인 배열의 생성 방식은 다음과 같다.\r\n```java\r\nint[] arr = new int[3];\r\n```\r\n\u003cbr\u003e\r\n\r\n이 배열을 생성과 동시에 초기화하려면 초기화할 값들을 다음과 같이 중괄호를 이용해서 나열하면 된다. \r\n```java\r\n//int[] arr2 = new int[3] {1, 2, 3}; //컴파일 오류 발생\r\n```\r\n\u003cbr\u003e\r\n\t\r\n그런데 위의 문장에서는 초기화할 값들의 수를 통해 배열의 길이 정보를 계산할 수 있으므로, 이경우 배열의 길이 정보를 생략하도록 약속하였다. 즉 위의 문장은 다음과 같이 수정해야 한다.\r\n```java\r\nint[] arr2 = new int[] {1, 2 ,3};\r\n```\r\n\u003cbr\u003e\r\n\t\r\n위의 문장을 통해 생성되는 배열의 길이는 3이다. 그리고 위의 문장은 다음과 같이 줄여서 표현할 수 도있다.\r\n```java\r\nint[] arr3 = {1, 2, 3};\r\n```\r\n\u003cbr\u003e\r\n\t\r\n### 배열의 선언 두가지 방법\r\n다음과 같이 배열을 생성하는 문장에서도 이 둘은 동일한 의미로 사용이 된다.\r\n```java\r\nint[] ar1 = new int[3]; //조금 더 선호하는 방법\r\nint ar2[] = new int[3];\r\n```\r\n\u003cbr\u003e\r\n\t\r\n\t\r\n\t\r\n### 배열의 참조 값과 메소드\r\n배열도 인스턴스이므로 메소드 호출 시 참조 값의 전달이 가능하다. 예를 들어 다음과 같이 배열의 참조 값을 인자로 전달할 수 있다.\r\n```java\r\npublic static void main(String[] args) {\r\n    int[] arr = {1, 2, 3};\r\n    System.out.println(sumOfAry(arr));\r\n}\r\n\t\r\n//물론 아래 메소드처럼 메소드 생성시 배열의 참조변수를 매개변수로 선언해야 한다.\r\nstatic int sumOfAry(int[] arr) {\r\n    int sum = 0;\r\n    for(int i = 0; i\u003c arr.length; i++) {\r\n        sum += arr[i];\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\u003cbr\u003e\r\n\r\n이 과정에서 배열이 새로 생성되는 것은 아니다. 그저 배열 인스턴스를 참조할 수 있는 참조 값만 인자로 전달이 되고, 이 값을 매개변수로 받을 뿐이다. 그리고 다음과 같이 배열의 참조 값을 반환하는 메소드를 정의하는 것도 가능하다.\r\n```java\r\nstatic int[] reIntArr(int x) {\r\n    int[] arr = new int[x];\r\n    return arr;//배열의 참조값을 반환\r\n}\r\n```\r\n\r\n## main 메서드의 매개변수\r\n지금까지 배열에 대해서 알아보았다. 그렇다면 main메소드의 매개변수 선언이 무엇을 의미하는지 알 수 있을 것이다.\r\n\r\n매개변수로 String 배열의 참조변수가 선언되었다. 따라서 다음과 같이 main 메소드를 호출해야 한다. (main 메서드를 직접 호출한다는 가정하에 작성된 코드이다.)\r\n```java\r\nString[] arr = new String []{\"Coffee\", \"Milk\", \"Orange\"};\r\nmain(arr);\r\n```\r\n\u003cbr\u003e\r\n\r\n물론 코드상에서 main메소드를 위와 같이 직접 호출하지는 않는다. 게다가 우리가 main 메소드에 전달할 String 배열을 만들지도 않는다. \r\n\r\n그렇다면 어떻게 String 배열이 만들어지고 또 main 메소드의 인자로 전달되는 것일까?\r\n\r\nString 배열을 구성하는 것도 main 메소드를 호출하는 것도 가상머신에 의해 이뤄지는 일이다. 다만 String 배열을 구성할 문자열은 프로그램 사용자가 전달해야 한다. \r\n\r\n예를 들어서 Simple.class 에 위치한 main 메소드를 다음과 같이 호출한다고 가정해보자. \r\n- C:\\JavaStudy\u003e java Simple\r\n\r\n그러면 String 배열이 다음과 같이 구성이 되어 main 메소드에 전달이 된다. \r\n```java\r\nString[] arr = new String[] {};\r\n```\r\n\u003cbr\u003e\r\n\r\n즉 빈 String 배열이 생성되어 main 메소드의 호출이 이뤄진다. 반면 다음과 같이 실행을 하면, \r\n- C:/JavaStudy\u003e java Simple Coffee Mile Orange\r\n\r\n즉 실행 명령문에 이어서 공백을 구분 기준으로 문자열을 입력하면, 이 내용을 대상으로 String 배열이 구성되고, 이 배열의 참조 값이 전달되면서 main 메소드가 호출이 된다. 그럼 이러한 내용의 확인을 위해 다음 예제를 실행해보자.\r\n```java\r\npublic static void main(String[] args) {\r\n    for(int i=0; i\u003cargs.length; i++) {\r\n        System.out.println(args[i]);\r\n    }\r\n}\r\n```\r\n\u003cbr\u003e\r\n\r\nCoffee, Mile, Orange가 뜨는 것을 볼 수 있을 것이다.(참고로 이클립스에선 javac , java 명령어를 알아서 처리해주기때문에 cmd를 활용하여 명령어를 직접 입력해보는 것이 좋다)\r\n\r\n이 밖에 다차원 배열등이 있지만 설명하는 것보단 직접 해보는 것이 더 효율적인 것 같다.\r\n\r\n- 배열 관련 예제코드\r\n    - [예제 01](https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C01.java)\r\n    - [예제 02](https://github.com/gojaebeom/java_tutorial/blob/master/src/ch10_%EB%B0%B0%EC%97%B4/%EB%B0%B0%EC%97%B4_%EC%98%88%EC%A0%9C02.java)\r\n"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"java14"},"buildId":"Ax74oeIwTnOL-khlokt1j","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script src="https://kit.fontawesome.com/e5541f9036.js" crossorigin="anonymous"></script></body></html>