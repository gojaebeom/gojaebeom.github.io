{"pages":[{"title":"안녕하세요!","text":"추후 작성 예정","link":"/about/index.html"}],"posts":[{"title":"github Blog 만들기 - hexo 설치 및 배포","text":"Hexo 설치저번 글에서 github page를 생성하는 것 까지 해보았습니다. 이어서 Hexo를 설치해 보겠습니다. 다시 Hexo에 대하여 간단히 말하자면 NodeJS 기반으로 만들어진 정적사이트 생성기로써 github page를 좀더 쉽게 관리 및 아름다운 테마를 사용할 수 있게 해줍니다. 먼저 hexo를 설치하기 위해선 nodeJS가 설치되어 있어야 합니다. Node.JS 공식홈페이지 주소 nodejs를 로컬에 설치하면 자동으로 npm도 함께 설치가 되는데 npm은 Node Packaged Manager의 약자로, 많은 사람들이 자바스크립트 패키지들을 만들어 공유하고 그런 오픈소스라이브러리들 쉽게 사용할 수 있게 해주는 프로그램입니다. 우리는 npm을 통해 Hexo를 설치해보겠습니다. 1. hexo 클라이언트 설치 : cmd창이나 터미널을 열고 다음을 입력합니다. 123$ npm install hexo-cli -g//install대신 i를 적어도 됩니다.//-g는 global의 약자로 사용자의 로컬에 전역적으로 설치한다는 뜻 입니다. 2. hexo 폴더 생성 : 핵소 클라이언트를 설치하였다면 이제 hexo 명령어를 사용할 수 있습니다. hexo를 통해 hexo 폴더를 생성해봅시다. 123$ hexo init 폴더명 //폴더명 부분에 원하는 폴더명을 입력하세요$ cd 폴더명 //cd 는 change directory의 약자로 해당 폴더로 이동하게 해줍니다.$ npm install // 폴더내부에 package.json 파일의 내용을 읽어 필요한 모듈들을 인스톨하는 과정입니다. error없이 완료되면 성공입니다! 3. config.yml 수정 : 정적 사이트 생성기 프레임워크들의 공통적인 특징으로 사용자가 쉽게 사이트의 정보를 수정할 수 있는 config.yml이 존재합니다. 해당 파일을 코드에디터등을 활용하여 열어주세요. 123456789# Site 수정 : 제일 상단에 있습니다.# 예시로 적어놓은 것 이니 본인한테맞게 적어주세요title: Hexo # 사이트 제목subtitle: 'hexo 블로그' # 사이트 부제description: 'hexo로 만든 블로그 입니다' # 사이트 설명keywords: hexo, github, github pages, git # 사이트 검색 키워드author: JaeBeom Go # 저자language: ko # 사용 언어timezone: 'Asia/Seoul' # 표준시간 123456789# URL 수정 : 상단 쪽에 있습니다.# 예시로 적어놓은 것 이니 본인한테맞게 적어주세요url: http://example.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true trailing_html: true 123456# Deployment 수정 : 제일 하단에 있습니다.# 예시로 적어놓은 것 이니 본인한테맞게 적어주세요deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 4. hexo 서버 실행시켜 보기 : 기본적인 셋팅은 끝났습니다. 해당 디렉토리 위치의 cmd에서 아래 명령어를 입력해주세요. 12$ hexo server//server는 줄여서 s로 사용가능합니다. 서버가 정상적으로 실행되면 http://localhost:4000에서 블로그를 볼 수 있습니다. 실행시키면 이렇게 우주스러운테마의 홈페이지가 열리면 성공입니다. 5. hexo 블로그파일 github에 배포하기방금 서버를 실행시킨것은 어디까지나 개인 컴퓨터에서만 보이는 서버입니다. 이제 github에 배포하여 다른 사람들도 볼 수 있도록 해봅시다. -정적 웹 리소스 생성하기 12$ hexo generate//줄여서 hexo g 로도 사용가능합니다. -github에 배포하기 123$ hexo deploy//줄여서 hexo -d 로도 사용가능합니다.//위의 웹 리소스 생성과 배포를 'hexo g -d' 로 동시에 할 수 있습니다. 배포시에 ERROR Deployer not found: git 라는 에러가 뜬다면 hexo-deployer-git 이라는 플러그인을 설치해주세요 1$ npm install hexo-deployer-git 설치 후 다시 ‘hexo -d’ 를 통해 github에 배포를 하면 됩니다. 그 후 브라우저에서 https://{username}.github.io 주소 입력시 우주스러운 홈페이지가 뜨면 성공입니다. 이번 글에서는 hexo 설치 및 배포하는 방법까지 알아보았습니다. 하지만 블로그 디자인이 너무 우주스러운게 맘에 들지않아요. hexo에서는 타 정적 웹사이트 프레임워크들과 같이 아름다운 테마들을 제공하는데요. 다음시간에는 테마 적용방법에 대하여 포스팅하겠습니다.","link":"/2020/04/20/hexo/hexo02/"},{"title":"github Blog 만들기 - 글 작성하기","text":"MarkDown이란?github page에서 글을 작성할때는 MarkDown 문법을 사용하여 글을 작성합니다. 마크다운은 일반 텍스트 문서의 양식을 편집하는 문법이에요. README 파일이나 온라인 문서, 혹은 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰입니다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 변환이 가능합니다. 마크다운 문법은 구글을 통해 검색하면, 쉽게 찾아볼 수 있습니다. 간단한 문법이니 사용하기 그리 어렵지 않습니다. 새로운 글 작성우리가 hexo 프레임워크를 이용하여 포스트를 작성한다면, hexo의 명령어로 쉽게 포스트를 생성할 수 있습니다. 1$ hexo new [레이아웃명] [새 포스트 명] 을 통해 파일을 만들 수 있는데요. 여기서 레이아웃명에 post를 쓰면 되지만, 따로 명시하지않아도 default 값이 post로 되어 있어 괜찮습니다. 임시저장 글 작성만약 바로 발행되지 않는 글을 작성하고 싶다면 레이아웃명에 draft를 적어주세요. 1234$ hexo new draft [새 포스트명]// 이후 발행시에는$ hexo publish [포스트명]// 으로 발행할 수 있습니다. 위의 방법은 hexo에서 제공하는 명령어를 사용하여 만드는 방법입니다. 위와 같은 방법으로 파일을 만들었다면 hexo 폴더의 source 폴더에 _posts 폴더 내부에 파일들이 생성되어 있는 것을 알 수 있습니다. 그렇다면 저희가 직접 생성하는 것도 가능하겠네요! _posts 폴더 내부에 원하는 파일명.md 형식으로 파일을 만들어도 똑같이 적용이 됩니다. 다만 명령어로 생성시 hexo에서 사용하는 기본 구조가 잡혀있는데요. 12345---title: hellodate: 2020-04-21 09:06:30tags:--- 직접 생성시에는 상단에 저런 틀을 넣어주셔야합니다. tag 생성하기위의 문법은 마크다운에서 제공하는 것이 아닌 hexo의 템플릿 양식입니다. 글의 제목, 날짜, 태그를 적어줄 수 있게 되어있네요. title과 date는 예시가 있으니 tag를 만드는 방법을 알아봅시다. 12345tags:- example1- example2- example3// 이런식으로 다수의 태그를 지정할 수 있습니다. category 만들기위의 양식에는 입력이 안되어있지만, 저 속성들 뿐만아니라 다른 다양한 속성들을 사용할 수 있습니다. 저희가 작성한 글의 카테고리를 분류하고싶다면 위의 양식에 속성으로 category: 를 만들어주세요. 그리고 다음과 같이 적어주시면 됩니다. 12345category:- 웹 개발//위의 카테고리에서 한번 더 분류하고 싶다면- java //밑에 두번째 분류 속성을 만들어주시면 됩니다. 이렇게 작성하면 웹 개발/ java 이런식으로 만들 수 있습니다. 썸네일 이미지 등록마찬가지로 thumbnail이라는 속성을 추가하여 썸네일 이미지를 등록할 수 있습니다. 1thumbnail: //이부분에 사용할 이미지의 주소를 입력해 주세요. more, excerpt인덱스 페이지에 어느부분까지 표시할 건지에 대한 세팅을 할 수 있습니다. 본문에 아래 주석을 이용하면 됩니다. 123본문이 이렇게 있을 때 여기까지만 인덱스 페이지에 나타납니다.&lt;!-- more --&gt;여기서부턴 인덱스에 안나옵니다. 123여기까지의 내용은 인덱스 페이지에만 나타납니다.&lt;!-- excerpt --&gt;여기서부턴 본문 시작입니다. 지금까지 post를 작성하는 방법에 대하여 알아보았습니다. 물론 이것 말고도 다른 여러가지 기술들이 있지만, 저도 아직 사용한지 얼마 안되어 이것저것 만져보고 이후에 더 추가하도록 하겠습니다. 감사합니다.","link":"/2020/04/21/hexo/hexo05/"},{"title":"github Blog 만들기 - github 페이지 생성","text":"github blog를 만든 계기요즈음 github에 프로젝트를 올리면서 동시에 글을 쓰는 데요. 아무래도 코딩과 동시에 설명을 적으니 주석 때문에 글도 지저분해 보이고 관리가 필요한 것 같더라고요. 그래서 시작한 github에서 제공하는 github pages 블로그 프레임워크 hexo를 이용하여 현재 블로그를 만들었습니다. github pages란?먼저 git과 github에 대한 어느 정도의 지식이 필요합니다. github pages는 github에 저장소의 내용을 (정적인) 웹페이지로 만들어 주는 서비스입니다. 그리고 무료라는 게 큰 장점이지요. github pages : https://pages.github.com/ hexo란?github pages에서 저장소를 웹페이지로써 호스팅할 수 있게 해준다면, 이것을 쉽게 관리하고 사용하게 해주는 프레임워크들이 있습니다. 정적 사이트 생성기(Static site generator)라고도 하며 대중적으로 유명한 hexo, jekyll, hugo 등이 있습니다. 이중의 뭐가 더 좋다~ 라는 건 저도 잘 모르겠습니다. 각 프레임워크들을 만든 프로그래밍언어들이 다른데 hexo는 nodejs, jekyll는 ruby, hugo는 go 언어로 만들어졌다고 합니다. 저는 nodejs를 접해본 경험이 있기 때문에 hexo가 가장 친근하게 다가왔습니다. hexo : https://hexo.io/ 물론 T스토리나 다음 블로거 등등을 사용해도 되지만 github로 블로그에 포스트를 게시하면서 동시에 github의 잔디까지 깔 수 있겠다 싶은게 가장 컷구요.(하지만 블로그에 글을 올리고 github에 업로드하여도 잔디가 채워지지 않았습니다. 이거 어째서입니까..? ) github page 생성본격적으로 github page를 만들어봅시다. 생각보다 엄청 간단한데요, 먼저 github계정이 있다는 전제 하에 github 메인페이지의 우측 상단에 추가버튼 을 누르고 new repository를 눌러주세요. 그리고 repository를 만드는데 다음과 같이 repository명을 example.github.io 를 만들어주세요. example 부분에는 꼭 본인의 아이디명을 적어주셔야 합니다! 마지막으로 하단의 Initialize this repository with a README 박스를 채크해주시고 create repository를 클릭해주세요. Initialize this repository with a README 을 채크할 경우 github에 바로 README 파일과함께 repository를 생성할 수 있습니다. 위의 이미지처럼 {사용자명}/github.io 의 이름으로 repository가 생성되었다면 성공입니다. github page는 생성이 되었지만 아직 기본적인 설정이 하나 더 남았습니다. https://{사용자명}/github.io url로 주소를 치게되면 처음으로 보이는 index페이지를 하나 생성해봅시다. 생성된 repository의 클론주소를 복사해줍니다. 본인의 로컬의 내려 받고싶은 폴더에 cmd나 터미널, git bash 등을 이용하여 ‘git clone {복사한 주소}’ 해줍니다. 로컬에 생성된 폴더에 들어가 index.html 파일을 만들고 hello world 등 예시 문구등을 적어주세요. index.html이 만들어진 git 로컬저장소를 다시 github에 push 해줍니다. 브라우저에서 https://{사용자명}/github.io url 주소를 입력하면 사용자가 정의한 문구가 보이는 페이지가 뜨는 것을 확인 할 수 있습니다. (바로 생성되지 않을 수 도 있어요. 저의 경우엔 3분가량 소요되었던 것 같습니다.) 여기까지 github page를 생성하는 방법을 알아보았습니다. 생각만큼 친절한 글은 아닌것 같아요. 중간중간 빠진 내용도 많아보이죠. 아마 이 글을 보러 오시는 분들이라면 웹에 관한 선행학습이 어느정도 되어있을 것 이라 괜찮다고 생각 하였습니다. 다음 글은 이어서 hexo 설치 및 배포방법에 대하여 포스팅하겠습니다.","link":"/2020/04/17/hexo/hexo01/"},{"title":"github Blog 만들기 - hexo 테마 적용하기","text":"Hexo 테마 설치하기hexo에서는 수많은 테마들이 존재합니다. 본인이 원하는 테마를 찾아 다운받을 수 있습니다. 저는 그중에서도 icarus 라는 테마를 사용하였습니다. icaurs는 material 스러운 디자인으로 저의 취향에 딱 맞는 느낌이더라고요ㅎㅎ 자신이 원하는 테마를 적용할 때는 해당 사이트에서 시키는 방법대로 적용하면 됩니다. 처음 테마를 설치하는 방법은 다 비슷한데 이번 글에서는 icarus theme를 적용하는 방법으로 글을 작성하겠습니다. -테마 다운로드hexo 블로그 디렉토리 위치에서 터미널을 통해 다음 명령어를 입력 해주세요. 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 다운로드가 완료되면 hexo 블로그 폴더에 themes 폴더에 icarus 폴더가 생성된 것을 볼 수 있습니다. -테마 바꾸기처음 hexo를 실행시켰을때 보였던 블로그 테마는 landscape 라는 기본 테마인데요. 이것을 다운받은 icarus 테마로 바꿔주어야 합니다. _config.yml 파일을 열어 다음 부분을 수정해주세요. 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # &lt;- 이부분을 icarus로 바꾸어주세요. -github에 hexo 블로그 재배포하기이전 글에서 다루었던 방법으로 지금까지 수정한 내용을 저장하고 다시 github에 올리면 github page가 바뀐것을 볼 수 있습니다. 다음과 같이 명령어를 입력해주세요. 1$ hexo g -d 아마 ERROR: pakage [패키지명] is not installed. 라는 에러가 몇개 뜨는 것을 볼 수 있는데요. icarus 테마에서 필요로하는 패키지들이 인스톨되지 않았다는 것 입니다. 당황하지말고 로그에 필요하다고 하는 패키지들을 다음과같이 install 해주세요. 1$ npm install [패키지명] 이 이후에 다시 hexo g -d 를 통해 github에 배포 후 사이트에 접속해보세요. icarus테마가 적용되어 보이면 성공입니다!이번 글에서는 hexo 블로그에 icarus 테마를 적용하는 방법에 대하여 알아 보았습니다. 다음 글에서는 icarus 테마의 일부분을 커스터마이징 하는 방법에 대해서 알아보겠습니다.","link":"/2020/04/20/hexo/hexo03/"},{"title":"github Blog 만들기 - icarus 테마 커스터마이징","text":"icarus 테마 살펴보기테마를 적용하고난 이후 기쁜마음에 이곳저곳 살펴보다보면 아래 사진처럼 뭐지 싶은 박스들을 볼 수 있습니다. 저도 github 사이트를 만들때 여러 블로그의 글을 보면서 도움을 받았지만, 사실 상 이 부분이 까다로웠습니다. icarus 테마를 다루는 블로거 분들은 모두 ejs 파일로 만들어진 icarus에 대하여 다루고있지만 본인이 다운받은 파일은 모두 react로 만들어져 있다는 것.. 현재 icarus 공식 github 사이트에 업로드 되어있는 파일은 react로 리팩토링되어 있는 것 같습니다. react를 조금이나마 흥미를 가지고 배운적이 있기에 긍정적인 마음으로 임하였지만 가장 큰 문제는 블로그에서 다루는 커스터마이징 파일은 ejs 또는 pug등의 파일들로 제공되어있는데, react 로 수정된 버전은 방법이 조금 달라진 것 같습니다. 다행이도 어느정도 시간을 두고 삽질을 하니 많은 부분이 해결이 되었습니다. 테마 일부 기능 삭제 / 추가하기위의 사진의 박스들이 어느정도 짐작이 가시나요? 각자 광고, 공유, 후원, 댓글기능 등을 추가할 수 있는 카드들이라는 것 입니다. 일단 광고와 후원은 현재로서는 사용하지 않을 예정이니 기능을 꺼놓도록 하겠습니다. -구글 광고 카드 삭제hexo 블로그 폴더에 있는 config 파일이 아닌 icarus 테마 폴더에 있는 _config.yml 파일을 열어주세요. # Google AdSense unit configurations 주석을 찾아 아래 내용과 같이 수정해주세요. 12345678910# Google AdSense unit configurations# 구글 광고 카드 / 사용시 adsense 앞의 #을 제거해주세요. - # Where should the widget be placed, left sidebar or right sidebar position: left type: #adsense # AdSense client ID client_id: '' # AdSense AD unit ID slot_id: '' -후원 기능 삭제위와 같이 _config.yml 파일을 열어 # Donate plugin configurations 주석 이하 내용을 삭제 또는 주석처리 해주세요. 123456789101112131415161718192021222324252627282930 # Donate plugin configurations# https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Donation/donates: # Alipay donate button configurations - type: alipay # Alipay qrcode image URL qrcode: '' # \"Buy me a coffee\" donate button configurations - type: buymeacoffee # URL to the \"Buy me a coffee\" page url: '' # Patreon donate button configurations - type: patreon # URL to the Patreon page url: '' # Paypal donate button configurations - type: paypal # Paypal business ID or email address business: '' # Currency code currency_code: USD # Wechat donate button configurations - type: wechat # Wechat qrcode image URL qrcode: '' -ShareThis(공유) 기능 연결하기ShareThis는 방문자가 여러 sns 등에 글을 공유할 수 있게 해주는 기능을 서비스 합니다. icarus(리액트 버전)테마 에서는 sharethis를 연결하는 방법이 조금 다릅니다. sharethis 사이트를 방문하여 원하는 공유 버튼을 제출을 하고 코드를 받습니다. 12345&lt;script type='text/javascript' src='blablablabla:example_code' async='async'&gt;&lt;/script&gt; 원래는 위의 코드전체를 ejs 파일에 붙여야 하지만 저희는 저 코드에서 src의 코드부분만 복사를 해둡니다. 위의 src내용은 임시로 작성한 것입니다. 본인이 본인 사이트의 주소를 입력하고 발급을 받아야합니다! 복사한 코드를 install_url 부분에 붙여넣어 줍시다. 123456# Share plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: type: sharethis # URL to the ShareThis share plugin script install_url: '' -Disqus를 사용하여 댓글 기능 셋팅하기Disqus는 소셜 댓글 서비스 입니다. 소셜 댓글 서비스란 소셜미디어(SNS)를 활용한 댓글 시스템으로 페이스북,트위터 와 같은 SNS와 연동해서 댓글을 달 수 있게 만들어 주는 서비스입니다. 소셜 댓글 서비스를 활용하여 댓글을 달면 동시에 해당 댓글이 자신이 연동한 SNS에도 발행이 됩니다. 위의 사이트에 들어가 회원가입을하고 무료버전 서비스를 받아봅시다. 이번에도 ShareThis처럼 다른 테마들과는 다르게 태그 등은 필요하지 않고 ‘short-name’ 값만 가져오면 됩니다. short-name은 회원가입한 ShareThis 아이디에 운영중인 홈페이지 URL을 연결하면 받을 수 있습니다. 그리고 _config.yml의 다음 부분에 short-name의 값을 붙여넣어 주세요. 123456# Comment plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: type: disqus # Disqus shortname shortname: '' # &lt;- 이 부분에 코드 넣기 여기까지 잘 진행이 되었다면 먼저 hexo server 로 확인을 해주시고 적용이 된 것을 확인하였다면 github에 배포해주시면 됩니다. 남은 프로필을 수정하거나 카드의 배치같은 부분도 _config.yml에서 할 수 있으니 자신만의 느낌대로 적용하시면 될 것 같습니다. 다음 글은 hexo 프레임워크에서 post 하는 방법등을 알아보겠습니다.","link":"/2020/04/20/hexo/hexo04/"},{"title":"나비보벳따우","text":"","link":"/2020/04/21/piano/piano-%EB%82%98%EB%B9%84%EB%B3%B4%EB%B2%B3%EB%94%B0%EC%9A%B0/"},{"title":"fate stay night - 운명의 밤","text":"","link":"/2020/04/27/piano/piano-%EC%9A%B4%EB%AA%85%EC%9D%98%20%EB%B0%A4/"},{"title":"짱구는 못말려 - 히로시의 회상","text":"","link":"/2020/04/27/piano/piano-%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98%20%ED%9A%8C%EC%83%81/"},{"title":"기쿠지로의 여름 ost - Summer","text":"","link":"/2020/04/27/piano/piano-summer/"},{"title":"말할 수 없는 비밀 - 쇼팽왈츠(편곡)","text":"","link":"/2020/04/27/piano/piano-%EC%87%BC%ED%8C%BD%EC%99%88%EC%B8%A0/"},{"title":"JAVA - 01. 자바 시작하기","text":"자바(JAVA)란 무엇인가?오늘부터 자바에 대해서 포스팅을 시작하겠다. 자바는 수많은 프로그래밍 언어중 하나이다. 먼저 프로그래밍 언어에 대한 정의를 하려고 한다. 프로그래밍 언어프로그래밍 언어는 컴퓨터를 이용하여 특정 문제를 해결하기 위한 프로그램을 작성하기 위해 사용되는 언어이다. 프로그래밍 언어는 일반적으로 저급언어(기계어, 어셈블리어)와 고급 언어(컴파일 언어) 로 분류할 수 있다. 저급언어(Low Level Language) 기계어 컴퓨터가 직접 이해할 수 있는 언어 0과 1의 2진수 형태로 표현되며 수행시간이 빠르다. 기종마다 기계어가 다르므로 언어의 호환성이 없다. 어셈블리어 기계어와 1:1로 대응되는 기호로 이루어진 언어로, 니모닉(Mnemonic) 언어 라고도 한다. 하드웨어 제어에 주로 사용되며, 언어의 호환성이 없다. 컴퓨터가 직접 이해할 수 없으므로 어셈블리어로 작성된 프로그램은 어셈블러를 사용하여 기계어로 번역해주어야 한다. 고급 언어(High Level Language) 인간이 실생활에서 사용하는 자연어와 비슷한 형태 및 구조를 가지고 있다. 하드웨어에 대한 깊은 지식이 없어도 프로그램 작성과 수정이 용이하다. 컴퓨터가 이해할 수 있는 기계어로 번역하기 위해 컴파일러나 인터프리터가 사용된다. 기계어와 어셈블리어를 제외한 C, JAVA, Python등의 언어가 고급언어에 해당된다. 자바의 탄생과 배경자바는 1991년에 썬 마이크로시스템즈(Sun Microsystems)사 에서 제임스 고슬링(James Gosling)이 고안하였고 그때 당시엔 오크(Oak), 또는 그린(Green) 이라고 불렸다. 오크는 최조에 가전제품에 쓰일 목적으로 개발이 되었지만 인터넷과 웹의 출현으로 오크의 초점은 가전제춤에서 인터넷으로 옮겨지게 되었다고 한다. 이후 1995년 이름을 자바(Java)로 변경하였다. 이전에 C, C++ 등의 언어가 존재했는데, 이 언어들은 직접 메모리를 핸들링하는 특징이 있다. 개발자가 컴퓨터의 메모리를 직접 관리하니 프로그램이 비정상적으로 다운되는 일 등이 생겼다. 그래서 자바는 위와 같은 언어들의 단점을 보안하려고 만들어졌고, 타 언어들과 다르게 자체적으로 메모리를 관리해준다. 2009년 썬 마이크로시스템즈는 오라클에 인수 합병되었고 자바에 대한 권리 및 유지보수 또한 오라클로 넘어가게 되었다. JVM(Java virtual machine)자바는 운영체제에 독립적이다. 이것을 가능하게 하는 것은 JVM이 운영체제 위에서 돌아가기때문이다. 예를 들어 Example.java 파일을 작성하면 javac Example.java 라는 명령어를 통해 Example.class(바이트코드) 파일로 변환할 수 있다. class 확장자 파일은 JVM이 읽을 수 있는 파일이다. 그리고 변환된 Example.class 파일을 java Example(여기서 확장자명은 생략한다) 명령어로 실행할 수 있게 되는 것이다. 이 과정을 다음과 같이 표현할 수 있다. 자바 소스코드(Example.java) -&gt; 자바 컴파일러 -&gt; 바이트코드(Example.class) -&gt; 가상머신(JVM) -&gt; 운영체제(윈도우 or 리눅스) 에서 실행 가능 컴파일이란?프로그래밍 언어를 컴퓨터가 알 수 있는 기계어로 바꾸는 행위. 컴파일러(Compiler)는 기계어로 바꾸어주는 프로그램을 말한다.(자바를 설치하면 기본적으로 자바 컴파일러도 설치된다) 자바의 특징이식성이 높은 언어이다이식성이란 서로 다른 실행 환경을 가진 시스템 간에 프로그램을 옮겨 실행할 수 있는 것을 말한다. 자바 언어로 개발된 프로그램은 소스 파일을 수정하지 않아도, 자바 실행 환경(JRE)이 설치되어 있는 모든 운영 체제에서 실행 가능하다. 객체 지향 언어이다객체 지향 프로그래밍(Object Oriented Programming, OOP)이란 프로그램을 개발하는 방법론중 하나이다. 말 그대로 객체를 만들어 상호작용하는 방식으로 프로그래밍을 한다. 또한 객체 지향 언어가 가져야 할 캡슐화, 상속, 다형성 기능을 완벽하게 지원한다. 메모리를 자동으로 관리한다위의 자바의 탄생과 배경에서 설명했듯이 C 또는 C++이 메모리 관리를 위해 개발자가 직접 코드를 작성해야 하는 반면, 자바는 개발자가 메모리에 직접 접근할 수 없으며 자바가 직접 메모리를 관리한다. 멀티스레드를 쉽게 구현할 수 있다자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다. 함수 지향적인 코딩을 지원한다함수적 프로그래밍은 대용량의 데이터 병렬 처리와 이벤트 지향 프로그래밍을 위해 적합하기 때문에 최근 들어 다시 주목받고 있다. 자바는 이 함수적 프로그래밍을 위해 람다식을 자바 8부터 지원한다. 람다식을 사용하면 컬렉션 요소를 필터링, 매핑, 집계 처리하는게 쉬워지고, 코드가 매우 간결해진다는 장점이 있다. 동적 로딩(Dynamic Loading)을 지원한다애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다. 오픈소스 라이브러리가 풍부하다자바는 오픈소스 언어이기 때문에 자바 프로그램에서 사용하는 라이브러리 또한 오픈소스가 많다. 오픈소스 라이브러리를 사용하면 개발 시간을 단축하면서 안정성이 높은 애플리케이션을 쉽게 개발할 수 있다. C나 C++에 비해 속도가 느리다 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다. 그러나 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다. 예외처리가 불편하다자바는 다른 언어들과 달리 프로그램 실행 시 발생할 수 있는 예외(Exception)들을 개발자가 직접 선언하여 처리해야 한다. 그렇지 않으면 아예 컴파일이 되지 않는다.","link":"/2020/04/21/java%20%EA%B8%B0%EC%B4%88/java01-%EC%9E%90%EB%B0%94%EB%9E%80/"},{"title":"JAVA - 05. 제어문","text":"조건문이란?조건식을 만족하느냐 아니냐에 따라 프로그램의 실행을 제어할 수 있는 문법이다. 이 때 조건식은 true나 false 같은 boolean형 타입을 반환할 수 있는 식을 말한다. 자바 문법 중에서 조건문은 if, switch, 조건연산자등이 있다. if문특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 키워드 if를 사용하면 된다. 그리고 두개의 문장 중 조건에 따라 하나만 실행하고 싶다면 거기에 else를 더 추가하면 된다. else는 if문 소괄호의 조건이 참이 아니라면 실행되는 곳이다. 1234567891011//if문 예제int num1 = 1;int num2 = 2;if(num1 &lt; num2) { //조건 true 시 실행되는 영역 System.out.println(\"참입니다\");}else { //조건 false 시 실행되는 영역 System.out.println(\"거짓입니다\");} if ~ else if 문은 2개 이상의 조건을 주고싶을 때 사용할 수 있는 방법이다. 밑의 예제를 보자. 12345678910//if ~ else if문 예제if(num1 &lt; num2) { System.out.println(\"num1보다 num2가 큽니다.\");}else if(num1 &gt; num2) { System.out.println(\"num2보다 num1이 큽니다.\");}else if(num1 == num2) { System.out.println(\"num1과 num2는 같습니다.\");}else { System.out.println(\"셋다 해당되지 않습니다.\");} 조건 연산자(삼항 연산자)조건 연산자는 피연산자가 세 개인 연산자이다. 이러한 조건 연산자는 간단한 if~else문을 대체하는 용도로 주로 사용된다. 밑의 예제를 보자. 12345//조건 연산자 예제int num1 = 10;int num2 = 20;int result = (false) ? num1 : num2;System.out.println(\"결과 : \"+ result); 변수 num5 는 선언과 동시에 조건연산자에 의한 값을 할당한다. ()안의 조건이 참이면 num3이 저장될 것이고 , 거짓이라면 num4가 저장될 것 이다. 하지만 임의적으로 false라는 값을 줌으로써 변수 num5에는 num4의 값, 즉 20이 저장되는것을 알 수 있다. switch문조건에 따라 실행할 문장을 구분한다는 측면에서 if문과 유사하다. else if가 많이 들어가는 상황에서는 switch문이 더 좋은 선택이 될 수 있다. 밑의 예제를 보자. 123456789101112131415public static void main(String[] args) { int num1 = 10; String animal = \"고양이\"; switch(animal) { case \"강아지\": System.out.println(\"강아지가 맞습니다\"); case \"고양이\": System.out.println(\"고양이가 맞습니다.\"); case \"고라니\": System.out.println(\"고라니가 맞습니다.\"); default : System.out.println(\"해당하는 동물이 없습니다.\");} 레이블(Label) 위의 switch 내부에 존재하는 키워드 case와 default를 가리켜 레이블이라고 한다. 레이블 case와 default는 코드상에서 위치를 표시하기 위해 사용된다. case는 switch 의 조건과 같은 타입을 가져야하고 같은 결과 값일 경우 그 case 이후의 값들이 출력이된다. 이것은 이후에 나오는 break문으로 제어할 수 있다. default는 case에서 switch와 같은 조건의 값이 없다면 실행되는 구문이다. 그리고 case와 default를 보면 들여쓰기가 되어있지 않다. 이는 책에 위치를 표시하는 레이블과 그 성격이 같다. 그리고 레이블은 책을 펼치기 전에 보여야 한다. 이와 마찬가지로 case와 default도 조금이라도 잘 보이도록 들여쓰기 대상에서 제외하는 것이 일반적이다. 일단 위의 결과를 보게되면 switch의 참거짓을 판단하는 매개변수로 animal이라는 변수를 주었다. 이 변수에 할당된 값은 ‘고양이’ 이다. 당연히 콘솔에 고양이가 맞습니다. 라고 찍힐 것이라고 예상할 수 있지만 결과는 고양이가 맞습니다. 이후에 나오는 모든 조건의 결과 고양이가 맞습니다.고라니가 맞습니다.해당하는 동물이 없습니다. 가 찍힌다. 이는 break 라는 키워드로 case의 실행구문이 끝난 이후 사용해 주어야 하위 case들이 실행 되는 것을 막을 수 있다. 밑의 예제를 보자. 12345678910111213switch(animal) {case \"고양이\": System.out.println(\"고양이가 맞습니다.\"); break;case \"강아지\": System.out.println(\"강아지가 맞습니다.\"); break;case \"고라니\": System.out.println(\"고라니가 맞습니다.\"); break;default : System.out.println(\"해당하는 동물이 없습니다.\");} 위의 switch문과는 다르게 각 case가 끝나는 부분에 break가 추가 되었다. 그리고 결과로는 고양이가 맞습니다. 이후의 출력은 사라졌다. 즉 if, else처럼 해당하는 조건에 맞는 결과값만이 출력이 되는 것을 확인 할 수 있다. 이는 switch문의 일반적인 사용 모델이다. 반복문이란?반복문은 어떤 작업이 반복적으로 수행되도록 할 때 사용된다. while, do~while, for문등을 예로 들 수 있다. while문먼저 while 문 예제를 살펴보자. 1234567891011public static void main(String[] args) { int num = 0; //While문 while(num &lt; 5) { System.out.println(\"I Like Java\"); num++; }} 위의 결과는 I Like Java가 5번 출력되는 것을 알 수 있다. while문의 소괄호에는 반복의 조건을 명시한다. true 또는 false가 와야 하므로 이를 반환하는 연산이 오게 된다. 그리고 그 조건이 true를 반환하는 동안에는 횟수에 상관없이 while문의 중괄호가 반복 실행되는데 , 다음의 패턴으로 반복이 된다. 먼저 조건검사 그리고 결과가 true이면 중괄호 영역 실행 반면에 밑에 예제에서 다루는 do ~ while문은 다음의 패턴으로 진행한다. 먼저 중괄호 영역 실행 그리고 조건 검사 후 결과가 true이면 반복 결정밑의 예제를 확인해 보자. 1234567int num2 = 0;//do_while문do { System.out.println(\"I Like Java \" + num2); num2++;}while(num2 &lt; 5); 위 예제는 이전의 while문을 do-while로 바꾼것 뿐이다. 따라서 실행결과는 동일하다. 보는것처럼 while문으로 작성된 문장은 do-while로도 작성가능한 경우가 대부분다. 따라서 “조건에 따른 반복이 필요하다. 그런데 반드시 한 번은 실행을 해야 한다.” 라는 경우에는 do~while문을 사용하는 것이 괜찮다. 이 이외의 경우에는 while문 또는 이어서 소개하는 for문을 사용하는 것이 바람직하다. 그래야 선택하는 반복문에 더 많은 의미를 부여할 수 있다. for문이전에 다루었던 while문에서 했던 예제들은 거의 반복하는 값이 정해져있었다. 이처럼 ‘반복의 횟수가 정해져 있는 상황’ 에서는 for문을 이용해서 다음과 같이 작성하는 것이 더 간결하고 뜻도 더 잘 통한다. 밑의 예제를 보자. 1234567//for문 예제public static void main(String[] args) { for(int i=0; i&lt;5; i++) { System.out.println(\"I Love Java\"); }} 위 예제에서 실행 흐름을 보자면 변수의 선언및 초기화 반복 조건이 true인지 확인 반복 영역을 실행 (반복 조건이 true이면) 변수의 값 증가 그리고 그 이후 두번째 반복부터는 첫번째 조건인 변수의 선언및 초기화 부분은 지나치게 된다. break 와 continuebreak 문은 앞서 switch문을 빠져나가는 용도로 다루었었는데, 마찬가지로 반복문을 빠져나가는 용도로도 사용된다.보통 if문과 함께 사용되어 특정 조건이 만족될 때, 이를 감싸는 반복문을 빠져나가도록 구성이 된다. break는 이전에 다루던 것과 별 차이가 없기 때문에 따로 예제를 다루지 않는다. continue문은 break문과 혼동하기 쉬워서 주의가 필요하다. 우선 continue는 반복문의 탈출과 거리가 멀다. 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건 검사 부분으로 이동시킨다. 밑의 예제를 보자. 1234567891011public static void main(String[] args){ int n = 0; while((n++)&lt;5) {//while 하단부에서 증가시켜줬던 구문을 이런식으로 작성할 수 있다. if(n == 1) continue; System.out.println(\"I Like Java\"); }} 위의 구문을 실행시켜보면 총 4번 실행 되는 것을 알 수 있다. 0~4까지 총 5번 출력되는 것이 맞는 것 이라고 생각 할 수 있는데, 이유는 조건에 따른 continue 구문이 실행하게 되면 그 이후의 문장은 무시하고 다시 반복문의 조건 검사로 이동하게 되기때문이다. 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.","link":"/2020/04/22/java%20%EA%B8%B0%EC%B4%88/java05-%EC%A0%9C%EC%96%B4%EB%AC%B8/"},{"title":"JAVA - 02. 변수와 자료형","text":"변수(Variable)란? 변수란 데이터의 저장과 참조를 위해 ‘할당된 메모리 공간’ 에 붙인 이름을 말한다. 변하는 값을 프로그램에서 나타내는 방법 변수 선언변수를 선언하는 것은 해당 자료형의 크기만큼의 메모리를 사용하겠다는 뜻 이다. 메모리의 위치를 변수명으로 참조한다. 변수는 다음과 같은 방식으로 선언할 수 있다. 12345678910111213141516171819202122[자료형] [변수명];//exampleint number;// tip.선언 이후 값을 할당하는 방법은 다음과 같이 할 수 있다.number = 10;// tip.선언과 동시에 값을 할당할 수 있는데, 이것을 `선언 및 초기화` 라고 한다.int age = 26; // tip.선언 되어있는 변수 이름과 이름이 중복될 수 없다.(변수의 스코프에 한함)int age; // 에러// tip.만약 변수를 선언만 하고 값을 할당하지 않았다면 사용될 수 없다.int testNum;System.out.println(testNum); // 에러// tip.동일한 자료형에 한해서 다수의 선언이 가능하다.int number1, number2, number3;// tip.다수의 선언과 동시에 값의 할당도 가능하다.int number4 = 10, number5 = 20; 식별자 규칙자바는 대소문자를 구분한다. 따라서 Num1 과 num1은 서로 다른 이름으로 인식된다. 때문에 자료형 int를 대신하여 INT를 사용할 수 없고 변수의 이름을 짓는데 다음과 같은 제약사항이 존재한다. 영문자나 숫자를 사용한다. 단 숫자로 시작할 수 없다. 특수문자중에서는 _와 $를 사용할 수 있다.(보통 사용할 경우 변수명 앞에 붙인다) 예약어는 사용할 수 없다.(ex&gt; int, double, char..) 변수는 그 쓰임에 맞는 이름으로 만드는 것이 가독성에 좋다. 일반적인 관례 변수는 소문자의 명사를 사용 클래스 이름은 대문자의 명사를 사용 메서드 이름은 소문자의 동사를 사용 두단어 이상 사용할 경우 카멜 케이스(Camel Case)로 표기(ex&gt; helloWorld, intNum..) 상수는 대문자의 명사(두 단어 이상 사용할 경우 _(언더바)로 연결) 자료형앞서 int 라는 키워드를 사용하여 변수를 만들었는데, 이러한 키워드를 가리켜 자료형 이라고 한다. 그리고 자바에서는 다양한 자료형을 제공한다. 자바의 자료형은 크게 기본형(primitive type)과 참조형(referene type)으로 나뉜다. 기본형(primitive type) 자바언어에서 기본적으로 제공해주는 자료형 메모리의 크기가 정해져있다. 정수, 실수, 문자, 논리 형이 있다. 참조형(referene type) JDK(java development kit)에서 제공되는 클래스와 프로그래머가 정의하는 클래스 클래스에 따라 사용되는 크기가 다르다. String, 그리고 사용자가 만든 클래스 등이 포함된다. 기본 자료형 종류 자료형 데이터 크기 표현 가능 범위 boolean 참과 거짓 1바이트 true, false char 문자 2바이트 유니코드 문자 byte 정수 1바이트 -128~127 short 정수 2바이트 -32,768~32,767 int 정수 4바이트 -2,147,483,648 ~ 2,147,483,647 long 정수 8바이트 -9,223,372,036,854,775,808 ~ 엄청크다.. float 실수 4바이트 단정도 실수형 (유효 자리는 7 정도임) double 실수 8바이트 배정도 실수형 (유효 자리는 15정도) 정수 자료형자바는 정수형 연산을 진행할 때 int형(4 byte)을 기본으로 한다. 12345// IntegerTest.javapublic static void main(String[] args){ int iNum = 2147483648; //에러 , 2147483647까지 표현 가능 long lNum = 2147483648;//에러} 위의 예제의 두 코드들은 에러가 난다. int 형 변수 iNum 은 4byte에 초과되는 값을 담았기 때문에 에러가 나는것은 이해할 수 있다. 하지만 int형에 담을 수 없는 값이기에 long형 변수에 할당했는데도 오류가 나고있다. 위에 설명했듯이 자바는 정수형 연산을 4byte를 기본으로 하기때문에 위의 long lNum = 2147483648 코드의 숫자들을 4byte에 담으려고 하니 에러가 나는 것 이다. 이럴때 형변환 이라는 것을 해주어야 하는데 다음과 같이 해결할 수 있다. 1234// IntegerTest.javapublic static void main(String[] args){ long num = 2147483648L;} 뒤에 l 또는 L 을 붙여줌으로써 형변환할 수 있다. 형변환은 다른글에서 자세히 다루도록 하겠다. 실수 자료형실수 자료형은 연산을 진행할 때 double형(8 byte)을 기본으로 한다. 123456//DoubleTest.javapublic static void main(String[] args){ float fNum1 = 0.1; // 에러 float fNum2 = 0.1F;} 위의 경우와 비슷한 예제이다. 실수는 double을 기본으로 연산을 하기때문에 double보다 낮은 float에 값을 할당 시 위 예제와 같이 f 또는 F를 값 뒤에 붙여 주어야 한다. 자바에서 정수형은 주로 int가 많이 사용이되고 실수형은 double이 많이 사용된다. 문자 자료형 내부적으로는 비트의 조합으로 표현된다. 인코딩 -&gt; 각 문자에 따른 특징인 숫자 값(코드 값)을 부여 디코딩 -&gt; 숫자값을 원래 문자로 반환 123456789101112131415161718// CharacterTest.javapublic static void main(String[] srg) { char ch = 'A'; System.out.println(ch); //A System.out.println((int)ch); //65 int iCh = 66; System.out.println(iCh); //66 System.out.println((char)iCh); //B //char ch2 = -66; 음수값은 들어갈 수 없음 char hangle1 = '\\uAC00'; //유니코드 넣는 방법 System.out.println(hangle1); char hangle2 = '가'; //물론 이렇게 표현할 수 있다. System.out.println(hangle2);} 문자의 표현에 대한 약속을 가리켜 ‘문자셋(Character Set)’ 이라고 한다. 이러한 문자 셋의 설계는 지역 및 국가별로 각각 이루어져 그 수가 다양하다. 때문에 데이터를 주고받거나 여러 국가의 언어를 동시에 표현하는 상황에서는 문제가 되는데, 그래서 모든 나라의 문자를 수용하여 전 세계적으로 사용할 수 있는 문자 셋을 설계하게 되었다. 이를 가리켜 ‘유니코드(Unicode)’라고 한다. 문자 세트 아스키 : 1byte로 영문자, 숫자, 특수문자등을 표현 유니코드 : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 (UTF-8, UTF-16이 대표적이다) 논리 자료형논리 자료형은 boolean이라는 키워드를 사용하여 선언한다. 1byte의 크기를 사용하며 보통 참과 거짓을 구분할 때 많이 사용된다. 12345//BooleanTest.javapublic static void main(String[] args){ boolean isMarried = false; System.out.println(isMarried);// fasle} 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.","link":"/2020/04/21/java%20%EA%B8%B0%EC%B4%88/java02-%EB%B3%80%EC%88%98%EC%99%80%20%EC%9E%90%EB%A3%8C%ED%98%95/"},{"title":"JAVA - 03. 상수와 형변환","text":"상수(Constant)란? 변하지 않는 수를 말한다. 상수 선언자바의 일반적인 상수는 변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 상수는 다음과 같은 특징이 있다. 값을 딱 한 번만 할당할 수 있다. 한 번 할당된 값은 변경이 불가능하다. 1234567891011// tip.상수의 선언final int NUM;// tip.선언된 상수에 값 할당NUM = 10;// tip.그 이후로 값의 변경은 불가능하다NUM = 5; // 에러// tip.변수와 마찬가지로 선언과 동시에 초기화가 가능하다.final int FINAL_NUMBER = 10; 상수의 관례그리고 위와같이 관례상 상수의 이름은 다음 두가지 사항을 지켜서 짓는다. 상수의 이름은 모두 대문자로 짓는다. 이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다. 리터럴(literal)프로그램에서 사용하는 모든 숫자, 문자, 논리 값 등을 가리켜 리터럴이라고 한다. 모든 리터럴(리터럴 상수라고도 한다)들은 상수 풀(Constant Pool)이라는 곳에 저장되어 있다. 12int num = 100; //right value에 해당하는 100이 리터럴이다.char ch = 'A'; //마찬가지로 A도 리터럴 이다. 리터럴(숫자, 문자, 논리 값) –로딩–&gt; Constant Pool(10, ‘A’, true) –대입, 복사–&gt; 변수 형변환서로 다른 자료형의 값이 대입이 되는 경우 형변환이 일어난다. byte -&gt; short -&gt; int &amp;&amp; char -&gt; long -&gt; float -&gt; double 일반적으로 위와 같이 화살표의 방향대로 대입이 되면 묵시적인 형변환이 일어나고 아닐 경우 직접 명시적인 형변환을 해주어야 한다. 묵시적 형 변환(Implicit Type Conversion) 작은 수에서 큰 수로 대입 덜 정밀한 수에서 더 정밀한 수로 대입(정수에서 실수) 123456789101112//ImplicitConterSionTest.javapublic static void main(String[] args) { //정수 byte bNum = 10; short sNum = bNum; int iNum = sNum; long lNum = iNum; //실수 float fNum = lNum; double dNum = fNum;} 위의 예제처럼 크기가 작은 수에서 큰 타입 순서로 대입을 할경우 자동적인 형변환이 일어난다. 명시적 형 변환(Explicit Type Conversion) 변환되는 자료형을 명시(타입 캐스팅) 이에 따른 자료의 손실이 발생할 수 있다. 123456789101112131415161718//ExplicitConterSionTest.javapublic static void main(String[] args) { // 예제 1 int iNum = 1000; byte bNum = (byte)iNum; //형변환을 억지로 하면 데이터 손실을 불러올 수 있다. System.out.println(bNum);//-24 // 예제 2 double dNum = 1.2; float fNum = 0.9F; int iNum1 = (int)dNum + (int)fNum; //1 int iNum2 = (int)(dNum + fNum); //2 System.out.println(iNum1); System.out.println(iNum2);} 예제 1은 int형 변수에 1000의 값을 할당하였다. 그리고 byte에게 대입하려고 한다. 하지만 byte는 int보다 크기가 작음으로 (byte) 와같이 프로그래머가 직접 byte형으로 변환 하겠다고 명시해주어야한다. 그리고 명시적인 형변환을 하게 되면 데이터가 손실될 수 도 있다. 예제 1의 경우 byte가 담을 수 있는 크기를 초과하여 값이 잘려 -24가 출력 되는 것을 알 수 있다. 예제 2의 핵심은 두개의 실수를 더하여 정수형 변수에 대입하려고 하는 것 이다. iNum1의 경우엔 각 dNum, fNum 의 값을 형변환 하고 연산을 진행한다. 즉 각자의 값은 소숫점이 잘려나가 1, 0이된다. 결국 1+0의 연산을 통해 1이라는 값이 iNum1에 대입이 된다. iNum2의 경우 먼저 변수의 값이 연산을 진행 한 이후 타입캐스팅이 일어난다 1.2 + 0.9 = 2.1이 되고 그 이후 소숫점이 잘려 2라는 값이 대입이 되는 것을 알 수 있다. 이것은 이 다음에 다룰 연산자에서 연산 우선순위를 통해 알 수 있다. 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.","link":"/2020/04/22/java%20%EA%B8%B0%EC%B4%88/java03-%EC%83%81%EC%88%98%EC%99%80%20%ED%98%95%EB%B3%80%ED%99%98/"},{"title":"JAVA - 04. 연산자","text":"연산자란?어떠한 기능 또는 어떤 대상체에 계산과 같은 처리를 수행하는 문자 또는 기호를 연산자라 한다. Java에서의 연산자는 크게 단항, 이항, 삼항, 대입 연산자로 나뉘며, 이항 연산자는 산술, 비교, 논리 연산자로 나뉠 수 있다. 연산자(operator) : 어떠한 기능을 수행하는 기호 (+, -, *, / 등) 피연산자(operand) : 연산자의 작업 대상 (변수, 상수, 수식 등) 연산자의 종류산술 연산자 (+, -, *, /, %)우리가 평소에 자주 사용하는 연산이다. 1234567//사용 예제int a = 10, b =20;System.out.println(a + b); //더하기System.out.println(a - b); //빼기System.out.println(a * b); //곱하기System.out.println(a / b); //나누기System.out.println(a % b); //나눈 나머지 대입 연산자(=) 오른쪽에서 왼쪽으로 할당 변수끼리 할당 가능 변수에 값이 존재하더라도 다른 값을 할당하면 마지막 할당된 값이 할당 연산자중에 우선순위가 제일 낮다 123int a = 0, b = 1;a = b; // 변수의 자료형이 같다면 할당 가능 : a 값이 1로 updatea = 20; // 당연히 자료형에 맞는 타입의 값이면 할당 가능 복합 대입 연산자(+=, -=, *=, /=, %=)연산자와 대입 연산자를 결합한 연산 후 대입 연산 12345678910111213141516171819202122232425//복합 대입 연산자// +=a += b; // a = a+b// -=a -= b; // a = a-b// *=a *= b; // a = a*b// /=a /= b; // a = a/b// %=a %= b; // a = a%b;// &amp;=a &amp;= b; // a = a&amp;b;// |=a |= b; // a = a | b;// ^=a ^= b; // a = a ^ b; 형변환 연산자((DataType))자동형변환의 경우 알아서 형변환이 일어나지만, 명시적으로 형변환을 필요로 할 때 사용가능하다. 12345int iNum = 20;short sNum = (short)iNum;double dNum = 5.5;float fNum = (float)dNum; 증감 연산자(++, - -) 증가 연산자(++) : 피연산자의 값을 1 증가시킨다. 감소 연산자(-­ -­) : 피연산자의 값을 1 감소시킨다. 증감연산자는 피연산자의 앞 또는 뒤에 붙일 수 있는데 그에따라 차이점을 보인다. 1234567891011//전위 형 : 값이 참조되기 전에 증가시키거나 감소시킨다.int a = 0;System.out.println(++a); //1//후위 형 : 값이 참조되고 난 이후 증가시키거나 감소시킨다.int b = 0;System.out.println(b++); //0//이 이후에 값이 증가 된상태System.out.println(b); //1 비교 연산자(&gt;, &gt;=, &lt;, &lt;=, ==, !=, instanceof)비교 연산자는 제어문의 조건문이나 반복문에 자주 쓰인다. 12345678910//사용 예시int a = 0 , b = 1;if(a &lt; b) // a 보다 b가 크다 : 참if(a &lt;= b) // a 보다 b가 크거나 같다 : 참if(a &gt; b) // a 가 b보다 크다 : 거짓if(a &gt;= b) // a 가 b보다 크거나 같다 : 거짓if(a == b) // a 와 b가 같다 : 거짓Person p = new Person();System.out.println(p instanceof Person); // p가 Person의 객체인지 참, 거짓으로 구분 : 참 비트 연산자(&amp;, |, ^, ~)데이터를 비트단위로 연산할 수 있는 연산자로 정수형또는 논리형에만 사용할 수 있다. 123456789System.out.println(0&amp;1); // 비트 단위의 논리곱(AND)System.out.println(5|1); // 비트 단위의 논리합(OR)System.out.println(0^1); // 비트 단위의 배타적 논리합(AND)System.out.println(~1); // 비트 단위의 보수(부정)System.out.println(0&gt;&gt;2); // 0을 2 만큼 오른쪽으로 이동시킴. 이동한 만큼의 왼쪽 비트는 부호 확장이 발생System.out.println(0&gt;&gt;&gt;1); // 부호 확장이 없고 이동한 만큼의 왼쪽 비트는 항상 0 으로 채운다System.out.println(true&amp;true);System.out.println(true^false); 논리 연산자(&amp;&amp;, ||, !)비트 논리 연산자의 경우 연산 대상이 정수형과 논리형에 모두 가능하지만, 논리 연산자의 경우 논리형에만 적용할 수 있다. 1234567System.out.println(true &amp;&amp; true); //trueSystem.out.println(true &amp;&amp; false); //falseSystem.out.println(true || true); //trueSystem.out.println(true || false); //trueSystem.out.println(false || false);//falseSystem.out.println(!true);//falseSystem.out.println(!false;//true 삼항 연산자( ? : )조건을 평가해서 소괄호 값이 참, 거짓이냐에 따라 수식1, 수식2 값을 대입한다. 12345//조건 연산자 예제int num1 = 10;int num2 = 20;int result = (false) ? num1 : num2;System.out.println(\"결과 : \"+ result); 연산자 우선순위 우선순위 연산자 1 () [] . 2 ++ , - - , ~ , ! 3 * , / , % 4 + , - 5 &gt;&gt; , &gt;&gt;&gt; , &lt;&lt; 6 &gt; , &gt;= , &lt; , &lt;= 7 == , != 8 &amp; 9 ^ 10 ｜ 11 &amp;&amp; 12 ｜｜ 13 a ? b : c 14 = tip. 우선순위에 상관 없이 ()를 사용하여 우선순위를 지정할 수 있다 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.","link":"/2020/04/22/java%20%EA%B8%B0%EC%B4%88/java04-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"title":"JAVA - 07. 함수와 메소드","text":"함수(Function)란?프로그래밍에서 함수는 하나의 기능을 수행하는 코드의 단위이다. 이전의 객체지향 프로그래밍이 무엇인가 다루었을 때 객체의 속성은 변수, 기능은 메소드라고 하였다. 메소드와 함수는 무슨 차이일까? 메소드(Method)란?클래스 내부에서 클래스의 기능을 갖는 함수를 메소드 라 한다. 즉 함수가 좀더 포괄적인 개념이다. 하지만 서로 기능적인 차이는 거의 없다. 단지 자바 프로그래밍을 할 때 우리는 function 보다 method라는 단어를 더 많이 접하게 될 것이다. 메소드 정의하기클래스를 정의할 때는 앞의 문자를 대문자로 하는 것이 일반적인 관례였다. 반대로 변수와 메소드명을 정의할 때는 소문자로 시작하고, 두 단어 이상이 사용되면 카멜케이스를 사용하는 것이 일반적인 관례이다. 1234//메소드 정의하기반환형 메소드명 (매개변수){몸통} ˇˇˇvoid func(int x){...} 메소드는 위와 같이 반환형, 메소드명, 매개변수, 그리고 구현부로 이루어져있다. void는 반환값이 없을때 사용하는 키워드이다. 그리고 매개변수는 사용함에 따라 선언 유무는 상관이 없고, 다수의 변수를 선언해도 상관 없다. 다음 예제를 보자. 1234567891011121314//반환값이 없고 매개변수가 없는 메소드 정의void func1(){...}//반환값이 없고 매개변수가 하나 있는 메소드 정의void func2(int a){...}//반환값이 없고 매개변수가 두개 있는 메소드의 정의void func3(int a, int b){...}//물론 매개변수는 두개이상도 가능하다.void func4(int a, int b, int c, int d){...}//매개변수의 타입은 필요에 따라 원하는 타입으로 선언할 수 있다.void func5(int a, String str, double d){...} 그리고 메소드의 기능을 실행한뒤에 결과 값을 다른곳으로 반환하고 싶다면 아래와 같이 할 수 있다. 1234int addNum(){ int num = 10; return num;} 반환형에 int를 명시해줬기 때문에 return되는 값은 int형이여야 한다. 물론 다른형으로도 명시가 가능하다. 메소드의 return메소드의 return은 값을 반환함과 동시에 메소드를 종료시킴을 의미한다. 다음으로 매개변수를 받아 가공하여 반환 하는 메소드의 예제를 보자. 123int addNum(int a, int b){ return a + b;} 위 메소드는 매개변수로 두 정수 값을 받아 더해서 반환하는 함수이다. 그리고 위 예제들의 모든 함수들은 정의만 하였고 사용되지 않았다. 메소드 사용하기메소드는 메소드의 이름으로 호출 할 수 있다. 1234567891011121314public static int addNum(int a, int b){ return a + b;}public static void helloWorld(){ System.out.println(\"Hello~ world\");}public static void main(String[] args){ helloWorld(); int result = addNum(10, 20); System.out.println(result);} 메소드의 반환형 앞에 붙은 public과 static은 신경쓰지말자. 이것은 이후에 배울 접근 제어자와, static을 통해 알 수 있다. 이전에 클래스를 사용할 때도 main 메소드 내부에서 실행한 것을 알 수 있다. 이는 자바 프로그램이 main 이라는 이름의 메소드에서부터 시작하는것을 약속으로 한다. 위의 addNum 그리고 helloworld 메소드는 메인 메소드에서 호출하였다. helloworld 메소드의 경우 내부적으로 println를 통해 문자열을 출력하는 일을 한다. addNum의 경우 int형 인자값을 두개 받기로 약속하였기 때문에 정수값 두개를 넘겨주고 내부에서 사칙연산을 수행 이후 값을 반환하고 있다. 그리고 반환값이 int형이기 때문에 int 타입의 변수에 값으로 할당할 수 있게 된다. 이후 그 값을 잘 출력하는 것을 볼 수 있다. 메소드와 메모리 스택(Stack)이전 클래스의 인스턴트 부분에서 메모리 구조에 대해 간략하게 소개한 적이 있다. 인스턴스는 메모리의 힙이라는 곳에 생성된다고 하였다. 반대로 메소드나, 메소드 내부에서 사용되는 변수(지역변수)들은 스택이라는 곳에 저장된다. Last In First Out (LIFO)스택은 후입선출의 방법으로 메모리를 관리한다. 즉 나중에 들어온 값이 가장 먼저 나가게 되는 것 이다. 예를 들어보자. 12345678public static void main(String[] args){ func1(); func2();}public static void func1(){...}public static void func2(){...} 위 예제는 메인함수가 먼저 실행이되고 메인 함수에서 func1 과 func2함수를 차례대로 호출하고 있다. 먼저 메인 메소드가 실행이 되면 다음과 같이 스택에 메인함수가 생성이 된다. 그리고 메인메서드가 func1 메소드를 호출한다. 위의 메소드는 내부적으로 기능을 완료하고 종료한다.그 이후 func2 메소드를 호출한다. 메소드는 이와같이 후입선출의 개념으로 스택영역에 저장되고, 소멸하게 된다.","link":"/2020/04/27/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-07-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/"},{"title":"JAVA - 06. 객체지향 프로그래밍과 클래스","text":"객체지향 프로그래밍(Object Oriented Programming )이란?객체지향은 프로그램 설계방법론중 하나 이다. 프로그램을 수많은 ‘객체’라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체(Object) 란?객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것을 의미한다. 클래스(Class) 란?클래스는 객체지향 프로그래밍의 가장 기본적인 요소이며, ‘속성(변수)과 기능(메소드)’의 묶음으로 나뉜다. 그리고 객체를 생성하기 위한 설계도라고 할 수 있다. 클래스와 객체가 햇갈리는 부분이 있을 수 있는데 클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다. 다음 예제를 보자. 클래스 정의하기12345678910public class Student { //맴버변수 int studentId; String studentName; //메소드 public void showStudentInfo(){ //학생 정보 출력 }} 위 예제는 학생을 추상화 한 Student 클래스의 정의 이다. 클래스는 정의 할때 다음과 같은 규칙이 있다. 이름의 앞글자는 대문자를 사용(일반적인 관례) 클래스명은 파일명과 같아야 하고 public 키워드가 붙어야 한다.(한 java 파일 안에 여러 클래스를 정의하는 것은 가능하지만 파일명과 같은 클래스만 public 키워드를 붙일 수 있다) 위에도 언급하였지만, 클래스를 설계할 때 클래스는 속성과 기능의 묶음이고, 그 클래스로 부터 생성될 객체들은 서로 식별이 가능하도록 설계해야 한다. 그래서 맴버변수에 각 학생들이 식별될 수 있는 고유번호 studentNum을 만든 것을 알 수 있다. 위 Student 클래스는 정의만 하였고 사용되지 않았다. 이를 사용하는 예제를 보자. 클래스 사용하기1234567891011121314public class StudentTest { public static void main(String[] args) { Student studentLee = new Student(); studentLee.studentId = 1; studentLee.studentName = \"이형석\"; studentLee.showStudentInfo(); Student studentKim = new Student(); studentKim.studentId = 2; studentKim.studentName = \"김종원\"; studentKim.showStudentInfo(); }} Student 클래스는 new Student()라는 선언을 통해 비로소 Student 객체로 생성된 것이다.(객체의 생성을 ‘인스턴스화 되었다’ 라고 불리기도 한다) 그리고 Student 객체를 사용하기 위해 Student 타입의 studentLee 라는 참조 변수로 참조하고 있는 것을 볼 수 있다.(객체를 참조한다고 하였는데, 정확한 뜻은 객체의 주솟값을 참조하고 있는 것 이다) 이처럼 정의한 클래스를 객체로 생성할 때는 new 키워드를 통해 생성할 수 있다. 이때 ‘객체를 생성한다’ 또는 ‘인스턴스화 한다’라고 한다. 그리고 위의 예제에서 전달하고자 하는 다른 부분은 똑같은 Student 클래스의 객체를 참조하는 studentLee와 studentKim은 서로 다른 객체라는 것 이다. 두 객체는 서로 다른 공간에 생성되어 다른 주소 값을 가지는 것을 알아두자. 인스턴스(Instance), 메모리 힙(Heap) 위 사진은 메모리의 구조를 나타낸다. 위 예제와 같이 새로운 객체를 생성하게 되면 1new Student(); 메모리의 힙이란 곳에 새로운 인스턴스가 만들어진다. (그래서 객체는 인스턴스라 불리기도 한다) 우리는 이것을 인스턴스화 한다라고 하고, 이 인스턴스는 자신의 주소 값을 가지고있다. 1new Student(); // ex) 3fb6a447 그리고 참조 변수는 이 인스턴스(객체)의 주소 값을 참조받는 것 이다. 1Student student = new Student(); // 3fb6a447 라는 주소 값을 참조한다. 조금 더 살을 붙이자면 이렇듯 new 로 생성된 인스턴스들은 각자 다른 공간에 만들어지고 주솟값도 다르기때문에, 같은 클래스로 만들어진 인스턴트들은 서로 다르다고 할 수 있다. 12new Student();// 객체 1, 주소 값 ex) 3fb6a447new Student();// 객체 2, 주소 값 ex) 79b4d0f 그리고 힙 영역은 프로그래머가 관리해야하는 영역이다. 생성된 객체가 사용되지 않으면 메모리에서 제거해주어야하는데, 자바는 가비지 컬랙터(Garbage Collector)가 필요한 타이밍에 알아서 관리해준다. 메모리 구조에 관한 내용은 원래 더욱 복잡한데, 다른 글에서 자세히 다루도록 하겠다.","link":"/2020/04/27/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-06-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"JAVA - 08. 생성자","text":"생성자(Constructor)란 무엇인가?우리는 이미 생성자를 한번 사용한 적이 있다. 객체를 생성할 때 new 키워드 다음에 선언한 클래스명() 이 생성자 이다. 1new Example(); 생성자 만들기생성자는 클래스명과 동일해야한다. 그리고 반환형도 없고 (이후에 배울)상속되지도 않는다. 생성자는 다음과 같이 선언할 수 있다. 1234public class Example{ //생성자 Example(){...}} 자바에서 클래스를 만들때 내부적으로 반드시 하나 이상의 생성자를 만들어야 하는 규칙이있다. 그런데 우리는 위와같이 생성자를 구현한 적이 없다. 그렇다면 지금까지 만든 클래스는 생성자가 없었는데 규칙을 어겼던 것일까? 자바는 컴파일을 할때 class에 생성자가 정의되어 있지않으면 디폴트 생성자(Default Constructor)라는 것을 만들어준다. 위와 같이 내용이 비어있는 빈껍대기인 생성자이다. 내부적으로 구현된 코드는 없지만 이로써 생성자를 하나 이상 만들어야 하는 규칙은 지켜지는 것 이다. 생성자의 사용생성자는 메소드와 같이 필요할 때 바로바로 호출하여 사용할 수 있는 것은 아니다. 생성자는 객체를 생성할때에만 호출이되며, 주로 맴버변수의 값을 초기와하는 역할을 한다. 다음 예제를 보자 12345678910111213141516171819class Student{ int studentId; String studentName; void showStudentInfo(){ System.out.println(\"학생번호:\"+studentId); System.out.println(\"학생이름:\"+studentName); }}class StudentTest{ public static void main(String[] args){ Student student = new Student(); student.studentId = 1; student.studentName = \"jaebeom\"; student.showStudentInfo(); }} 위의 예제에선 Student 객체를 생성한 이후 맴버변수에 접근하여 값을 넣고 학생정보를 보이고 있다. 하지만 생성이후 저렇게 정보를 보이기 위해 변수에 하나하나 값을 넣는 것은 비효율적으로 보인다. 그리고 이후에 나오는 ‘정보은닉’관점에서도 저 방법은 좋은 예제는 아니다. 이제 다음 예제를 보자 123456789101112131415161718192021class Student{ int studentId; String studentName; Student(int id, String name){ studentId = id; studentName = name; } void showStudentInfo(){ System.out.println(\"학생번호:\"+studentId); System.out.println(\"학생이름:\"+studentName); }}class StudentTest{ public static void main(String[] args){ Student student = new Student(1, \"jaebeom\"); student.showStudentInfo(); }} 위 예제는 생성자를 직접 정의하여 객체 생성 당시에 학생번호와 학생이름을 매개변수로 받아 맴버변수들을 초기화하는 예제이다. 불필요하게 맴버변수들을 불러와 값을 할당할 필요가 없어진 것 이다. 여기서 한가지 궁금한 적이 있다. 우리가 생성자를 직접 정의하였는데, 그렇다면 아무런 매개변수를 받지 않는 디폴트 생성자는 그대로 존재하는가? 결론은 ‘존재하지 않는다’ 이다. 우리가 직접 생성자를 정의하게되면 디폴트 생성자는 생성되지 않는다. 123456class StudentTest{ public static void main(String[] args){ new Student(1, \"jaebeom\"); new Student();//에러 }} 이전의 Student 클래스의 생성자를 정의했다고 가정하고 위와 같이 작성해보면, 매개변수를 받지 않는 생성자가 호출될 때 에러가 나는 것을 알 수 있다. 우리가 매개변수를 받지 않는 생성자를 정의하지 않았기 때문이다. 생성자 오버로딩(Overloading)생성자 오버로딩은 생성자의 이름을 같게 하고 매개변수의 수, 그리고 타입에 따라 여러개의 생성자를 만들어 내는 것을 말한다. (오버로딩은 이후의 메소드 오버로딩때 자세히 다루도록 한다) 예제를 살펴보자. 12345678class Student{ Student(){...} Student(String name){...} Student(String name, int id){...}} 위와 같이 똑같은 이름인 생성자들이 매개변수의 수, 그리고 타입에 따라 여러개를 정의하게 가능한 것을 알 수 있다. 즉 이전 예제인 Student 객체의 생성자 호출 문제는 다음과 같이 해결할 수 있다. 1234567891011121314151617181920212223242526class Student{ int studentId; String studentName; Student(){} Student(int id, String name){ studentId = id; studentName = name; } void showStudentInfo(){ System.out.println(\"학생번호:\"+studentId); System.out.println(\"학생이름:\"+studentName); }}class StudentTest{ public static void main(String[] args){ Student student1 = new Student(1, \"jaebeom\"); student.showStudentInfo(); Student student2 = new Student(); }} 아무런 매개변수를 받지 않는 생성자도 따로 정의하여 문제없이 호출하는 것을 알 수 있다. 이것이 생성자 오버로딩이 필요한 이유이다.","link":"/2020/04/27/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-08-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"title":"JAVA - 09. 참조 자료형","text":"참조 자료형(Reference Data Type)처음 자바에 대한 글을 작성할때 변수와 자료형에 대해 알아보았다. 그리고 자료형에는 기본 자료형과 참조 자료형이 있다고 하였다. 참조형에 대해선 그 당시에 다루지 않았는데, 참조 자료형은 클래스에 대한 기본적인 지식을 가지고 있어야 이해하기 편하다고 생각하였다. 참조 자료형은 자료형이 클래스이다. 우리가 자주 사용하는 String, 그리고 우리가 직접 정의한 Student 클래스도 참조 자료형이 될 수 있다. 기본 자료형은 int, char, double, boolean 과 같이 그 크기가 이미 정해져 있지만, 참조자료형은 참조하는 클래스에 따라 그 크기가 다르다. 참조 자료형 사용 예제이전에 학생 클래스를 만들어 학생의 고유번호와 이름을 받아 학생의 정보를 보여주는 일을 하는 클래스를 정의하였다. 12345public class StudentTest{ public static void main(String[] args){ Student studentGo = new Student(); }} 그리고 만든 학생 클래스를 객체로 생성하여 위와 같이 참조변수에 할당하였다. 이렇듯 참조변수를 main 메소드 안에서만 정의 하였는데, 참조변수는 클래스의 내부에 맴버변수로써도 사용할 수 있다. 학생 클래스를 만들었으니 학생마다 수강하는 과목을 만들고 싶다. 그리고 그 과목에 대한 점수도 받고싶다. 그렇다면 다음과 같이 작성하면 될까? 12345678910public class Student{ int studentId; String studentName; String subjectEng;//영어 int subjectEngScore;//영어점수 String subjectMath;//수학 int subjeectMathScore;//수학점수 ...} 위와 같이 과목을 하나하나 적는 것은 비효율 적일 것 같다. 게다가 과목이 갖는 점수 역시 따로 명시해주어야 한다. 우리는 위의 클래스를 Student 라 정의 하였다. 여기서 알 수 있는 것은 학생에 관련된 클래스라는 것 이다. 그렇다면 과목에 관련된 클래스 역시 따로 정의 할 수 있지 않을까? 한번 과목 클래스를 만들어보자. 12345public class Subject{ int subjectId;//과목 번호 String sbujectName;//과목 이름 int subjectScore;//과목 점수} 위와 같이 따로 과목에 대한 클래스를 정의할 수 있다. 그렇다면 학생 클래스에서 이 과목 클래스를 가져와 사용하는 예를 보자. 123456789101112131415public class Student{ int studentId; String studentName; //Subject형 참조변수 Subject eng; Subject math; Student(int id, String name){ studentId = id; studentName = name; Subject eng = new Subject(); Subject math = new Subject(); }} Subject 타입의 참조변수 eng와 math를 맴버변수로 선언한 뒤, 학생 객체의 생성자가 호출될때 동시에 Subject 객체가 생성되고 참조값을 참조하게 된다. 이로써 Student 객체가 생성이 되면 Subject 객체도 같이 생성되는것을 알 수 있다. (사실 위의 Subject를 통해 과목을 직접 나누는 것도 좋은 예는 아니지만 우리는 아직 배열과 리스트를 배우지 않았기 때문에 일단은 위와 같이 작성하자) 12345678910111213141516171819202122232425262728public class Student{ ... void setEngSubject(int id, String name, int score) { eng.subjectId = id; eng.subjectName = name; eng.subjectScore = score; } void setMathSubject(int id, String name, int score) { math.subjectId = id; math.subjectName = name; math.subjectScore = score; } void showStudentScore() { System.out.println(\"학생번호:\"+studentId); System.out.println(\"학생이름:\"+studentName); System.out.println(\"과목1:\"+eng.subjectName); System.out.println(\"점수:\"+eng.subjectScore); System.out.println(\"과목2:\"+math.subjectName); System.out.println(\"점수:\"+math.subjectScore); System.out.println(\"총 점수\"+(eng.subjectScore + math.subjectScore)); }} 그리고 Subject를 참조하긴 했지만, 과목번호와 , 과목이름, 과목점수등을 설정하지 않았기때문에 과목의 정보를 입력할 수 있는 메소드와, 학생정보 그리고 수강과목점수등을 보여주는 메소드를 만들었다. 이제 StudentTest에서 Student 객체를 생성하여 사용해보자. 12345678910111213141516public class StudentTest { public static void main(String[] args) { Student sJaebeom = new Student(1, \"재범\"); sJaebeom.setEngSubject(1, \"영어\", 50); sJaebeom.setMathSubject(2, \"수학\", 30); sJaebeom.showStudentScore(); System.out.println(); Student sJongwon = new Student(2, \"종원\"); sJongwon.setEngSubject(1, \"영어\", 40); sJongwon.setMathSubject(2, \"수학\", 70); sJongwon.showStudentScore(); }} StudentTest 클래스에서 테스트해보면 위와 같이 작성할 수 있다. 이번 글의 주제는 참조변수이지만, 참조변수를 다른 클래스에서 사용하여 객체끼리 상호작용을 하는 예제를 살짝 다루었다. 객체지향적인 프로그래밍은 이와 같이 서로 다른 객체가 맞물려서 작동하는 프로그램을 나타낸다.","link":"/2020/04/27/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-09-%EC%B0%B8%EC%A1%B0%20%EC%9E%90%EB%A3%8C%ED%98%95/"},{"title":"JAVA - 10. 정보 은닉","text":"정보 은닉자바에서 말하는 정보는 클래스의 인스턴스 변수를 의미한다. 따라서 정보를 은닉한다는 것은 인스턴스 변수를 숨긴다는 뜻이다. 자바에서는 ‘접근 제어자’(접근 제한자, 접근 제어 지시자 등 다양하게 불린다)를 통해 접근의 허용 수준을 결정할 때 선언하는 키워드를 제공한다. 접근 제어자접근 제어자의 종류는 다음과 같이 4가지 이다. public, protected, private, default 이중에서 default는 키워드가 아닌, 아무런 선언도 하지 않은 상황을 의미한다. 비록 이는 키워드가 아닌 일종의 상황이지만 이 역시 접근 제한자의 한 종류로 구분을 한다. 그리고 이러한 선언을 할 수 있는 대상은 다음 두 가지이다. 클래스의 정의 클래스의 맴버 변수와 메소드 클래스의 정의를 대상으로는 다음 두 가지 선언이 가능하다. 클래스 정의대상 : public ,default 그리고 맴버 변수와 메소드를 대상으로는 다음 네 가지 선언이 모두 가능하다. public, protected, private, default 그럼 이제 각각의 기능을 알아보자. 클래스 정의 대상의 public 과 default 선언이 갖는 의미 public : 어디서든 객체(인스턴스) 생성이 가능하다. default : 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용한다. 인스턴스 멤버 대상의 public , protected, private, default 선언이 갖는 의미 접근제한자 클래스 내부 동일 패키지 상속 받은 클래스 이외의 영역 private o x x x default o o x x protected o o o x public o o o o 위의 표에서 말하는 이외의 영역은 다른 패키지에 속한 클래스를 뜻한다. 즉 서로 다른 패키지에 속한 두 클래스 사이의 접근을 의미한다. 그리고 위 표의 내용을 기준으로 접근 허용 범위에 대하여 다음과 같이 이해하고 있는 것도 도움이 된다. public &gt; protected &gt; default &gt; private 정보 은닉이 필요한 이유우리가 어떠한 클래스를 정의한다고 생각해보자. 만약 사용자 입장에서 잘못된 조작을 할 수 있는 예외상황으로 인해 우리가만든 프로그램이 잘못사용될 경우 그 프로그램은 잘 짜여진 프로그램이 아닐 것 이다. 다음 예제를 보자 12345678910111213141516171819public class MyDate{ int day; int month; int year; public void showDate() { System.out.println( year + \"년\" + month + \"월 \" + day + \"일.\" ); }}public class MyDateTest{ public static void main(String[] args) { MyDate date = new MyDate(); date.day = 100; date.month = 100; date.year = 2019; date.showDate(); //2019년 100월 100일. 출력 }} 위 예제는 날짜값을 받아서 날짜를 출력하는 프로그램이다. 사용자가 맴버변수에 바로 접근하여 값을 할당하고, 그에 맞는 값이 출력되는 것을 볼 수 있다. 여기서 문제는 2019년 100월 100일 과 같은 날짜가 출력되는것이 정상인가? 존재하지 않는 날짜가 출력되기때문에 이는 잘못된 프로그램이라고 할 수 있다. 이와같이 사용자가 직접 값을 조작하면 예외 상황이 일어날 수 있는 코드들은 외부에서 접근하지 못하게 막아놓고 메소드를 통해 값을 받아 잘못된 값이 들어오면 조취를 취할 수 있게 하는 것이 정보은닉의 대표적인 예 이다. 다음 예제를 보자. 123456789101112131415161718192021222324252627282930313233343536public class MyDate { private int day; private int month; private int year; //조건이 유효한지 체크하는 변수 private boolean isValid = true; public void setDay(int day) { if(day &lt; 1 || day &gt; 31) isValid = false; else this.day = day; } public void setMonth(int month) { if( month &lt; 1 || month &gt; 12) isValid = false; else this.month = month; } public void setYear(int year) { if(year &lt; 1900 || year &gt; 2020) isValid = false; else this.year = year; } public void showDate() { if(isValid) System.out.println( year + \"년\" + month + \"월 \" + day + \"일.\" ); else System.out.println(\"정상적인 값이 아닙니다.\"); }} 맴버변수에 isValid 라는 변수를 true로 선언과 동시에 초기화 하였다. 유효성 검사를 하기위한 변수이다. 그리고 모든 맴버변수들을 private로 외부로부터 숨기고 각 변수들에게 값을 담을 수 있는 public 메소드들을 정의하였다. 그리고 이 메소드는 내부적으로 잘못된 값이 들어오면 isValid의 값을 false로 바꾼다. 이후에 날짜를 출력하는 showDate 메소드는 isValid의 값이 참일때 시간을 보여주고 거짓이면 실패 문구를 출력한다. 결과적으로 값이 하나라도 잘못 입력되면 날짜를 띄울 수 없게 만든 코드이다. 123456789public class MyDateTest{ public static void main(String[] args){ MyDate date = new MyDate(); date.setDay(0); date.setMonth(5); date.setYear(2020); date.showDate();//정상적인 값이 아닙니다. }} 위의 클래스를 MyDateTest 클래스에서 테스트해보면 잘못된 값이 하나라도 존재하면 ‘정상적인 값이 아닙니다.’(살짝 불친절한..) 문구가 나오는 것을 알 수 있다. 물론 값이 제대로 입력되면 정상적으로 날짜를 출력한다. 이와 같이 프로그램을 만들다보면 외부로부터의 접근을 숨겨야하는 정보들이 있다. 그러한 정보들은 외부로부터의 접근을 막고 만든이가 의도하는대로 사용자가 프로그램을 다루게 하는것이 정보 은닉이 필요한 이유라 생각한다.","link":"/2020/04/28/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-10-%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/"},{"title":"JAVA - 11. this 키워드","text":"this의 의미자바에서 제공하는 this 키워드는 인스턴스 자기 자신를 가리키는 키워드이다. 이 this 키워드를 통해 클래스 메서드 및 생성자에서 자기 자신의 데이터를 업데이트하거나 조작할 수 있다. this의 사용 예제this를 이용한 생성자 호출this를 이용하여 생성자를 호출하는 방법을 알아보자. 123456789101112131415161718public class ExampleTest { public static void main(String[] args) { new Person(0); }}public class Example{ Example(){ System.out.println(\"생성자 1\"); } Example(int num1, int num2){ System.out.println(\"생성자 2\"); } Example(int num){ this(3, 4); System.out.println(\"생성자 3\"); }} 위의 예제를 보면 this 키워드를 이용하여 다른 생성자를 호출하고있다. 정수를 하나 받는 인스턴트를 새로 호출하자, 생성자2, 생성자3 이 콘솔에 출력된다. 생성자 3이 사용이 되었는데 생성자 3에서는 this(3, 4) 라는 키워드가 먼저 작성되어있다.여기서 this는 오버로딩된 다른 생성자를 의미한다. 거기에 정수를 두개 받는 생성자를 찾기때문에 생성자 2가 먼저 호출이 되고 그다음 출력문을 만나 생성자 3이 콘솔에 찍히게 된다. this - 인스턴수 변수 접근앞서 키워드 this를 이용한 생성자의 호출에 대해 설명했는데, this는 다른 의미로도 사용이 된다. 이와 관련하여 다음 예제를 보자. 12345678910public class Example{ private String name; void setName(String name) { this.name = name; } String getName(){ return this.name; }} 위와 같이 매개변수의 이름이 인스턴스 변수의 이름과 동일하게 선언된 경우, 선언된 지역 내에서의 해당 이름은 매개변수를 의미하게 된다.하지만 키워드 this를 이용하면 이 영역 안에서도 인스턴스 변수에 접근할 수 있다. 즉 this.name에서 this가 의미하는 것은 ‘이 문장이 속한 인스턴스’ 이다. 따라서 this.name은 인스턴스 변수 name을 의미하는 것이 된다.","link":"/2020/04/28/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-11-this/"},{"title":"JAVA - 12. static 변수와 메소드","text":"static 변수static 변수는 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다. 인스턴스를 생성하면, 각 인스턴스들은 서로 독립적기 때문에 서로 다른 값을 유지하게된다. 경우에 따라서는 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우가 있는데 이때 static 변수를 사용하면 된다. 다음 예제를 보자. 12345678910111213141516public class Student{ private int studentId; private String studentName; public Student(int studentId, String studentName){ this.studentId = studentId; this.studentName = studentName; }}public class StudentTest{ public static void main(String[] args){ Student student1 = new Student(1, \"jaebeom\"); Student student2 = new Student(2, \"jongwon\"); }} 이전에 다루었던 학생 클래스이다. 위와 같이 학생을 식별하기위한 학생번호라는 속성을 주고 사용자가 직접 학생번호를 입력하고있다. 위와 같은 상황에 일어날 수 있는 일이 무엇이 있을까? 먼저 값을 하나하나 입력하기때문에 학생이 1000명일 경우 1부터 1000까지 직접 입력해야한다. 그리고 사용자가 직접 번호를 적다보면 잘못 입력하여 중복되는 값들이 생길 수 있다. 이것은 치명적인 문제가 될 것 이다. 이것을 개선한 다음 예제를 보자. 12345678910111213141516171819202122public class Student{ private static int serialNum = 0; private int studentId; private String studentName; public Student(String studentName){ this.studentName = studentName; serialNum++; studentId = serialNum; }}public class StudentTest{ public static void main(String[] args){ Student student1 = new Student(\"jaebeom\"); student1.showStudentInfo(); Student student2 = new Student(\"jongwon\"); student2.showStudentInfo(); }} Student 클래스의 속성으로 serialNum 이라는 static 변수(클래스 변수)가 추가되었다. 그리고 생성자가 호출될때마다 serialNum의 값을 1씩 증가시키고 studentId에 그 값을 할당하고있다. 위의 코드를 메모리 상태와 연관 지어보면 다음과 같이 될 것 이다. 위의 두 student1, student2 참조변수는 서로 다른 인스턴트를 참조하고 있기 때문에 맴버변수 또한 서로 다른 메모리를 사용한다. 하지만 static 변수는 선언 시 메모리 영역에 따로 할당이 되기때문에 Student 클래스를 통해 생성된 모든 인스턴트들은 이 값을 모두 공유하게 되는 것이다. 결론적으로 static 변수가 모든 인스턴스에 공유되는 특징을 이용하여 사용자가 직접 학생번호를 입력하지 않고도 생성자가 호출될 때 마다 알아서 학생의 번호가 증가되게 만들었다. 이렇듯 static 변수는 객체가 공유해야하는 값을 필요로 할 때 사용할 수 있다. static 변수 접근 방법static 변수도 ‘접근 수준 지시자’ 의 규칙을 그대로 적용받기 때문에 public으로 선언되면 어디서든 접근이 가능하다. 물론 접근 방법에 있어서는 차이를 보이는데 이와 관련된 내용은 이어서 설명하겠다. static 변수에 접근하는 방법은 접근 영역을 기준으로 다음과 같이 크게 두 가지로 나뉜다. 클래스 내부 접근 : 변수의 이름을 통해 직접 접근 클래스 외부 접근 : 클래스 또는 인스턴스의 이름을 통해 접근 다음예제를 보면서 static 변수의 접근 방법을 알아보자. 1234567891011121314151617181920212223class AccessWay{ static int num = 0; AccessWay(){ incrCnt(); } void incrCnt() { num++; //클래스 내부에서 이름을 통한 접근 }}public class AccessWayTest{ public static void main(String[] args) { AccessWay way = new AccessWay(); way.num++; //외부에서 인스턴스의 이름을 통한 접근 AccessWay.num++; //외부에서 클래스의 이름을 통한 접근 System.out.println(\"num = \" + AccessWay.num);// 총 3이 찍힌다. AccessWay way2 = new AccessWay();//way2라는 새로운 AccessWay의 인스턴스를 생성하였다. System.out.println(way2.num);//그리고 way2의 클래스변수 num을 조회 하였는데 값은 4가 찍힌다. }} 인스턴스의 이름을 통한 접근 방법을 보면서, static 변수를 인스턴스 내부에 위치한 것으로 오해하면 안된다. 그리고 static 변수 num은 default로 선언되었다. 따라서 클래스 내부는 물론 클래스 외부이더라도 동일 패키지로 묶여 있으면 접근이 가능하다. 인스턴트 변수(맴버 변수)와 static 변수(클래스 변수)의 차이맴버 변수 공간적 특성: 인스턴트 변수는 객체마다 별도로 존재한다.인스턴스 멤버 라고 부른다. 시간적 특성: 객체 생성 시에 인스턴트 변수가 생성된다. 객체가 생길 때 인스턴트 변수도 생성된다. 객체 생성 후 인스턴트 변수 사용이 가능하다. 객체가 사라지면 인스턴트 변수도 사라진다. 공유의 특성: 공유되지 않는다. 인스턴트 변수는 객체 내에 각각의 공간을 유지한다. static 변수 공간적 특성: static 변수는 클래스당 하나가 생성된다. static 변수는 객체 내부가 아닌 별도의 공간에 생성된다. 시간적 특성: 클래스 로딩 시에 static 변수가 생성된다. 객체가 생기기 전에 이미 생성된다. 객체가 생기기 전에도 사용이 가능하다. (객체를 생성하지 않고도 사용할 수 있다) 객체가 사라져도 static 변수는 사라지지 않는다. static 변수는 프로그램이 종료될 때 사라진다. 공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유된다. 클래스로딩앞서 설명에서 static 변수는 클래스 로딩시 생성된다고 하였는데, 이렇듯 가상머신이 특정 클래스 정보를 읽는 행위를 가리켜 클래스 로딩 이라 한다. 그리고 특정 클래스의 인스턴스 생성을 위해서는 해당 클래스가 반드시 가상머신에 의해 로딩되어야 한다. 즉 인스턴스 생성보다 클래스 로딩이 먼저이다. static 메소드클래스 내에 정의된 메소드에 static 선언을 하면 static 메소드(클래스 메소드)가 된다. 그리고 static 메소드는 그 성격이 static 변수와 유사하다. 접근 방법도 동일하며 인스턴스 생성 이전부터 호출이 가능한, 그리고 어느 인스턴스에도 속하지 않는 메소드라는 점도 static 변수와 동일하다. static 메소드의 정의와 호출static 변수의 특성 두 가지는 다음과 같다. 인스턴스 생성 이전부터 접근이 가능하다. 어느 인스턴스에도 속하지 않는다. 이 두 가지는 static 메소드도 동일하게 갖는 특성이다. 따라서 이 사실을 다음 예제를 통해서 확인해보겠다. 123456789101112131415161718192021222324252627282930313233public class NumberPrinter{ private int myNum = 0; static void showInt(int n) {//static 메소드 System.out.println(n); } static void showDouble(double n) {//static 메소드 System.out.println(n); } void setMyNumber(int n) {//인스턴스 메소드 myNum = n; } void showMyNumber() {//인스턴스 메소드 showInt(myNum); }}public class NumberPrinterTest { public static void main(String[] args) { NumberPrinter.showInt(50);// 클래스 이름을 통한 클래스 메소드 호출 /** * 사실 위의 문장만 보더라도 static 메소드가 어느 인스턴스에도 속하지 않는다는 사실을 알 수 있다. * 인스턴스 생성 이전에 호출이 되었기 때문이다. * 그리고 예제의 주석에서 설명하고 있듯이 클래스의 내부와 외부에서 static 메소드를 호출하는 방법은 * static 변수에 접근하는 방법과 차이가 없다. */ NumberPrinter np = new NumberPrinter(); np.showDouble(3.15); // 인스턴스 이름을 통한 클래스 메소드 호출 np.setMyNumber(30); np.showMyNumber(); }} 다음 질문에 답해보자. static 메소드에서 같은 클래스에 선언된 인스턴스 변수에 접근이 가능한가? 이는 다음과 같은 코드의 작성이 가능한지를 묻는 질문이다. 1234567public class Example { int num =0; static void addNum(int n) { num = n; }} 위의 코드는 에러가 난다. 논리적으로 생각을 하면 위와 같은 문장 구성이 불가능하다는 것을 알 수 있다. 인스턴스 변수는 인스턴스에 속한다. 더불어 인스턴스가 생성이 되어야 메모리 공간에 존재하게 된다. 반면 static 메소드는 인스턴스 생성 이전부터 호출이 가능하다. 따라서 위 질문에 대해서 다음과 같이 대답할 수 있다. static 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수에 접근이 불가능하다. 같은 이유로 static 메소드는 인스턴스 메소드의 호출도 불가능하다. 그러나 static 메소드 같은 클래스에 정의되어 있는 다른 static 메소드나 성격이 동일한 static 변수에는 접근이 가능하다.(당연한 얘기지만) System.out.println 그리고 main 메소드지금까지 main 메소드를 정의할 때 그 앞에 static 선언을 붙여왔다. 그리고 인스턴스의 생성 없이 println 메소드를 호출해 왔다. System.out.println()에서 out과 println의 정체는?static 선언의 의미를 알았으니 System.out.println()의 구성을 이해할 수 있다. 일단 System은 자바에서 제공하는 클래스로 java.lang 패키지에 묶여있다. 따라서 원칙적으로는 다음과 같이 호출해야 한다. java.lang.System.out.println(…); 그러나 컴파일러가 다음 문장은 삽입 해주기때문에 패키지의 이름부분은 생략할 수 있다. import java.lang.*; 그리고 out은 System.out으로 접근을 하니, 이는 분명 static으로 선언된 static 변수가 분명하다. 클래스의 이름을 통해 접근하니 말이다. 실제로 out은 System 클래스 내에 다음과 같이 선언된 static 변수이다. 1234public final class System extends Object{ public static final PrintStream out; //참조변수} 마지막으로 println은 PrintStream 클래스의 인스턴스 메소드이다. 따라서 다음 문장을 보면서, System.out.println(…); 다음과 같이 이해 할 수 있어야 한다. System에 위치한 클래스 변수 out이 참조하는 인스턴스의 println 메소드를 호출하는 문장 main 메소드가 public 이고 static인 이유에 대해서 알아보자.main 메소드는 반드시 다음의 모양새를 갖춰야 한다. 123public static void main(String[] args) { } 이렇듯 main 메소드는 public 으로 그리고 static으로 선언해야 한다. 이는 일종의 약속이다. main메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당함을 알 수 있다. 그리고 main메소드는 인스턴스가 생성되기 이전에 호출된다. 따라서 static 선언하는 것이 옳음을 알 수 있다. 다음의 예제를 보자. Car클래스와 Boat 클래스를 정의 하였다. 다음의 main 메소드가 호출이 되어 실제 실행이 되게 하려고 한다면 어떤 클래스에 두어야 할까? 1234567891011class Car{ void myCar() { System.out.println(\"밴츠\"); }}class Boat{ void myBoat() { System.out.println(\"보트\"); }} main 메소드는 static 메소드이기 때문에, 즉 특정 인스턴스의 맴버로 존재하는 메소드가 아니기 때문에 정답은 어디든 상관은 없다. (물론 실행방식에선 차이가 발생한다. Car클래스에 두었으면 java Car 를 호출, Boat면 java Boat 호출) 그렇다면 Car클래스에 두었다고 가정해보자. main 메소드를 Car 클래스 내에 위치시켰는데 그 안에서 Car 인스턴스를 생성하고 있다. 혹시 이부분이 조금 난해하게 느껴지는가? 그렇다면 다음과 같이 생각하자. Car클래스와 static으로 선언된 main메소드는 사실상 별개다. 다만 Car 클래스가 main 메소드에게 공간을 제공했을 뿐이다.","link":"/2020/04/29/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-12-Static%20%EB%B3%80%EC%88%98,%20%EB%A9%94%EC%86%8C%EB%93%9C/"},{"title":"JAVA - 13. static 응용 - Singleton","text":"싱글톤 패턴(Singleton Pattern)이란?싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다. 싱글톤이 사용되는 이유한번의 객체 생성으로 재 사용이 가능하기 때문에 메모리 낭비를 방지할 수 있다. 또한 싱글톤으로 생성된 객체는 무조건 한번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이하다. 싱글톤 예제우리가 프로그램을 만들다보면 단 하나만 존재해야 하는 인스턴스들이 존재할 수 있다. 예를 들어 특정 학교와 학생이라는 객체를 만든다고 할 때 학생은 다수 존재하기 때문에 생성자를 계속 만들어 사용해왔다. 하지만 학생들을 대상으로 학교는 1이상 생성하는 것은 비효율적 이므로 한번만 생성할 수 있게 만들어야 한다. 그렇다면 우리는 기술적으로 어떻게 객체를 최초 한번만 생성하게 할 수 있을까? 객체를 새로 생성할 때 우리는 생성자를 호출하여 만들 수 있다. 그렇다면 생성자를 외부에서 호출하지 못하게 막는다면 어떨까? 123public class School{ private School(){...}} 위와 같이 생성자를 private로 정의하면 직접 생성자를 정의하였기 때문에 자바가상머신이 디폴트 생성자를 만들어주지도 않는다. 즉 외부에서 생성자를 호출 할 수 없게 되는 것 이다. 하지만 위와 같은 상황에선 School 의 객체를 아예 생성할 수 없기 때문에 몇가지 코드를 더 추가해 주어야 한다. 12345678public class School{ private static School instance = new School(); private School(){...} public static School getInstance(){ return instance; }} private 는 클래스 내부에선 접근할 수 있기 때문에 내부에서 생성자를 호출하여 새로운 객체를 만들고 School타입의 참조변수에 할당된 것을 볼 수 있다. 그리고 getInstance 메소드를 통해 참조변수(생성된 객체의 주솟값을 참조) instance를 반환함으로써 외부에서 이 값을 통해 School 객체를 사용할 수 있을 것 이다. 여기서 중요한 것은 참조변수 instance가 static 변수라는 점 인데, 만약 instance가 non-static한 변수였다면 생성자를 통해 객체가 생성될 때 존재하게 될 것이다. 하지만 static 변수는 자바가상머신이 클래스를 읽어올때 생성되는 변수이다. 그렇기때문에 생성자를 호출하지 않아도 외부에서 클래스를 통해 사용되어질 수 있는 것 이다. 물론 정보은닉적인 관점에서 instance 변수 자체는 private 키워드를 통해 외부에서 조작하지 못하게 하고 getInstance 메소드를 통해서만 사용될 수 있게 하였다. 그렇다면 자연스럽게 getInstance 메소드가 static 메소드인 이유도 알 수 있다. 일반 인스턴스 메소드 역시 객체가 생성될때 사용할 수 있다. 때문에 static 메소드로 정의 함으로써 외부에서 클래스를 통해 바로 호출이 가능하게 해야하는 것 이다. 12345678public class SchoolTest { public static void main(String[] args) { School s1 = School.getInstance(); School s2 = School.getInstance(); System.out.println(s1); System.out.println(s2); }} SchoolTest 클래스를 테스트한 결과 School 클래스를 객체 생성없이 바로 getInstance() 를 호출하고 있다. getInstance가 반환하는 참조변수 instance는 클래스를 로딩하는 시점에서 객체가 생성되어 주솟값을 담고 있기때문에 참조변수의 값으로써 사용되어질 수 있다. 위의 참조변수 s1와 s2의 값을 출력해보면 test.School@79698539test.School@79698539 위와 같이 같은 인스턴스를 참조하고 있는 것을 알 수 있다. 싱글톤의 문제점전역성을 띄면서 다른 객체와 공통으로 사용하는 경우와 같은 몇 가지 케이스에서만 사용할 때 효율적이며 그 외에는 문제점이 생길 수 있다.일단 싱글톤으로 만든 객체의 역할이 간단한 것이 아닌 역할이 복잡한 경우라면 해당 싱글톤 객체를 사용하는 다른 객체간의 결함도가 높아져서 객체 지향 설계 원칙에 어긋나게 된다. (개방-폐쇄)","link":"/2020/04/29/java%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/JAVA-13-static%20%EC%9D%91%EC%9A%A9/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"java virtual machine","slug":"java-virtual-machine","link":"/tags/java-virtual-machine/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"java 변수","slug":"java-변수","link":"/tags/java-%EB%B3%80%EC%88%98/"},{"name":"식별자","slug":"식별자","link":"/tags/%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"name":"자료형","slug":"자료형","link":"/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"git page","slug":"git-page","link":"/tags/git-page/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo post","slug":"hexo-post","link":"/tags/hexo-post/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"hexo icarus theme","slug":"hexo-icarus-theme","link":"/tags/hexo-icarus-theme/"},{"name":"제어문","slug":"제어문","link":"/tags/%EC%A0%9C%EC%96%B4%EB%AC%B8/"},{"name":"if문","slug":"if문","link":"/tags/if%EB%AC%B8/"},{"name":"for문","slug":"for문","link":"/tags/for%EB%AC%B8/"},{"name":"while문","slug":"while문","link":"/tags/while%EB%AC%B8/"},{"name":"do while문","slug":"do-while문","link":"/tags/do-while%EB%AC%B8/"},{"name":"조건문","slug":"조건문","link":"/tags/%EC%A1%B0%EA%B1%B4%EB%AC%B8/"},{"name":"반복문","slug":"반복문","link":"/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"name":"상수","slug":"상수","link":"/tags/%EC%83%81%EC%88%98/"},{"name":"형변환","slug":"형변환","link":"/tags/%ED%98%95%EB%B3%80%ED%99%98/"},{"name":"메소드","slug":"메소드","link":"/tags/%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"나비보벳따우","slug":"나비보벳따우","link":"/tags/%EB%82%98%EB%B9%84%EB%B3%B4%EB%B2%B3%EB%94%B0%EC%9A%B0/"},{"name":"피아노","slug":"피아노","link":"/tags/%ED%94%BC%EC%95%84%EB%85%B8/"},{"name":"클래스","slug":"클래스","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"객체","slug":"객체","link":"/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"생성자","slug":"생성자","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"히로시의 회상","slug":"히로시의-회상","link":"/tags/%ED%9E%88%EB%A1%9C%EC%8B%9C%EC%9D%98-%ED%9A%8C%EC%83%81/"},{"name":"객체지향","slug":"객체지향","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"자바의 특징","slug":"자바의-특징","link":"/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%ED%8A%B9%EC%A7%95/"},{"name":"연산자","slug":"연산자","link":"/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"자바 연산자","slug":"자바-연산자","link":"/tags/%EC%9E%90%EB%B0%94-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"참조 자료형","slug":"참조-자료형","link":"/tags/%EC%B0%B8%EC%A1%B0-%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"객체지향 프로그래밍","slug":"객체지향-프로그래밍","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"힙","slug":"힙","link":"/tags/%ED%9E%99/"},{"name":"메모리 구조","slug":"메모리-구조","link":"/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/"},{"name":"자바","slug":"자바","link":"/tags/%EC%9E%90%EB%B0%94/"},{"name":"함수","slug":"함수","link":"/tags/%ED%95%A8%EC%88%98/"},{"name":"생성자 오버로딩","slug":"생성자-오버로딩","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/"},{"name":"정보 은닉","slug":"정보-은닉","link":"/tags/%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89/"},{"name":"접근 제어자","slug":"접근-제어자","link":"/tags/%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90/"},{"name":"접근 제한자","slug":"접근-제한자","link":"/tags/%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90/"},{"name":"static","slug":"static","link":"/tags/static/"},{"name":"singleton","slug":"singleton","link":"/tags/singleton/"},{"name":"싱글톤","slug":"싱글톤","link":"/tags/%EC%8B%B1%EA%B8%80%ED%86%A4/"}],"categories":[{"name":"웹 개발","slug":"웹-개발","link":"/categories/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/"},{"name":"github page & hexo","slug":"웹-개발/github-page-hexo","link":"/categories/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/github-page-hexo/"},{"name":"코로나 격리 운동","slug":"코로나-격리-운동","link":"/categories/%EC%BD%94%EB%A1%9C%EB%82%98-%EA%B2%A9%EB%A6%AC-%EC%9A%B4%EB%8F%99/"},{"name":"피아노","slug":"코로나-격리-운동/피아노","link":"/categories/%EC%BD%94%EB%A1%9C%EB%82%98-%EA%B2%A9%EB%A6%AC-%EC%9A%B4%EB%8F%99/%ED%94%BC%EC%95%84%EB%85%B8/"},{"name":"java 기초","slug":"웹-개발/java-기초","link":"/categories/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/java-%EA%B8%B0%EC%B4%88/"},{"name":"java 객체지향","slug":"웹-개발/java-객체지향","link":"/categories/%EC%9B%B9-%EA%B0%9C%EB%B0%9C/java-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"}]}